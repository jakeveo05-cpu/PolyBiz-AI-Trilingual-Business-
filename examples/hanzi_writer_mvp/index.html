<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PolyBiz AI - Hanzi Writer MVP</title>
    <script src="https://cdn.jsdelivr.net/npm/hanzi-writer@3.5/dist/hanzi-writer.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh; color: #fff; padding: 20px;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        h1 { text-align: center; margin-bottom: 10px; font-size: 1.8em; }
        .subtitle { text-align: center; color: #888; margin-bottom: 20px; }
        
        /* Performance Monitor */
        #perf-monitor {
            position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.8);
            padding: 15px; border-radius: 10px; font-family: monospace; font-size: 12px;
            z-index: 1000; min-width: 200px;
        }
        .perf-row { display: flex; justify-content: space-between; margin: 5px 0; }
        .perf-label { color: #888; }
        .perf-value { color: #4ade80; font-weight: bold; }
        .perf-warning { color: #fbbf24; }
        .perf-danger { color: #ef4444; }
</style>
</head>
<body>
    <div class="container">
        <h1>üÄÑ PolyBiz AI - Hanzi Writer MVP</h1>
        <p class="subtitle">Test hi·ªáu nƒÉng Air Writing + Character Animation</p>
        
        <!-- Performance Monitor -->
        <div id="perf-monitor">
            <div style="font-weight:bold; margin-bottom:10px; color:#60a5fa;">üìä Performance</div>
            <div class="perf-row"><span class="perf-label">FPS:</span><span id="fps" class="perf-value">--</span></div>
            <div class="perf-row"><span class="perf-label">Memory:</span><span id="memory" class="perf-value">--</span></div>
            <div class="perf-row"><span class="perf-label">CPU Load:</span><span id="cpu" class="perf-value">--</span></div>
            <div class="perf-row"><span class="perf-label">Hand Track:</span><span id="hand-status" class="perf-value">OFF</span></div>
            <hr style="border-color:#333; margin:10px 0;">
            <div class="perf-row"><span class="perf-label">Browser:</span><span id="browser" class="perf-value">--</span></div>
            <div class="perf-row"><span class="perf-label">Screen:</span><span id="screen" class="perf-value">--</span></div>
        </div>
</body>
</html>

        <!-- Main Content -->
        <div class="main-grid">
            <!-- Character Display -->
            <div class="card">
                <div class="card-header">
                    <span>üìö H·ªçc ch·ªØ</span>
                    <select id="char-select">
                        <option value="Â•Ω">Â•Ω (h«éo) - T·ªët</option>
                        <option value="‰Ω†">‰Ω† (n«ê) - B·∫°n</option>
                        <option value="Êàë">Êàë (w«í) - T√¥i</option>
                        <option value="‰ªñ">‰ªñ (tƒÅ) - Anh ·∫•y</option>
                        <option value="ÊòØ">ÊòØ (sh√¨) - L√†</option>
                        <option value="‰∏≠">‰∏≠ (zh≈çng) - Gi·ªØa</option>
                        <option value="ÂõΩ">ÂõΩ (gu√≥) - N∆∞·ªõc</option>
                        <option value="‰∫∫">‰∫∫ (r√©n) - Ng∆∞·ªùi</option>
                        <option value="Â§ß">Â§ß (d√†) - L·ªõn</option>
                        <option value="Â≠¶">Â≠¶ (xu√©) - H·ªçc</option>
                    </select>
                </div>
                <div class="char-display">
                    <div id="character-target" class="hanzi-box"></div>
                    <div class="char-info">
                        <div id="char-pinyin" class="pinyin">h«éo</div>
                        <div id="char-meaning" class="meaning">T·ªët, Th√≠ch</div>
                        <div id="char-radical" class="radical">B·ªô: Â•≥ (n·ªØ) + Â≠ê (con)</div>
                    </div>
                </div>
                <div class="btn-group">
                    <button id="btn-animate" class="btn btn-primary">‚ñ∂Ô∏è Animation</button>
                    <button id="btn-quiz" class="btn btn-success">‚úçÔ∏è Quiz Mode</button>
                </div>
            </div>

            <!-- Air Writing -->
            <div class="card">
                <div class="card-header">
                    <span>üéØ Air Writing <span style="background:#f59e0b;color:#000;padding:2px 6px;border-radius:4px;font-size:10px;margin-left:5px;">BETA</span></span>
                    <span id="air-status" class="status-badge status-off">Camera OFF</span>
                </div>
                <div class="air-writing-area">
                    <video id="webcam" autoplay playsinline></video>
                    <canvas id="draw-canvas"></canvas>
                    <div id="webcam-placeholder">
                        <div>üìπ</div>
                        <div>Click "B·∫≠t Camera" ƒë·ªÉ b·∫Øt ƒë·∫ßu</div>
                    </div>
                </div>
                <div class="btn-group">
                    <button id="btn-camera" class="btn btn-primary">üìπ B·∫≠t Camera</button>
                    <button id="btn-draw-toggle" class="btn btn-success" style="display:none;">‚úèÔ∏è Gi·ªØ ƒë·ªÉ v·∫Ω (Space)</button>
                    <button id="btn-undo" class="btn btn-secondary">‚Ü©Ô∏è Undo</button>
                    <button id="btn-clear" class="btn btn-secondary">üóëÔ∏è X√≥a</button>
                </div>
                <p style="font-size:11px;color:#888;margin-top:10px;text-align:center;">
                    Gi·ªØ ph√≠m <kbd style="background:#333;padding:2px 6px;border-radius:3px;">Space</kbd> ho·∫∑c n√∫t "Gi·ªØ ƒë·ªÉ v·∫Ω" khi mu·ªën v·∫Ω
                </p>
            </div>

            <!-- Practice Canvas -->
            <div class="card">
                <div class="card-header">
                    <span>‚úèÔ∏è Luy·ªán vi·∫øt (Chu·ªôt/Touch)</span>
                </div>
                <div id="practice-target" class="hanzi-box practice-box"></div>
                <div class="score-display">
                    <span>ƒêi·ªÉm: </span><span id="score">--</span>
                </div>
            </div>
        </div>

        <!-- Results -->
        <div class="card results-card">
            <div class="card-header">üìà K·∫øt qu·∫£ Test</div>
            <div id="test-results">
                <p>Nh·∫•n c√°c n√∫t ƒë·ªÉ test t·ª´ng t√≠nh nƒÉng. K·∫øt qu·∫£ s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y.</p>
            </div>
            <button id="btn-full-test" class="btn btn-warning" style="margin-top:15px;">
                üß™ Ch·∫°y Full Test (30 gi√¢y)
            </button>
        </div>
        
        <!-- SRS - Spaced Repetition System -->
        <div class="card srs-card">
            <div class="card-header">
                <span>üìä Th·ªëng k√™ & ƒê·ªÅ xu·∫•t √¥n t·∫≠p</span>
                <label style="font-size:12px;font-weight:normal;display:flex;align-items:center;gap:5px;">
                    <input type="checkbox" id="tts-toggle" checked> üîä Ph√°t √¢m
                </label>
            </div>
            <div class="srs-stats">
                <div class="srs-stat-item">
                    <span class="srs-stat-value" id="total-practice">0</span>
                    <span class="srs-stat-label">T·ªïng l∆∞·ª£t</span>
                </div>
                <div class="srs-stat-item">
                    <span class="srs-stat-value" id="avg-score">--%</span>
                    <span class="srs-stat-label">ƒêi·ªÉm TB</span>
                </div>
                <div class="srs-stat-item">
                    <span class="srs-stat-value" id="streak-count">0</span>
                    <span class="srs-stat-label">Streak üî•</span>
                </div>
            </div>
            
            <div class="srs-section">
                <div class="srs-section-title">üî¥ C·∫ßn √¥n t·∫≠p (sai nhi·ªÅu)</div>
                <div id="srs-weak" class="srs-char-list">
                    <span class="srs-empty">Ch∆∞a c√≥ d·ªØ li·ªáu</span>
                </div>
            </div>
            
            <div class="srs-section">
                <div class="srs-section-title">üü° ƒêang h·ªçc</div>
                <div id="srs-learning" class="srs-char-list">
                    <span class="srs-empty">Ch∆∞a c√≥ d·ªØ li·ªáu</span>
                </div>
            </div>
            
            <div class="srs-section">
                <div class="srs-section-title">üü¢ ƒê√£ thu·ªôc</div>
                <div id="srs-mastered" class="srs-char-list">
                    <span class="srs-empty">Ch∆∞a c√≥ d·ªØ li·ªáu</span>
                </div>
            </div>
            
            <div class="btn-group" style="margin-top:15px;">
                <button id="btn-suggest" class="btn btn-primary">üí° ƒê·ªÅ xu·∫•t √¥n t·∫≠p</button>
                <button id="btn-reset-srs" class="btn btn-secondary">üóëÔ∏è Reset d·ªØ li·ªáu</button>
            </div>
        </div>
    </div>

    <style>
        .main-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 20px; margin-bottom: 20px;
        }
        .card {
            background: rgba(255,255,255,0.05); border-radius: 15px;
            padding: 20px; backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .card-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 15px; font-weight: bold; font-size: 1.1em;
        }
        .hanzi-box {
            width: 200px; height: 200px; margin: 0 auto;
            background: rgba(255,255,255,0.1); border-radius: 10px;
        }
        .practice-box { background: #fff; }
        .char-display { text-align: center; margin-bottom: 15px; }
        .char-info { margin-top: 15px; }
        .pinyin { font-size: 1.5em; color: #60a5fa; }
        .meaning { font-size: 1.2em; margin: 5px 0; }
        .radical { color: #888; font-size: 0.9em; }
        
        .btn-group { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
        .btn {
            padding: 10px 20px; border: none; border-radius: 8px;
            cursor: pointer; font-size: 14px; transition: all 0.2s;
        }
        .btn-primary { background: #3b82f6; color: #fff; }
        .btn-success { background: #22c55e; color: #fff; }
        .btn-secondary { background: #6b7280; color: #fff; }
        .btn-warning { background: #f59e0b; color: #000; }
        .btn:hover { transform: scale(1.05); filter: brightness(1.1); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .btn-active { background: #16a34a !important; transform: scale(0.95); box-shadow: inset 0 2px 4px rgba(0,0,0,0.3); }
        
        .status-badge {
            padding: 4px 10px; border-radius: 20px; font-size: 12px;
        }
        .status-off { background: #ef4444; }
        .status-on { background: #22c55e; }
        
        .air-writing-area {
            position: relative; width: 100%; aspect-ratio: 4/3;
            background: #000; border-radius: 10px; overflow: hidden; margin-bottom: 15px;
        }
        #webcam {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            opacity: 0.15;
            filter: grayscale(100%);
            transform: scaleX(-1); /* Mirror camera */
        }
        #draw-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        }
        #webcam-placeholder {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center;
            align-items: center; color: #666; font-size: 14px;
        }
        #webcam-placeholder div:first-child { font-size: 48px; margin-bottom: 10px; }
        
        .score-display { text-align: center; margin-top: 15px; font-size: 1.2em; }
        #score { color: #4ade80; font-weight: bold; }
        
        .results-card { margin-top: 20px; }
        
        /* SRS Styles */
        .srs-card { margin-top: 20px; }
        .srs-stats {
            display: flex; justify-content: space-around; margin-bottom: 20px;
            padding: 15px; background: rgba(0,0,0,0.2); border-radius: 10px;
        }
        .srs-stat-item { text-align: center; }
        .srs-stat-value { display: block; font-size: 1.8em; font-weight: bold; color: #60a5fa; }
        .srs-stat-label { font-size: 0.85em; color: #888; }
        .srs-section { margin-bottom: 15px; }
        .srs-section-title { font-size: 0.9em; color: #aaa; margin-bottom: 8px; }
        .srs-char-list { display: flex; flex-wrap: wrap; gap: 8px; min-height: 40px; }
        .srs-char {
            display: inline-flex; flex-direction: column; align-items: center;
            padding: 8px 12px; background: rgba(255,255,255,0.1); border-radius: 8px;
            cursor: pointer; transition: all 0.2s;
        }
        .srs-char:hover { transform: scale(1.1); background: rgba(255,255,255,0.2); }
        .srs-char-hanzi { font-size: 1.5em; }
        .srs-char-score { font-size: 0.7em; color: #888; }
        .srs-char.weak { border-left: 3px solid #ef4444; }
        .srs-char.learning { border-left: 3px solid #f59e0b; }
        .srs-char.mastered { border-left: 3px solid #22c55e; }
        .srs-empty { color: #666; font-style: italic; font-size: 0.9em; }
        #test-results { 
            background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px;
            font-family: monospace; font-size: 13px; line-height: 1.6;
            max-height: 300px; overflow-y: auto;
        }
        
        select {
            background: rgba(255,255,255,0.1); color: #fff; border: 1px solid #444;
            padding: 5px 10px; border-radius: 5px;
        }
    </style>

    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>

    <script>
        // ============ PERFORMANCE MONITOR ============
        const perfData = {
            fps: [], memory: [], cpuStart: 0, frameCount: 0, lastTime: performance.now()
        };

        function updatePerformance() {
            const now = performance.now();
            perfData.frameCount++;
            
            if (now - perfData.lastTime >= 1000) {
                const fps = Math.round(perfData.frameCount * 1000 / (now - perfData.lastTime));
                perfData.fps.push(fps);
                document.getElementById('fps').textContent = fps;
                document.getElementById('fps').className = 
                    fps >= 30 ? 'perf-value' : fps >= 15 ? 'perf-warning' : 'perf-danger';
                
                if (performance.memory) {
                    const memMB = Math.round(performance.memory.usedJSHeapSize / 1048576);
                    perfData.memory.push(memMB);
                    document.getElementById('memory').textContent = memMB + ' MB';
                    document.getElementById('memory').className = 
                        memMB < 100 ? 'perf-value' : memMB < 200 ? 'perf-warning' : 'perf-danger';
                }
                
                perfData.frameCount = 0;
                perfData.lastTime = now;
            }
            requestAnimationFrame(updatePerformance);
        }

        // Browser & Screen info
        function getDeviceInfo() {
            const ua = navigator.userAgent;
            let browser = 'Unknown';
            if (ua.includes('Chrome')) browser = 'Chrome';
            else if (ua.includes('Firefox')) browser = 'Firefox';
            else if (ua.includes('Safari')) browser = 'Safari';
            else if (ua.includes('Edge')) browser = 'Edge';
            
            document.getElementById('browser').textContent = browser;
            document.getElementById('screen').textContent = 
                `${window.screen.width}x${window.screen.height}`;
            
            if (!performance.memory) {
                document.getElementById('memory').textContent = 'N/A';
            }
        }
</script>

    <script>
        // ============ HANZI WRITER ============
        let writer = null;
        let quizWriter = null;
        const charData = {
            'Â•Ω': { pinyin: 'h«éo', meaning: 'T·ªët, Th√≠ch', radical: 'Â•≥ (n·ªØ) + Â≠ê (con)' },
            '‰Ω†': { pinyin: 'n«ê', meaning: 'B·∫°n', radical: '‰∫ª (ng∆∞·ªùi) + Â∞î' },
            'Êàë': { pinyin: 'w«í', meaning: 'T√¥i', radical: 'Êâã (tay) + Êàà (gi√°o)' },
            '‰ªñ': { pinyin: 'tƒÅ', meaning: 'Anh ·∫•y', radical: '‰∫ª (ng∆∞·ªùi) + ‰πü' },
            'ÊòØ': { pinyin: 'sh√¨', meaning: 'L√†', radical: 'Êó• (m·∫∑t tr·ªùi) + Ê≠£' },
            '‰∏≠': { pinyin: 'zh≈çng', meaning: 'Gi·ªØa, Trung', radical: '‰∏® (n√©t s·ªï) + Âè£' },
            'ÂõΩ': { pinyin: 'gu√≥', meaning: 'N∆∞·ªõc, Qu·ªëc gia', radical: 'Âõó (bao v√¢y) + Áéâ' },
            '‰∫∫': { pinyin: 'r√©n', meaning: 'Ng∆∞·ªùi', radical: '‰∫∫ (ng∆∞·ªùi)' },
            'Â§ß': { pinyin: 'd√†', meaning: 'L·ªõn, To', radical: 'Â§ß (l·ªõn)' },
            'Â≠¶': { pinyin: 'xu√©', meaning: 'H·ªçc', radical: 'Â≠ê (con) + ÂÜñ' }
        };

        function initHanziWriter(char) {
            document.getElementById('character-target').innerHTML = '';
            writer = HanziWriter.create('character-target', char, {
                width: 200, height: 200,
                padding: 5,
                strokeAnimationSpeed: 1,
                delayBetweenStrokes: 200,
                strokeColor: '#3b82f6',
                radicalColor: '#ef4444',
                showOutline: true,
                showCharacter: true
            });
            
            const data = charData[char];
            document.getElementById('char-pinyin').textContent = data.pinyin;
            document.getElementById('char-meaning').textContent = data.meaning;
            document.getElementById('char-radical').textContent = 'B·ªô: ' + data.radical;
        }

        function initQuizWriter(char) {
            document.getElementById('practice-target').innerHTML = '';
            quizWriter = HanziWriter.create('practice-target', char, {
                width: 200, height: 200,
                padding: 5,
                showCharacter: false,
                showOutline: true,
                showHintAfterMisses: 3,
                highlightOnComplete: true,
                strokeColor: '#22c55e',
                drawingColor: '#3b82f6',
                outlineColor: '#ddd',
                highlightColor: '#4ade80'
            });
        }

        document.getElementById('btn-animate').addEventListener('click', () => {
            if (writer) writer.animateCharacter();
        });

        document.getElementById('btn-quiz').addEventListener('click', () => {
            const char = document.getElementById('char-select').value;
            initQuizWriter(char);
            quizWriter.quiz({
                onComplete: (data) => {
                    const score = Math.round((1 - data.totalMistakes / 10) * 100);
                    document.getElementById('score').textContent = Math.max(0, score) + '%';
                    logResult(`‚úÖ Quiz ho√†n th√†nh! ƒêi·ªÉm: ${Math.max(0, score)}%, L·ªói: ${data.totalMistakes}`);
                    
                    // SRS: L∆∞u k·∫øt qu·∫£
                    srsRecordPractice(char, Math.max(0, score));
                    
                    // TTS: Ph√°t √¢m ch·ªØ
                    if (document.getElementById('tts-toggle').checked) {
                        speakChinese(char);
                    }
                }
            });
        });

        document.getElementById('char-select').addEventListener('change', (e) => {
            initHanziWriter(e.target.value);
            currentChar = e.target.value; // C·∫≠p nh·∫≠t ch·ªØ m·∫´u air writing
            // X√≥a n√©t c≈© khi ƒë·ªïi ch·ªØ
            if (persistentCtx) {
                persistentCtx.clearRect(0, 0, persistentCanvas.width, persistentCanvas.height);
            }
        });
    </script>
    
    <script>
        // ============ SRS - SPACED REPETITION SYSTEM ============
        const SRS_KEY = 'polybiz_srs_data';
        
        // Load SRS data t·ª´ localStorage
        function srsLoadData() {
            const saved = localStorage.getItem(SRS_KEY);
            if (saved) {
                return JSON.parse(saved);
            }
            return {
                chars: {}, // { 'Â•Ω': { attempts: 5, totalScore: 420, lastPractice: timestamp, streak: 2 } }
                totalPractice: 0,
                currentStreak: 0,
                lastPracticeDate: null
            };
        }
        
        // Save SRS data
        function srsSaveData(data) {
            localStorage.setItem(SRS_KEY, JSON.stringify(data));
        }
        
        // Ghi nh·∫≠n k·∫øt qu·∫£ luy·ªán t·∫≠p
        function srsRecordPractice(char, score) {
            const data = srsLoadData();
            const today = new Date().toDateString();
            
            // C·∫≠p nh·∫≠t streak
            if (data.lastPracticeDate !== today) {
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                if (data.lastPracticeDate === yesterday.toDateString()) {
                    data.currentStreak++;
                } else {
                    data.currentStreak = 1;
                }
                data.lastPracticeDate = today;
            }
            
            // C·∫≠p nh·∫≠t char data
            if (!data.chars[char]) {
                data.chars[char] = { attempts: 0, totalScore: 0, lastPractice: 0, streak: 0 };
            }
            
            const charData = data.chars[char];
            charData.attempts++;
            charData.totalScore += score;
            charData.lastPractice = Date.now();
            
            // Streak cho t·ª´ng ch·ªØ (li√™n ti·∫øp ƒë·∫°t >= 80%)
            if (score >= 80) {
                charData.streak++;
            } else {
                charData.streak = 0;
            }
            
            data.totalPractice++;
            srsSaveData(data);
            srsUpdateUI();
        }
        
        // C·∫≠p nh·∫≠t UI
        function srsUpdateUI() {
            const data = srsLoadData();
            
            // Stats
            document.getElementById('total-practice').textContent = data.totalPractice;
            document.getElementById('streak-count').textContent = data.currentStreak;
            
            // T√≠nh ƒëi·ªÉm trung b√¨nh
            let totalScore = 0, totalAttempts = 0;
            Object.values(data.chars).forEach(c => {
                totalScore += c.totalScore;
                totalAttempts += c.attempts;
            });
            const avgScore = totalAttempts > 0 ? Math.round(totalScore / totalAttempts) : 0;
            document.getElementById('avg-score').textContent = avgScore + '%';
            
            // Ph√¢n lo·∫°i ch·ªØ
            const weak = [], learning = [], mastered = [];
            
            Object.entries(data.chars).forEach(([char, info]) => {
                const avg = Math.round(info.totalScore / info.attempts);
                const item = { char, avg, attempts: info.attempts, streak: info.streak };
                
                if (avg < 60 || info.streak === 0) {
                    weak.push(item);
                } else if (avg < 85 || info.streak < 3) {
                    learning.push(item);
                } else {
                    mastered.push(item);
                }
            });
            
            // Render lists
            renderSRSList('srs-weak', weak, 'weak');
            renderSRSList('srs-learning', learning, 'learning');
            renderSRSList('srs-mastered', mastered, 'mastered');
        }
        
        function renderSRSList(elementId, items, className) {
            const container = document.getElementById(elementId);
            if (items.length === 0) {
                container.innerHTML = '<span class="srs-empty">Ch∆∞a c√≥ d·ªØ li·ªáu</span>';
                return;
            }
            
            // Sort: weak by lowest score, others by attempts
            items.sort((a, b) => className === 'weak' ? a.avg - b.avg : b.attempts - a.attempts);
            
            container.innerHTML = items.map(item => `
                <div class="srs-char ${className}" onclick="selectChar('${item.char}')" title="Luy·ªán ${item.attempts} l·∫ßn, streak: ${item.streak}">
                    <span class="srs-char-hanzi">${item.char}</span>
                    <span class="srs-char-score">${item.avg}%</span>
                </div>
            `).join('');
        }
        
        // Click v√†o ch·ªØ ƒë·ªÉ ch·ªçn luy·ªán
        function selectChar(char) {
            document.getElementById('char-select').value = char;
            initHanziWriter(char);
            currentChar = char;
            if (persistentCtx) {
                persistentCtx.clearRect(0, 0, persistentCanvas.width, persistentCanvas.height);
            }
            // Scroll l√™n
            document.querySelector('.main-grid').scrollIntoView({ behavior: 'smooth' });
        }
        
        // ƒê·ªÅ xu·∫•t √¥n t·∫≠p (∆∞u ti√™n ch·ªØ y·∫øu + l√¢u kh√¥ng luy·ªán)
        document.getElementById('btn-suggest').addEventListener('click', () => {
            const data = srsLoadData();
            const chars = Object.entries(data.chars);
            
            if (chars.length === 0) {
                alert('Ch∆∞a c√≥ d·ªØ li·ªáu! H√£y luy·ªán vi·∫øt m·ªôt v√†i ch·ªØ tr∆∞·ªõc.');
                return;
            }
            
            // T√≠nh ƒëi·ªÉm ∆∞u ti√™n: ƒëi·ªÉm th·∫•p + l√¢u kh√¥ng luy·ªán = ∆∞u ti√™n cao
            const now = Date.now();
            const scored = chars.map(([char, info]) => {
                const avg = info.totalScore / info.attempts;
                const daysSince = (now - info.lastPractice) / (1000 * 60 * 60 * 24);
                const priority = (100 - avg) + daysSince * 10 - info.streak * 5;
                return { char, priority, avg: Math.round(avg) };
            });
            
            scored.sort((a, b) => b.priority - a.priority);
            const suggested = scored[0];
            
            selectChar(suggested.char);
            logResult(`üí° ƒê·ªÅ xu·∫•t √¥n: ${suggested.char} (ƒëi·ªÉm TB: ${suggested.avg}%)`);
        });
        
        // Reset SRS data
        document.getElementById('btn-reset-srs').addEventListener('click', () => {
            if (confirm('X√≥a to√†n b·ªô d·ªØ li·ªáu luy·ªán t·∫≠p?')) {
                localStorage.removeItem(SRS_KEY);
                srsUpdateUI();
                logResult('üóëÔ∏è ƒê√£ reset d·ªØ li·ªáu SRS');
            }
        });
        
        // ============ TTS - TEXT TO SPEECH ============
        function speakChinese(text) {
            if (!('speechSynthesis' in window)) {
                console.warn('TTS kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£');
                return;
            }
            
            // Cancel any ongoing speech
            speechSynthesis.cancel();
            
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'zh-CN';
            utterance.rate = 0.8; // Ch·∫≠m h∆°n ƒë·ªÉ nghe r√µ
            utterance.pitch = 1;
            
            // T√¨m voice ti·∫øng Trung
            const voices = speechSynthesis.getVoices();
            const chineseVoice = voices.find(v => v.lang.includes('zh'));
            if (chineseVoice) {
                utterance.voice = chineseVoice;
            }
            
            speechSynthesis.speak(utterance);
        }
        
        // Preload voices
        if ('speechSynthesis' in window) {
            speechSynthesis.getVoices();
            speechSynthesis.onvoiceschanged = () => speechSynthesis.getVoices();
        }
    </script>

    <script>
        // ============ AIR WRITING (MediaPipe) ============
        let camera = null;
        let hands = null;
        let isDrawing = false;
        let lastPoint = null;
        let persistentCanvas = null;
        let persistentCtx = null;
        let positionHistory = [];
        const SMOOTH_FACTOR = 8; // TƒÉng l√™n ƒë·ªÉ m∆∞·ª£t h∆°n
        const MIN_MOVE_DISTANCE = 2; // Gi·∫£m xu·ªëng ƒë·ªÉ n√©t li·ªÅn h∆°n
        let lastDrawTime = 0;
        const DRAW_INTERVAL = 12; // Nhanh h∆°n ƒë·ªÉ b·∫Øt g√≥c
        let currentChar = 'Â•Ω';
        let handDistance = 0;
        
        // Auto-connect settings
        const AUTO_CONNECT_DISTANCE = 30;
        const MAX_JUMP_DISTANCE = 80;
        let lastStrokeEnd = null;
        let strokeCount = 0;
        
        // Stroke history for undo
        let strokeHistory = [];
        let currentStroke = [];
        
        // Direction detection for corners
        let lastDirection = null;
        const CORNER_ANGLE_THRESHOLD = 45;
        
        // Grid bounds (s·∫Ω ƒë∆∞·ª£c set khi v·∫Ω)
        let gridBounds = { x: 0, y: 0, size: 280 };
        
        // Stability check
        let handStableFrames = 0;
        const STABLE_FRAMES_REQUIRED = 5;
        let lastHandPosition = null;
        
        // CH·∫æ ƒê·ªò V·∫º - d√πng ph√≠m Space ho·∫∑c n√∫t ƒë·ªÉ toggle
        let drawingEnabled = false;
        
        const drawCanvas = document.getElementById('draw-canvas');
        const drawCtx = drawCanvas.getContext('2d');
        const video = document.getElementById('webcam');

        async function initCamera() {
            const placeholder = document.getElementById('webcam-placeholder');
            const statusBadge = document.getElementById('air-status');
            const handStatus = document.getElementById('hand-status');
            
            try {
                logResult('üìπ ƒêang kh·ªüi t·∫°o camera...');
                
                hands = new Hands({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
                });
                
                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1, // Full model cho ch√≠nh x√°c h∆°n
                    minDetectionConfidence: 0.8,
                    minTrackingConfidence: 0.8
                });
                
                hands.onResults(onHandResults);
                
                camera = new Camera(video, {
                    onFrame: async () => {
                        await hands.send({ image: video });
                    },
                    width: 640,
                    height: 480
                });
                
                await camera.start();
                
                placeholder.style.display = 'none';
                statusBadge.textContent = 'Camera ON';
                statusBadge.className = 'status-badge status-on';
                handStatus.textContent = 'Tracking...';
                handStatus.className = 'perf-value';
                
                drawCanvas.width = 640;
                drawCanvas.height = 480;
                
                persistentCanvas = document.createElement('canvas');
                persistentCanvas.width = 640;
                persistentCanvas.height = 480;
                persistentCtx = persistentCanvas.getContext('2d');
                
                logResult('‚úÖ Camera ƒë√£ b·∫≠t!');
                logResult('üëÜ Gi·ªØ ph√≠m SPACE ƒë·ªÉ v·∫Ω, th·∫£ ra ƒë·ªÉ nh·∫•c b√∫t');
                logResult('üñêÔ∏è X√≤e tay ƒë·ªÉ x√≥a');
                
                // Hi·ªán n√∫t v·∫Ω
                document.getElementById('btn-draw-toggle').style.display = 'inline-block';
                
            } catch (err) {
                logResult('‚ùå L·ªói camera: ' + err.message);
                statusBadge.textContent = 'L·ªói';
                statusBadge.className = 'status-badge status-off';
            }
        }

        function isFingerExtended(landmarks, fingerTip, fingerPip, fingerMcp) {
            return landmarks[fingerTip].y < landmarks[fingerPip].y && 
                   landmarks[fingerPip].y < landmarks[fingerMcp].y;
        }
        
        function isFingerFolded(landmarks, fingerTip, fingerPip) {
            // Ng√≥n tay g·∫≠p khi tip TH·∫§P h∆°n pip (g·∫ßn l√≤ng b√†n tay)
            return landmarks[fingerTip].y > landmarks[fingerPip].y;
        }
        
        function detectGesture(landmarks) {
            // Ki·ªÉm tra t·ª´ng ng√≥n
            const indexTip = landmarks[8], indexPip = landmarks[6], indexMcp = landmarks[5];
            const middleTip = landmarks[12], middlePip = landmarks[10], middleMcp = landmarks[9];
            const ringTip = landmarks[16], ringPip = landmarks[14], ringMcp = landmarks[13];
            const pinkyTip = landmarks[20], pinkyPip = landmarks[18], pinkyMcp = landmarks[17];
            const thumbTip = landmarks[4], thumbIp = landmarks[3], thumbMcp = landmarks[2];
            
            // Ng√≥n tr·ªè du·ªói th·∫≥ng ho√†n to√†n
            const indexStraight = indexTip.y < indexPip.y && indexPip.y < indexMcp.y;
            // Ng√≥n tr·ªè g·∫≠p
            const indexFolded = indexTip.y > indexPip.y;
            
            // 3 ng√≥n c√≤n l·∫°i g·∫≠p (n·∫Øm tay)
            const middleFolded = middleTip.y > middlePip.y;
            const ringFolded = ringTip.y > ringPip.y;
            const pinkyFolded = pinkyTip.y > pinkyPip.y;
            const othersFolded = middleFolded && ringFolded && pinkyFolded;
            
            // 4 ng√≥n du·ªói (x√≤e tay)
            const indexExtended = indexTip.y < indexMcp.y;
            const middleExtended = middleTip.y < middleMcp.y;
            const ringExtended = ringTip.y < ringMcp.y;
            const pinkyExtended = pinkyTip.y < pinkyMcp.y;
            const allExtended = indexExtended && middleExtended && ringExtended && pinkyExtended;
            
            // GESTURE 1: V·∫º - N·∫Øm tay + CH·ªà ng√≥n tr·ªè du·ªói th·∫≥ng
            if (indexStraight && othersFolded) {
                return 'DRAW';
            }
            
            // GESTURE 2: X√ìA - X√≤e c·∫£ b√†n tay (4 ng√≥n du·ªói)
            if (allExtended) {
                return 'ERASE';
            }
            
            // GESTURE 3: NH·∫§C B√öT - N·∫Øm tay ho√†n to√†n (t·∫•t c·∫£ ng√≥n g·∫≠p)
            if (indexFolded && othersFolded) {
                return 'LIFT';
            }
            
            // Kh√¥ng nh·∫≠n di·ªán ƒë∆∞·ª£c gesture chu·∫©n
            return 'NONE';
        }
        
        function getHandOrientation(landmarks) {
            const wrist = landmarks[0];
            const middleMcp = landmarks[9];
            return middleMcp.y < wrist.y;
        }
        
        function smoothPosition(x, y) {
            positionHistory.push({ x, y, time: Date.now() });
            if (positionHistory.length > SMOOTH_FACTOR) {
                positionHistory.shift();
            }
            
            // T√≠nh h∆∞·ªõng di chuy·ªÉn hi·ªán t·∫°i
            let currentDirection = null;
            if (positionHistory.length >= 2) {
                const prev = positionHistory[positionHistory.length - 2];
                const curr = positionHistory[positionHistory.length - 1];
                currentDirection = Math.atan2(curr.y - prev.y, curr.x - prev.x) * 180 / Math.PI;
            }
            
            // Ki·ªÉm tra c√≥ ƒë·ªïi h∆∞·ªõng ƒë·ªôt ng·ªôt kh√¥ng
            let isCorner = false;
            if (lastDirection !== null && currentDirection !== null) {
                let angleDiff = Math.abs(currentDirection - lastDirection);
                if (angleDiff > 180) angleDiff = 360 - angleDiff;
                isCorner = angleDiff > CORNER_ANGLE_THRESHOLD;
            }
            lastDirection = currentDirection;
            
            // N·∫øu l√† g√≥c g·∫•p kh√∫c, d√πng √≠t smooth h∆°n
            const effectiveSmooth = isCorner ? 2 : SMOOTH_FACTOR;
            const recentPoints = positionHistory.slice(-effectiveSmooth);
            
            let totalWeight = 0;
            let avgX = 0, avgY = 0;
            recentPoints.forEach((p, i) => {
                const weight = i + 1;
                avgX += p.x * weight;
                avgY += p.y * weight;
                totalWeight += weight;
            });
            
            return { 
                x: avgX / totalWeight, 
                y: avgY / totalWeight,
                isCorner: isCorner
            };
        }

        function onHandResults(results) {
            // X√≥a canvas
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            
            // V·∫Ω grid √¥ ch·ªØ ·ªü gi·ªØa
            const gridSize = 340;
            const gridX = (drawCanvas.width - gridSize) / 2;
            const gridY = (drawCanvas.height - gridSize) / 2 + 15;
            
            // L∆∞u grid bounds ƒë·ªÉ check
            gridBounds = { x: gridX, y: gridY, size: gridSize };
            
            // N·ªÅn √¥ ch·ªØ - s√°ng h∆°n
            drawCtx.fillStyle = 'rgba(255, 255, 255, 0.08)';
            drawCtx.fillRect(gridX, gridY, gridSize, gridSize);
            
            // Vi·ªÅn √¥ ch·ªØ - ƒë·∫≠m h∆°n
            drawCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            drawCtx.lineWidth = 3;
            drawCtx.strokeRect(gridX, gridY, gridSize, gridSize);
            
            // ƒê∆∞·ªùng ch√©o (Á±≥Â≠óÊ†º)
            drawCtx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            drawCtx.lineWidth = 1;
            drawCtx.setLineDash([5, 5]);
            
            // ƒê∆∞·ªùng ngang gi·ªØa
            drawCtx.beginPath();
            drawCtx.moveTo(gridX, gridY + gridSize/2);
            drawCtx.lineTo(gridX + gridSize, gridY + gridSize/2);
            drawCtx.stroke();
            
            // ƒê∆∞·ªùng d·ªçc gi·ªØa
            drawCtx.beginPath();
            drawCtx.moveTo(gridX + gridSize/2, gridY);
            drawCtx.lineTo(gridX + gridSize/2, gridY + gridSize);
            drawCtx.stroke();
            
            // ƒê∆∞·ªùng ch√©o
            drawCtx.beginPath();
            drawCtx.moveTo(gridX, gridY);
            drawCtx.lineTo(gridX + gridSize, gridY + gridSize);
            drawCtx.stroke();
            
            drawCtx.beginPath();
            drawCtx.moveTo(gridX + gridSize, gridY);
            drawCtx.lineTo(gridX, gridY + gridSize);
            drawCtx.stroke();
            
            drawCtx.setLineDash([]); // Reset dash
            
            // V·∫Ω ch·ªØ m·∫´u m·ªù ·ªü gi·ªØa
            if (currentChar) {
                drawCtx.font = `${gridSize * 0.8}px "Noto Sans SC", "Microsoft YaHei", sans-serif`;
                drawCtx.fillStyle = 'rgba(100, 150, 255, 0.15)';
                drawCtx.textAlign = 'center';
                drawCtx.textBaseline = 'middle';
                drawCtx.fillText(currentChar, gridX + gridSize/2, gridY + gridSize/2 + 10);
            }
            
            // V·∫Ω l·∫°i n√©t ƒë√£ l∆∞u
            if (persistentCtx) {
                drawCtx.drawImage(persistentCanvas, 0, 0);
            }
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // T√≠nh kho·∫£ng c√°ch tay (d·ª±a v√†o k√≠ch th∆∞·ªõc b√†n tay tr√™n m√†n h√¨nh)
                const wrist = landmarks[0];
                const middleTip = landmarks[12];
                handDistance = Math.sqrt(
                    Math.pow(middleTip.x - wrist.x, 2) + 
                    Math.pow(middleTip.y - wrist.y, 2)
                );
                
                // Hi·ªÉn th·ªã h∆∞·ªõng d·∫´n kho·∫£ng c√°ch
                let distanceStatus = '';
                let distanceColor = '#888';
                if (handDistance < 0.15) {
                    distanceStatus = 'üìè ƒê∆∞a tay L·∫†I G·∫¶N camera h∆°n';
                    distanceColor = '#ef4444';
                } else if (handDistance > 0.35) {
                    distanceStatus = 'üìè ƒê∆∞a tay RA XA camera h∆°n';
                    distanceColor = '#ef4444';
                } else {
                    distanceStatus = '‚úÖ Kho·∫£ng c√°ch t·ªët';
                    distanceColor = '#22c55e';
                }
                
                // V·∫Ω h∆∞·ªõng d·∫´n kho·∫£ng c√°ch
                drawCtx.font = '14px sans-serif';
                drawCtx.fillStyle = distanceColor;
                drawCtx.textAlign = 'center';
                drawCtx.fillText(distanceStatus, drawCanvas.width/2, 25);
                
                // Nh·∫≠n di·ªán gesture
                const gesture = detectGesture(landmarks);
                const handUp = getHandOrientation(landmarks);
                
                const indexTip = landmarks[8];
                const palmCenter = landmarks[9];
                const rawX = (1 - indexTip.x) * drawCanvas.width;
                const rawY = indexTip.y * drawCanvas.height;
                const palmX = (1 - palmCenter.x) * drawCanvas.width;
                const palmY = palmCenter.y * drawCanvas.height;
                
                const smoothed = smoothPosition(rawX, rawY);
                const x = smoothed.x;
                const y = smoothed.y;
                
                // Ki·ªÉm tra ng√≥n tr·ªè c√≥ trong v√πng v·∫Ω kh√¥ng
                const inGrid = x >= gridBounds.x && x <= gridBounds.x + gridBounds.size &&
                               y >= gridBounds.y && y <= gridBounds.y + gridBounds.size;
                
                // Ki·ªÉm tra l√≤ng b√†n tay c√≥ trong v√πng x√≥a kh√¥ng (m·ªü r·ªông v√πng cho d·ªÖ x√≥a)
                const eraseMargin = 60; // Cho ph√©p x√≥a r·ªông h∆°n √¥ ch·ªØ m·ªôt ch√∫t
                const palmInGrid = palmX >= gridBounds.x - eraseMargin && 
                                   palmX <= gridBounds.x + gridBounds.size + eraseMargin &&
                                   palmY >= gridBounds.y - eraseMargin && 
                                   palmY <= gridBounds.y + gridBounds.size + eraseMargin;
                
                // Ki·ªÉm tra x√≤e tay ƒë·ªÉ x√≥a - d√πng palmInGrid thay v√¨ inGrid
                if (gesture === 'ERASE') {
                    // T√≠nh kho·∫£ng c√°ch ng√≥n tr·ªè - ng√≥n c√°i ƒë·ªÉ ƒëi·ªÅu ch·ªânh k√≠ch th∆∞·ªõc x√≥a
                    const thumbTip = landmarks[4];
                    const indexTipLm = landmarks[8];
                    const pinchDist = Math.sqrt(
                        Math.pow((thumbTip.x - indexTipLm.x) * drawCanvas.width, 2) + 
                        Math.pow((thumbTip.y - indexTipLm.y) * drawCanvas.height, 2)
                    );
                    
                    // Map kho·∫£ng c√°ch pinch -> k√≠ch th∆∞·ªõc x√≥a (15px - 80px)
                    // B√≥p s√°t = nh·ªè (15px), x√≤e r·ªông = l·ªõn (80px)
                    const minEraseSize = 15;
                    const maxEraseSize = 80;
                    const minPinch = 30;  // Kho·∫£ng c√°ch t·ªëi thi·ªÉu khi b√≥p
                    const maxPinch = 150; // Kho·∫£ng c√°ch t·ªëi ƒëa khi x√≤e
                    const eraseSize = Math.min(maxEraseSize, Math.max(minEraseSize,
                        minEraseSize + (pinchDist - minPinch) / (maxPinch - minPinch) * (maxEraseSize - minEraseSize)
                    ));
                    
                    // V·ªã tr√≠ x√≥a = gi·ªØa ng√≥n tr·ªè v√† ng√≥n c√°i
                    const eraseX = (1 - (thumbTip.x + indexTipLm.x) / 2) * drawCanvas.width;
                    const eraseY = ((thumbTip.y + indexTipLm.y) / 2) * drawCanvas.height;
                    
                    // Check v·ªã tr√≠ x√≥a trong grid
                    const eraseInGrid = eraseX >= gridBounds.x - eraseMargin && 
                                        eraseX <= gridBounds.x + gridBounds.size + eraseMargin &&
                                        eraseY >= gridBounds.y - eraseMargin && 
                                        eraseY <= gridBounds.y + gridBounds.size + eraseMargin;
                    
                    // Lu√¥n hi·ªán v√≤ng tr√≤n x√≥a ƒë·ªÉ user th·∫•y v·ªã tr√≠
                    drawCtx.beginPath();
                    drawCtx.arc(eraseX, eraseY, eraseSize, 0, 2 * Math.PI);
                    drawCtx.strokeStyle = eraseInGrid ? '#ef4444' : '#666';
                    drawCtx.lineWidth = 2;
                    drawCtx.stroke();
                    drawCtx.fillStyle = eraseInGrid ? 'rgba(239, 68, 68, 0.2)' : 'rgba(100, 100, 100, 0.1)';
                    drawCtx.fill();
                    
                    // Ch·ªâ x√≥a khi trong v√πng
                    if (eraseInGrid && persistentCtx) {
                        persistentCtx.globalCompositeOperation = 'destination-out';
                        persistentCtx.beginPath();
                        persistentCtx.arc(eraseX, eraseY, eraseSize, 0, 2 * Math.PI);
                        persistentCtx.fill();
                        persistentCtx.globalCompositeOperation = 'source-over';
                        
                        document.getElementById('hand-status').textContent = `üßπ X√≥a (${Math.round(eraseSize)}px)`;
                        document.getElementById('hand-status').className = 'perf-danger';
                    } else {
                        document.getElementById('hand-status').textContent = `üñêÔ∏è V√†o √¥ ƒë·ªÉ x√≥a (${Math.round(eraseSize)}px)`;
                        document.getElementById('hand-status').className = 'perf-warning';
                    }
                    
                    lastPoint = null;
                    isDrawing = false;
                    return;
                }
                
                // V·∫º CH·ªà KHI GI·ªÆ PH√çM SPACE
                if (drawingEnabled && inGrid) {
                    const now = Date.now();
                    
                    if (!lastPoint) {
                        lastPoint = { x, y };
                        lastDrawTime = now;
                        strokeCount++;
                        currentStroke = [{ x, y }];
                    }
                    
                    if (lastPoint && persistentCtx && (now - lastDrawTime) >= DRAW_INTERVAL) {
                        const dist = Math.sqrt(Math.pow(x - lastPoint.x, 2) + Math.pow(y - lastPoint.y, 2));
                        
                        if (dist >= MIN_MOVE_DISTANCE && dist < MAX_JUMP_DISTANCE) {
                            persistentCtx.beginPath();
                            persistentCtx.moveTo(lastPoint.x, lastPoint.y);
                            persistentCtx.lineTo(x, y);
                            persistentCtx.strokeStyle = '#3b82f6';
                            persistentCtx.lineWidth = 5;
                            persistentCtx.lineCap = 'round';
                            persistentCtx.lineJoin = 'round';
                            persistentCtx.stroke();
                            
                            currentStroke.push({ x, y });
                            lastPoint = { x, y };
                            lastDrawTime = now;
                        }
                    }
                    isDrawing = true;
                    
                    drawCtx.beginPath();
                    drawCtx.arc(x, y, 10, 0, 2 * Math.PI);
                    drawCtx.fillStyle = '#22c55e';
                    drawCtx.fill();
                    
                    document.getElementById('hand-status').textContent = `‚úçÔ∏è ƒêang v·∫Ω | N√©t: ${strokeCount}`;
                    document.getElementById('hand-status').className = 'perf-value';
                    
                } else {
                    // Kh√¥ng v·∫Ω - ch·ªâ tracking
                    if (isDrawing && currentStroke.length > 0) {
                        strokeHistory.push([...currentStroke]);
                        lastStrokeEnd = lastPoint;
                    }
                    lastPoint = null;
                    isDrawing = false;
                    currentStroke = [];
                    
                    drawCtx.beginPath();
                    drawCtx.arc(x, y, 6, 0, 2 * Math.PI);
                    drawCtx.fillStyle = inGrid ? 'rgba(249, 158, 11, 0.7)' : 'rgba(255, 100, 100, 0.5)';
                    drawCtx.fill();
                    
                    const msg = inGrid ? 'üëÜ Gi·ªØ SPACE ƒë·ªÉ v·∫Ω' : '‚ö†Ô∏è V√†o √¥ ch·ªØ';
                    document.getElementById('hand-status').textContent = msg;
                    document.getElementById('hand-status').className = 'perf-warning';
                }
            } else {
                document.getElementById('hand-status').textContent = 'üñêÔ∏è Kh√¥ng th·∫•y tay';
                document.getElementById('hand-status').className = 'perf-danger';
                lastPoint = null;
                isDrawing = false;
                positionHistory = [];
                handStableFrames = 0;
                lastHandPosition = null;
            }
        }

        document.getElementById('btn-camera').addEventListener('click', initCamera);
        
        // SPACE KEY ƒë·ªÉ v·∫Ω
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && camera) {
                e.preventDefault();
                drawingEnabled = true;
                document.getElementById('btn-draw-toggle').classList.add('btn-active');
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                drawingEnabled = false;
                document.getElementById('btn-draw-toggle').classList.remove('btn-active');
                // L∆∞u stroke khi th·∫£ ph√≠m
                if (isDrawing && currentStroke.length > 0) {
                    strokeHistory.push([...currentStroke]);
                    lastStrokeEnd = lastPoint;
                }
                lastPoint = null;
                isDrawing = false;
                currentStroke = [];
            }
        });
        
        // N√öT "Gi·ªØ ƒë·ªÉ v·∫Ω" - mouse events
        const btnDrawToggle = document.getElementById('btn-draw-toggle');
        btnDrawToggle.addEventListener('mousedown', () => {
            if (camera) {
                drawingEnabled = true;
                btnDrawToggle.classList.add('btn-active');
            }
        });
        btnDrawToggle.addEventListener('mouseup', () => {
            drawingEnabled = false;
            btnDrawToggle.classList.remove('btn-active');
            if (isDrawing && currentStroke.length > 0) {
                strokeHistory.push([...currentStroke]);
                lastStrokeEnd = lastPoint;
            }
            lastPoint = null;
            isDrawing = false;
            currentStroke = [];
        });
        btnDrawToggle.addEventListener('mouseleave', () => {
            drawingEnabled = false;
            btnDrawToggle.classList.remove('btn-active');
        });
        // Touch events cho mobile
        btnDrawToggle.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (camera) {
                drawingEnabled = true;
                btnDrawToggle.classList.add('btn-active');
            }
        });
        btnDrawToggle.addEventListener('touchend', (e) => {
            e.preventDefault();
            drawingEnabled = false;
            btnDrawToggle.classList.remove('btn-active');
            if (isDrawing && currentStroke.length > 0) {
                strokeHistory.push([...currentStroke]);
                lastStrokeEnd = lastPoint;
            }
            lastPoint = null;
            isDrawing = false;
            currentStroke = [];
        });
        
        document.getElementById('btn-undo').addEventListener('click', () => {
            if (strokeHistory.length > 0) {
                strokeHistory.pop();
                strokeCount = Math.max(0, strokeCount - 1);
                // V·∫Ω l·∫°i t·∫•t c·∫£ stroke c√≤n l·∫°i
                if (persistentCtx) {
                    persistentCtx.clearRect(0, 0, persistentCanvas.width, persistentCanvas.height);
                    strokeHistory.forEach(stroke => {
                        if (stroke.length < 2) return;
                        persistentCtx.beginPath();
                        persistentCtx.moveTo(stroke[0].x, stroke[0].y);
                        for (let i = 1; i < stroke.length; i++) {
                            persistentCtx.lineTo(stroke[i].x, stroke[i].y);
                        }
                        persistentCtx.strokeStyle = '#3b82f6';
                        persistentCtx.lineWidth = 5;
                        persistentCtx.lineCap = 'round';
                        persistentCtx.lineJoin = 'round';
                        persistentCtx.stroke();
                    });
                    // C·∫≠p nh·∫≠t lastStrokeEnd
                    if (strokeHistory.length > 0) {
                        const lastStroke = strokeHistory[strokeHistory.length - 1];
                        lastStrokeEnd = lastStroke[lastStroke.length - 1];
                    } else {
                        lastStrokeEnd = null;
                    }
                }
                logResult(`‚Ü©Ô∏è Undo n√©t ${strokeCount + 1}`);
            }
        });
        
        document.getElementById('btn-clear').addEventListener('click', () => {
            if (persistentCtx) {
                persistentCtx.clearRect(0, 0, persistentCanvas.width, persistentCanvas.height);
            }
            drawCtx.fillStyle = '#111';
            drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
            lastPoint = null;
            lastStrokeEnd = null;
            strokeCount = 0;
            strokeHistory = [];
            currentStroke = [];
            lastDirection = null;
            positionHistory = [];
            logResult('üóëÔ∏è ƒê√£ x√≥a canvas');
        });
    </script>

    <script>
        // ============ TEST & LOGGING ============
        function logResult(msg) {
            const results = document.getElementById('test-results');
            const time = new Date().toLocaleTimeString();
            results.innerHTML += `<div>[${time}] ${msg}</div>`;
            results.scrollTop = results.scrollHeight;
        }

        async function runFullTest() {
            const btn = document.getElementById('btn-full-test');
            btn.disabled = true;
            btn.textContent = 'üîÑ ƒêang test...';
            
            logResult('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            logResult('üß™ B·∫ÆT ƒê·∫¶U FULL TEST (30 gi√¢y)');
            logResult('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            
            // Device info
            logResult(`üì± Device: ${navigator.userAgent.substring(0, 50)}...`);
            logResult(`üñ•Ô∏è Screen: ${window.screen.width}x${window.screen.height}`);
            logResult(`üíæ Memory: ${navigator.deviceMemory || 'N/A'} GB`);
            logResult(`üîß Cores: ${navigator.hardwareConcurrency || 'N/A'}`);
            
            // Test 1: Hanzi Writer Animation
            logResult('');
            logResult('üìù Test 1: Hanzi Writer Animation...');
            const animStart = performance.now();
            for (let i = 0; i < 5; i++) {
                await new Promise(resolve => {
                    writer.animateCharacter({ onComplete: resolve });
                });
            }
            const animTime = performance.now() - animStart;
            logResult(`   ‚úÖ 5 animations: ${Math.round(animTime)}ms (${Math.round(animTime/5)}ms/each)`);
            
            // Test 2: Character switching
            logResult('');
            logResult('üìù Test 2: Character Switching...');
            const chars = ['Â•Ω', '‰Ω†', 'Êàë', '‰ªñ', 'ÊòØ'];
            const switchStart = performance.now();
            for (const char of chars) {
                initHanziWriter(char);
                await new Promise(r => setTimeout(r, 100));
            }
            const switchTime = performance.now() - switchStart;
            logResult(`   ‚úÖ 5 switches: ${Math.round(switchTime)}ms (${Math.round(switchTime/5)}ms/each)`);
            
            // Test 3: FPS stability
            logResult('');
            logResult('üìù Test 3: FPS Stability (10s)...');
            await new Promise(r => setTimeout(r, 10000));
            const avgFps = perfData.fps.length > 0 
                ? Math.round(perfData.fps.reduce((a,b) => a+b, 0) / perfData.fps.length) 
                : 0;
            const minFps = perfData.fps.length > 0 ? Math.min(...perfData.fps) : 0;
            logResult(`   ‚úÖ Avg FPS: ${avgFps}, Min FPS: ${minFps}`);
            
            // Test 4: Memory usage
            logResult('');
            logResult('üìù Test 4: Memory Usage...');
            if (perfData.memory.length > 0) {
                const avgMem = Math.round(perfData.memory.reduce((a,b) => a+b, 0) / perfData.memory.length);
                const maxMem = Math.max(...perfData.memory);
                logResult(`   ‚úÖ Avg Memory: ${avgMem}MB, Max: ${maxMem}MB`);
            } else {
                logResult('   ‚ö†Ô∏è Memory API kh√¥ng kh·∫£ d·ª•ng (ch·ªâ Chrome)');
            }
            
            // Summary
            logResult('');
            logResult('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            logResult('üìä K·∫æT QU·∫¢ T·ªîNG H·ª¢P');
            logResult('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            
            let grade = 'A';
            let recommendation = '';
            
            if (avgFps >= 30 && minFps >= 20) {
                grade = 'A';
                recommendation = '‚úÖ TUY·ªÜT V·ªúI! M√°y ch·∫°y m∆∞·ª£t m√†.';
            } else if (avgFps >= 20 && minFps >= 10) {
                grade = 'B';
                recommendation = 'üëç T·ªêT. C√≥ th·ªÉ d√πng ƒë∆∞·ª£c, ƒë√¥i khi h∆°i lag.';
            } else if (avgFps >= 15) {
                grade = 'C';
                recommendation = '‚ö†Ô∏è T·∫†M ƒê∆Ø·ª¢C. N√™n t·∫Øt Air Writing, ch·ªâ d√πng Quiz.';
            } else {
                grade = 'D';
                recommendation = '‚ùå Y·∫æU. Ch·ªâ n√™n d√πng Animation c∆° b·∫£n.';
            }
            
            logResult(`üèÜ Grade: ${grade}`);
            logResult(recommendation);
            logResult('');
            logResult('üí° Y√äU C·∫¶U T·ªêI THI·ªÇU ƒê·ªÄ XU·∫§T:');
            logResult('   - CPU: Intel i3 / AMD Ryzen 3 tr·ªü l√™n');
            logResult('   - RAM: 4GB (8GB recommended)');
            logResult('   - Browser: Chrome/Edge m·ªõi nh·∫•t');
            logResult('   - Webcam: 720p (cho Air Writing)');
            logResult('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            
            btn.disabled = false;
            btn.textContent = 'üß™ Ch·∫°y Full Test (30 gi√¢y)';
        }

        document.getElementById('btn-full-test').addEventListener('click', runFullTest);

        // ============ INIT ============
        window.onload = () => {
            getDeviceInfo();
            updatePerformance();
            initHanziWriter('Â•Ω');
            srsUpdateUI(); // Load SRS data
            logResult('ÔøΩ  PolyBiz AI MVP ƒë√£ s·∫µn s√†ng!');
            logResult('üí° Tip: Nh·∫•n "Full Test" ƒë·ªÉ ki·ªÉm tra hi·ªáu nƒÉng m√°y.');
            logResult('üîä B·∫≠t/t·∫Øt ph√°t √¢m ·ªü panel "Th·ªëng k√™"');
        };
    </script>
</body>
</html>