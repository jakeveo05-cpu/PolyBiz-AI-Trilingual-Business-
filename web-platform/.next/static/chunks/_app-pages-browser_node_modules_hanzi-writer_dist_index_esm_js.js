"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_hanzi-writer_dist_index_esm_js"],{

/***/ "(app-pages-browser)/./node_modules/hanzi-writer/dist/index.esm.js":
/*!*****************************************************!*\
  !*** ./node_modules/hanzi-writer/dist/index.esm.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/**\n * Hanzi Writer v3.7.3 | https://chanind.github.io/hanzi-writer\n */ var _globalObj$requestAni, _globalObj$cancelAnim, _globalObj$navigator; // hacky way to get around rollup not properly setting `global` to `window` in browser\nconst globalObj =  false ? 0 : window;\nconst performanceNow = globalObj.performance && (()=>globalObj.performance.now()) || (()=>Date.now());\nconst requestAnimationFrame = ((_globalObj$requestAni = globalObj.requestAnimationFrame) === null || _globalObj$requestAni === void 0 ? void 0 : _globalObj$requestAni.bind(globalObj)) || ((callback)=>setTimeout(()=>callback(performanceNow()), 1000 / 60));\nconst cancelAnimationFrame = ((_globalObj$cancelAnim = globalObj.cancelAnimationFrame) === null || _globalObj$cancelAnim === void 0 ? void 0 : _globalObj$cancelAnim.bind(globalObj)) || clearTimeout; // Object.assign polyfill, because IE :/\nfunction arrLast(arr) {\n    return arr[arr.length - 1];\n}\nconst fixIndex = (index, length)=>{\n    // helper to handle negative indexes in array indices\n    if (index < 0) {\n        return length + index;\n    }\n    return index;\n};\nconst selectIndex = (arr, index)=>{\n    // helper to select item from array at index, supporting negative indexes\n    return arr[fixIndex(index, arr.length)];\n};\nfunction copyAndMergeDeep(base, override) {\n    const output = {\n        ...base\n    };\n    for(const key in override){\n        const baseVal = base[key];\n        const overrideVal = override[key];\n        if (baseVal === overrideVal) {\n            continue;\n        }\n        if (baseVal && overrideVal && typeof baseVal === \"object\" && typeof overrideVal === \"object\" && !Array.isArray(overrideVal)) {\n            output[key] = copyAndMergeDeep(baseVal, overrideVal);\n        } else {\n            // @ts-ignore\n            output[key] = overrideVal;\n        }\n    }\n    return output;\n}\n/** basically a simplified version of lodash.get, selects a key out of an object like 'a.b' from {a: {b: 7}} */ function inflate(scope, obj) {\n    const parts = scope.split(\".\");\n    const final = {};\n    let current = final;\n    for(let i = 0; i < parts.length; i++){\n        const cap = i === parts.length - 1 ? obj : {};\n        current[parts[i]] = cap;\n        current = cap;\n    }\n    return final;\n}\nlet count = 0;\nfunction counter() {\n    count++;\n    return count;\n}\nfunction average(arr) {\n    const sum = arr.reduce((acc, val)=>val + acc, 0);\n    return sum / arr.length;\n}\nfunction colorStringToVals(colorString) {\n    const normalizedColor = colorString.toUpperCase().trim(); // based on https://stackoverflow.com/a/21648508\n    if (/^#([A-F0-9]{3}){1,2}$/.test(normalizedColor)) {\n        let hexParts = normalizedColor.substring(1).split(\"\");\n        if (hexParts.length === 3) {\n            hexParts = [\n                hexParts[0],\n                hexParts[0],\n                hexParts[1],\n                hexParts[1],\n                hexParts[2],\n                hexParts[2]\n            ];\n        }\n        const hexStr = \"\".concat(hexParts.join(\"\"));\n        return {\n            r: parseInt(hexStr.slice(0, 2), 16),\n            g: parseInt(hexStr.slice(2, 4), 16),\n            b: parseInt(hexStr.slice(4, 6), 16),\n            a: 1\n        };\n    }\n    const rgbMatch = normalizedColor.match(/^RGBA?\\((\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)(?:\\s*,\\s*(\\d*\\.?\\d+))?\\)$/);\n    if (rgbMatch) {\n        return {\n            r: parseInt(rgbMatch[1], 10),\n            g: parseInt(rgbMatch[2], 10),\n            b: parseInt(rgbMatch[3], 10),\n            // @ts-expect-error ts-migrate(2554) FIXME: Expected 1 arguments, but got 2.\n            a: parseFloat(rgbMatch[4] || 1, 10)\n        };\n    }\n    throw new Error(\"Invalid color: \".concat(colorString));\n}\nconst trim = (string)=>string.replace(/^\\s+/, \"\").replace(/\\s+$/, \"\"); // return a new array-like object with int keys where each key is item\n// ex: objRepeat({x: 8}, 3) === {0: {x: 8}, 1: {x: 8}, 2: {x: 8}}\nfunction objRepeat(item, times) {\n    const obj = {};\n    for(let i = 0; i < times; i++){\n        obj[i] = item;\n    }\n    return obj;\n} // similar to objRepeat, but takes in a callback which is called for each index in the object\nfunction objRepeatCb(times, cb) {\n    const obj = {};\n    for(let i = 0; i < times; i++){\n        obj[i] = cb(i);\n    }\n    return obj;\n}\nconst ua = ((_globalObj$navigator = globalObj.navigator) === null || _globalObj$navigator === void 0 ? void 0 : _globalObj$navigator.userAgent) || \"\";\nconst isMsBrowser = ua.indexOf(\"MSIE \") > 0 || ua.indexOf(\"Trident/\") > 0 || ua.indexOf(\"Edge/\") > 0; // eslint-disable-next-line @typescript-eslint/no-empty-function\nconst noop = ()=>{};\nclass RenderState {\n    overwriteOnStateChange(onStateChange) {\n        this._onStateChange = onStateChange;\n    }\n    updateState(stateChanges) {\n        const nextState = copyAndMergeDeep(this.state, stateChanges);\n        this._onStateChange(nextState, this.state);\n        this.state = nextState;\n    }\n    run(mutations) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const scopes = mutations.map((mut)=>mut.scope);\n        this.cancelMutations(scopes);\n        return new Promise((resolve)=>{\n            const mutationChain = {\n                _isActive: true,\n                _index: 0,\n                _resolve: resolve,\n                _mutations: mutations,\n                _loop: options.loop,\n                _scopes: scopes\n            };\n            this._mutationChains.push(mutationChain);\n            this._run(mutationChain);\n        });\n    }\n    _run(mutationChain) {\n        if (!mutationChain._isActive) {\n            return;\n        }\n        const mutations = mutationChain._mutations;\n        if (mutationChain._index >= mutations.length) {\n            if (mutationChain._loop) {\n                mutationChain._index = 0; // eslint-disable-line no-param-reassign\n            } else {\n                mutationChain._isActive = false; // eslint-disable-line no-param-reassign\n                this._mutationChains = this._mutationChains.filter((chain)=>chain !== mutationChain); // The chain is done - resolve the promise to signal it finished successfully\n                mutationChain._resolve({\n                    canceled: false\n                });\n                return;\n            }\n        }\n        const activeMutation = mutationChain._mutations[mutationChain._index];\n        activeMutation.run(this).then(()=>{\n            if (mutationChain._isActive) {\n                mutationChain._index++; // eslint-disable-line no-param-reassign\n                this._run(mutationChain);\n            }\n        });\n    }\n    _getActiveMutations() {\n        return this._mutationChains.map((chain)=>chain._mutations[chain._index]);\n    }\n    pauseAll() {\n        this._getActiveMutations().forEach((mutation)=>mutation.pause());\n    }\n    resumeAll() {\n        this._getActiveMutations().forEach((mutation)=>mutation.resume());\n    }\n    cancelMutations(scopesToCancel) {\n        for (const chain of this._mutationChains){\n            for (const chainId of chain._scopes){\n                for (const scopeToCancel of scopesToCancel){\n                    if (chainId.startsWith(scopeToCancel) || scopeToCancel.startsWith(chainId)) {\n                        this._cancelMutationChain(chain);\n                    }\n                }\n            }\n        }\n    }\n    cancelAll() {\n        this.cancelMutations([\n            \"\"\n        ]);\n    }\n    _cancelMutationChain(mutationChain) {\n        var _mutationChain$_resol;\n        mutationChain._isActive = false;\n        for(let i = mutationChain._index; i < mutationChain._mutations.length; i++){\n            mutationChain._mutations[i].cancel(this);\n        }\n        (_mutationChain$_resol = mutationChain._resolve) === null || _mutationChain$_resol === void 0 ? void 0 : _mutationChain$_resol.call(mutationChain, {\n            canceled: true\n        });\n        this._mutationChains = this._mutationChains.filter((chain)=>chain !== mutationChain);\n    }\n    constructor(character, options, onStateChange = noop){\n        this._mutationChains = [];\n        this._onStateChange = onStateChange;\n        this.state = {\n            options: {\n                drawingFadeDuration: options.drawingFadeDuration,\n                drawingWidth: options.drawingWidth,\n                drawingColor: colorStringToVals(options.drawingColor),\n                strokeColor: colorStringToVals(options.strokeColor),\n                outlineColor: colorStringToVals(options.outlineColor),\n                radicalColor: colorStringToVals(options.radicalColor || options.strokeColor),\n                highlightColor: colorStringToVals(options.highlightColor)\n            },\n            character: {\n                main: {\n                    opacity: options.showCharacter ? 1 : 0,\n                    strokes: {}\n                },\n                outline: {\n                    opacity: options.showOutline ? 1 : 0,\n                    strokes: {}\n                },\n                highlight: {\n                    opacity: 1,\n                    strokes: {}\n                }\n            },\n            userStrokes: null\n        };\n        for(let i = 0; i < character.strokes.length; i++){\n            this.state.character.main.strokes[i] = {\n                opacity: 1,\n                displayPortion: 1\n            };\n            this.state.character.outline.strokes[i] = {\n                opacity: 1,\n                displayPortion: 1\n            };\n            this.state.character.highlight.strokes[i] = {\n                opacity: 0,\n                displayPortion: 1\n            };\n        }\n    }\n}\nconst subtract = (p1, p2)=>({\n        x: p1.x - p2.x,\n        y: p1.y - p2.y\n    });\nconst magnitude = (point)=>Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));\nconst distance = (point1, point2)=>magnitude(subtract(point1, point2));\nconst equals = (point1, point2)=>point1.x === point2.x && point1.y === point2.y;\nconst round = function(point) {\n    let precision = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n    const multiplier = precision * 10;\n    return {\n        x: Math.round(multiplier * point.x) / multiplier,\n        y: Math.round(multiplier * point.y) / multiplier\n    };\n};\nconst length = (points)=>{\n    let lastPoint = points[0];\n    const pointsSansFirst = points.slice(1);\n    return pointsSansFirst.reduce((acc, point)=>{\n        const dist = distance(point, lastPoint);\n        lastPoint = point;\n        return acc + dist;\n    }, 0);\n};\nconst cosineSimilarity = (point1, point2)=>{\n    const rawDotProduct = point1.x * point2.x + point1.y * point2.y;\n    return rawDotProduct / magnitude(point1) / magnitude(point2);\n};\n/**\n * return a new point, p3, which is on the same line as p1 and p2, but distance away\n * from p2. p1, p2, p3 will always lie on the line in that order\n */ const _extendPointOnLine = (p1, p2, dist)=>{\n    const vect = subtract(p2, p1);\n    const norm = dist / magnitude(vect);\n    return {\n        x: p2.x + norm * vect.x,\n        y: p2.y + norm * vect.y\n    };\n};\n/** based on http://www.kr.tuwien.ac.at/staff/eiter/et-archive/cdtr9464.pdf */ const frechetDist = (curve1, curve2)=>{\n    const longCurve = curve1.length >= curve2.length ? curve1 : curve2;\n    const shortCurve = curve1.length >= curve2.length ? curve2 : curve1;\n    const calcVal = (i, j, prevResultsCol, curResultsCol)=>{\n        if (i === 0 && j === 0) {\n            return distance(longCurve[0], shortCurve[0]);\n        }\n        if (i > 0 && j === 0) {\n            return Math.max(prevResultsCol[0], distance(longCurve[i], shortCurve[0]));\n        }\n        const lastResult = curResultsCol[curResultsCol.length - 1];\n        if (i === 0 && j > 0) {\n            return Math.max(lastResult, distance(longCurve[0], shortCurve[j]));\n        }\n        return Math.max(Math.min(prevResultsCol[j], prevResultsCol[j - 1], lastResult), distance(longCurve[i], shortCurve[j]));\n    };\n    let prevResultsCol = [];\n    for(let i = 0; i < longCurve.length; i++){\n        const curResultsCol = [];\n        for(let j = 0; j < shortCurve.length; j++){\n            // we only need the results from i - 1 and j - 1 to continue the calculation\n            // so we only need to hold onto the last column of calculated results\n            // prevResultsCol is results[i-1][:] in the original algorithm\n            // curResultsCol is results[i][:j-1] in the original algorithm\n            curResultsCol.push(calcVal(i, j, prevResultsCol, curResultsCol));\n        }\n        prevResultsCol = curResultsCol;\n    }\n    return prevResultsCol[shortCurve.length - 1];\n};\n/** break up long segments in the curve into smaller segments of len maxLen or smaller */ const subdivideCurve = function(curve) {\n    let maxLen = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.05;\n    const newCurve = curve.slice(0, 1);\n    for (const point of curve.slice(1)){\n        const prevPoint = newCurve[newCurve.length - 1];\n        const segLen = distance(point, prevPoint);\n        if (segLen > maxLen) {\n            const numNewPoints = Math.ceil(segLen / maxLen);\n            const newSegLen = segLen / numNewPoints;\n            for(let i = 0; i < numNewPoints; i++){\n                newCurve.push(_extendPointOnLine(point, prevPoint, -1 * newSegLen * (i + 1)));\n            }\n        } else {\n            newCurve.push(point);\n        }\n    }\n    return newCurve;\n};\n/** redraw the curve using numPoints equally spaced out along the length of the curve */ const outlineCurve = function(curve) {\n    let numPoints = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 30;\n    const curveLen = length(curve);\n    const segmentLen = curveLen / (numPoints - 1);\n    const outlinePoints = [\n        curve[0]\n    ];\n    const endPoint = arrLast(curve);\n    const remainingCurvePoints = curve.slice(1);\n    for(let i = 0; i < numPoints - 2; i++){\n        let lastPoint = arrLast(outlinePoints);\n        let remainingDist = segmentLen;\n        let outlinePointFound = false;\n        while(!outlinePointFound){\n            const nextPointDist = distance(lastPoint, remainingCurvePoints[0]);\n            if (nextPointDist < remainingDist) {\n                remainingDist -= nextPointDist;\n                lastPoint = remainingCurvePoints.shift();\n            } else {\n                const nextPoint = _extendPointOnLine(lastPoint, remainingCurvePoints[0], remainingDist - nextPointDist);\n                outlinePoints.push(nextPoint);\n                outlinePointFound = true;\n            }\n        }\n    }\n    outlinePoints.push(endPoint);\n    return outlinePoints;\n};\n/** translate and scale from https://en.wikipedia.org/wiki/Procrustes_analysis */ const normalizeCurve = (curve)=>{\n    const outlinedCurve = outlineCurve(curve);\n    const meanX = average(outlinedCurve.map((point)=>point.x));\n    const meanY = average(outlinedCurve.map((point)=>point.y));\n    const mean = {\n        x: meanX,\n        y: meanY\n    };\n    const translatedCurve = outlinedCurve.map((point)=>subtract(point, mean));\n    const scale = Math.sqrt(average([\n        Math.pow(translatedCurve[0].x, 2) + Math.pow(translatedCurve[0].y, 2),\n        Math.pow(arrLast(translatedCurve).x, 2) + Math.pow(arrLast(translatedCurve).y, 2)\n    ]));\n    const scaledCurve = translatedCurve.map((point)=>({\n            x: point.x / scale,\n            y: point.y / scale\n        }));\n    return subdivideCurve(scaledCurve);\n}; // rotate around the origin\nconst rotate = (curve, theta)=>{\n    return curve.map((point)=>({\n            x: Math.cos(theta) * point.x - Math.sin(theta) * point.y,\n            y: Math.sin(theta) * point.x + Math.cos(theta) * point.y\n        }));\n}; // remove intermediate points that are on the same line as the points to either side\nconst _filterParallelPoints = (points)=>{\n    if (points.length < 3) return points;\n    const filteredPoints = [\n        points[0],\n        points[1]\n    ];\n    points.slice(2).forEach((point)=>{\n        const numFilteredPoints = filteredPoints.length;\n        const curVect = subtract(point, filteredPoints[numFilteredPoints - 1]);\n        const prevVect = subtract(filteredPoints[numFilteredPoints - 1], filteredPoints[numFilteredPoints - 2]); // this is the z coord of the cross-product. If this is 0 then they're parallel\n        const isParallel = curVect.y * prevVect.x - curVect.x * prevVect.y === 0;\n        if (isParallel) {\n            filteredPoints.pop();\n        }\n        filteredPoints.push(point);\n    });\n    return filteredPoints;\n};\nfunction getPathString(points) {\n    let close = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    const start = round(points[0]);\n    const remainingPoints = points.slice(1);\n    let pathString = \"M \".concat(start.x, \" \").concat(start.y);\n    remainingPoints.forEach((point)=>{\n        const roundedPoint = round(point);\n        pathString += \" L \".concat(roundedPoint.x, \" \").concat(roundedPoint.y);\n    });\n    if (close) {\n        pathString += \"Z\";\n    }\n    return pathString;\n}\n/** take points on a path and move their start point backwards by distance */ const extendStart = (points, dist)=>{\n    const filteredPoints = _filterParallelPoints(points);\n    if (filteredPoints.length < 2) return filteredPoints;\n    const p1 = filteredPoints[1];\n    const p2 = filteredPoints[0];\n    const newStart = _extendPointOnLine(p1, p2, dist);\n    const extendedPoints = filteredPoints.slice(1);\n    extendedPoints.unshift(newStart);\n    return extendedPoints;\n};\nclass Stroke {\n    getStartingPoint() {\n        return this.points[0];\n    }\n    getEndingPoint() {\n        return this.points[this.points.length - 1];\n    }\n    getLength() {\n        return length(this.points);\n    }\n    getVectors() {\n        let lastPoint = this.points[0];\n        const pointsSansFirst = this.points.slice(1);\n        return pointsSansFirst.map((point)=>{\n            const vector = subtract(point, lastPoint);\n            lastPoint = point;\n            return vector;\n        });\n    }\n    getDistance(point) {\n        const distances = this.points.map((strokePoint)=>distance(strokePoint, point));\n        return Math.min(...distances);\n    }\n    getAverageDistance(points) {\n        const totalDist = points.reduce((acc, point)=>acc + this.getDistance(point), 0);\n        return totalDist / points.length;\n    }\n    constructor(path, points, strokeNum, isInRadical = false){\n        this.path = path;\n        this.points = points;\n        this.strokeNum = strokeNum;\n        this.isInRadical = isInRadical;\n    }\n}\nclass Character {\n    constructor(symbol, strokes){\n        this.symbol = symbol;\n        this.strokes = strokes;\n    }\n}\nfunction generateStrokes(param) {\n    let { radStrokes, strokes, medians } = param;\n    const isInRadical = (strokeNum)=>{\n        var _radStrokes$indexOf;\n        return ((_radStrokes$indexOf = radStrokes === null || radStrokes === void 0 ? void 0 : radStrokes.indexOf(strokeNum)) !== null && _radStrokes$indexOf !== void 0 ? _radStrokes$indexOf : -1) >= 0;\n    };\n    return strokes.map((path, index)=>{\n        const points = medians[index].map((pointData)=>{\n            const [x, y] = pointData;\n            return {\n                x,\n                y\n            };\n        });\n        return new Stroke(path, points, index, isInRadical(index));\n    });\n}\nfunction parseCharData(symbol, charJson) {\n    const strokes = generateStrokes(charJson);\n    return new Character(symbol, strokes);\n}\n// All makemeahanzi characters have the same bounding box\nconst CHARACTER_BOUNDS = [\n    {\n        x: 0,\n        y: -124\n    },\n    {\n        x: 1024,\n        y: 900\n    }\n];\nconst [from, to] = CHARACTER_BOUNDS;\nconst preScaledWidth = to.x - from.x;\nconst preScaledHeight = to.y - from.y;\nclass Positioner {\n    convertExternalPoint(point) {\n        const x = (point.x - this.xOffset) / this.scale;\n        const y = (this.height - this.yOffset - point.y) / this.scale;\n        return {\n            x,\n            y\n        };\n    }\n    constructor(options){\n        const { padding, width, height } = options;\n        this.padding = padding;\n        this.width = width;\n        this.height = height;\n        const effectiveWidth = width - 2 * padding;\n        const effectiveHeight = height - 2 * padding;\n        const scaleX = effectiveWidth / preScaledWidth;\n        const scaleY = effectiveHeight / preScaledHeight;\n        this.scale = Math.min(scaleX, scaleY);\n        const xCenteringBuffer = padding + (effectiveWidth - this.scale * preScaledWidth) / 2;\n        const yCenteringBuffer = padding + (effectiveHeight - this.scale * preScaledHeight) / 2;\n        this.xOffset = -1 * from.x * this.scale + xCenteringBuffer;\n        this.yOffset = -1 * from.y * this.scale + yCenteringBuffer;\n    }\n}\nconst COSINE_SIMILARITY_THRESHOLD = 0; // -1 to 1, smaller = more lenient\nconst START_AND_END_DIST_THRESHOLD = 250; // bigger = more lenient\nconst FRECHET_THRESHOLD = 0.4; // bigger = more lenient\nconst MIN_LEN_THRESHOLD = 0.35; // smaller = more lenient\nfunction strokeMatches(userStroke, character, strokeNum) {\n    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n    const strokes = character.strokes;\n    const points = stripDuplicates(userStroke.points);\n    if (points.length < 2) {\n        return {\n            isMatch: false,\n            meta: {\n                isStrokeBackwards: false\n            }\n        };\n    }\n    const { isMatch, meta, avgDist } = getMatchData(points, strokes[strokeNum], options);\n    if (!isMatch) {\n        return {\n            isMatch,\n            meta\n        };\n    } // if there is a better match among strokes the user hasn't drawn yet, the user probably drew the wrong stroke\n    const laterStrokes = strokes.slice(strokeNum + 1);\n    let closestMatchDist = avgDist;\n    for(let i = 0; i < laterStrokes.length; i++){\n        const { isMatch, avgDist } = getMatchData(points, laterStrokes[i], {\n            ...options,\n            checkBackwards: false\n        });\n        if (isMatch && avgDist < closestMatchDist) {\n            closestMatchDist = avgDist;\n        }\n    } // if there's a better match, rather that returning false automatically, try reducing leniency instead\n    // if leniency is already really high we can allow some similar strokes to pass\n    if (closestMatchDist < avgDist) {\n        // adjust leniency between 0.3 and 0.6 depending on how much of a better match the new match is\n        const leniencyAdjustment = 0.6 * (closestMatchDist + avgDist) / (2 * avgDist);\n        const { isMatch, meta } = getMatchData(points, strokes[strokeNum], {\n            ...options,\n            leniency: (options.leniency || 1) * leniencyAdjustment\n        });\n        return {\n            isMatch,\n            meta\n        };\n    }\n    return {\n        isMatch,\n        meta\n    };\n}\nconst startAndEndMatches = (points, closestStroke, leniency)=>{\n    const startingDist = distance(closestStroke.getStartingPoint(), points[0]);\n    const endingDist = distance(closestStroke.getEndingPoint(), points[points.length - 1]);\n    return startingDist <= START_AND_END_DIST_THRESHOLD * leniency && endingDist <= START_AND_END_DIST_THRESHOLD * leniency;\n}; // returns a list of the direction of all segments in the line connecting the points\nconst getEdgeVectors = (points)=>{\n    const vectors = [];\n    let lastPoint = points[0];\n    points.slice(1).forEach((point)=>{\n        vectors.push(subtract(point, lastPoint));\n        lastPoint = point;\n    });\n    return vectors;\n};\nconst directionMatches = (points, stroke)=>{\n    const edgeVectors = getEdgeVectors(points);\n    const strokeVectors = stroke.getVectors();\n    const similarities = edgeVectors.map((edgeVector)=>{\n        const strokeSimilarities = strokeVectors.map((strokeVector)=>cosineSimilarity(strokeVector, edgeVector));\n        return Math.max(...strokeSimilarities);\n    });\n    const avgSimilarity = average(similarities);\n    return avgSimilarity > COSINE_SIMILARITY_THRESHOLD;\n};\nconst lengthMatches = (points, stroke, leniency)=>{\n    return leniency * (length(points) + 25) / (stroke.getLength() + 25) >= MIN_LEN_THRESHOLD;\n};\nconst stripDuplicates = (points)=>{\n    if (points.length < 2) return points;\n    const [firstPoint, ...rest] = points;\n    const dedupedPoints = [\n        firstPoint\n    ];\n    for (const point of rest){\n        if (!equals(point, dedupedPoints[dedupedPoints.length - 1])) {\n            dedupedPoints.push(point);\n        }\n    }\n    return dedupedPoints;\n};\nconst SHAPE_FIT_ROTATIONS = [\n    Math.PI / 16,\n    Math.PI / 32,\n    0,\n    -1 * Math.PI / 32,\n    -1 * Math.PI / 16\n];\nconst shapeFit = (curve1, curve2, leniency)=>{\n    const normCurve1 = normalizeCurve(curve1);\n    const normCurve2 = normalizeCurve(curve2);\n    let minDist = Infinity;\n    SHAPE_FIT_ROTATIONS.forEach((theta)=>{\n        const dist = frechetDist(normCurve1, rotate(normCurve2, theta));\n        if (dist < minDist) {\n            minDist = dist;\n        }\n    });\n    return minDist <= FRECHET_THRESHOLD * leniency;\n};\nconst getMatchData = (points, stroke, options)=>{\n    const { leniency = 1, isOutlineVisible = false, checkBackwards = true, averageDistanceThreshold = 350 } = options;\n    const avgDist = stroke.getAverageDistance(points);\n    const distMod = isOutlineVisible || stroke.strokeNum > 0 ? 0.5 : 1;\n    const withinDistThresh = avgDist <= averageDistanceThreshold * distMod * leniency; // short circuit for faster matching\n    if (!withinDistThresh) {\n        return {\n            isMatch: false,\n            avgDist,\n            meta: {\n                isStrokeBackwards: false\n            }\n        };\n    }\n    const startAndEndMatch = startAndEndMatches(points, stroke, leniency);\n    const directionMatch = directionMatches(points, stroke);\n    const shapeMatch = shapeFit(points, stroke.points, leniency);\n    const lengthMatch = lengthMatches(points, stroke, leniency);\n    const isMatch = withinDistThresh && startAndEndMatch && directionMatch && shapeMatch && lengthMatch;\n    if (checkBackwards && !isMatch) {\n        const backwardsMatchData = getMatchData([\n            ...points\n        ].reverse(), stroke, {\n            ...options,\n            checkBackwards: false\n        });\n        if (backwardsMatchData.isMatch) {\n            return {\n                isMatch,\n                avgDist,\n                meta: {\n                    isStrokeBackwards: true\n                }\n            };\n        }\n    }\n    return {\n        isMatch,\n        avgDist,\n        meta: {\n            isStrokeBackwards: false\n        }\n    };\n};\nclass UserStroke {\n    appendPoint(point, externalPoint) {\n        this.points.push(point);\n        this.externalPoints.push(externalPoint);\n    }\n    constructor(id, startingPoint, startingExternalPoint){\n        this.id = id;\n        this.points = [\n            startingPoint\n        ];\n        this.externalPoints = [\n            startingExternalPoint\n        ];\n    }\n}\nclass Delay {\n    run() {\n        this._startTime = performanceNow();\n        this._runningPromise = new Promise((resolve)=>{\n            this._resolve = resolve; // @ts-ignore return type of \"setTimeout\" in builds is parsed as `number` instead of `Timeout`\n            this._timeout = setTimeout(()=>this.cancel(), this._duration);\n        });\n        return this._runningPromise;\n    }\n    pause() {\n        if (this._paused) return; // to pause, clear the timeout and rewrite this._duration with whatever time is remaining\n        const elapsedDelay = performance.now() - (this._startTime || 0);\n        this._duration = Math.max(0, this._duration - elapsedDelay);\n        clearTimeout(this._timeout);\n        this._paused = true;\n    }\n    resume() {\n        if (!this._paused) return;\n        this._startTime = performance.now(); // @ts-ignore return type of \"setTimeout\" in builds is parsed as `number` instead of `Timeout`\n        this._timeout = setTimeout(()=>this.cancel(), this._duration);\n        this._paused = false;\n    }\n    cancel() {\n        clearTimeout(this._timeout);\n        if (this._resolve) {\n            this._resolve();\n        }\n        this._resolve = undefined;\n    }\n    constructor(duration){\n        this._duration = duration;\n        this._startTime = null;\n        this._paused = false;\n        this.scope = \"delay.\".concat(duration);\n    }\n}\nclass Mutation {\n    run(renderState) {\n        if (!this._values) this._inflateValues(renderState);\n        if (this._duration === 0) renderState.updateState(this._values);\n        if (this._duration === 0 || isAlreadyAtEnd(renderState.state, this._values)) {\n            return Promise.resolve();\n        }\n        this._renderState = renderState;\n        this._startState = renderState.state;\n        this._startTime = performance.now();\n        this._frameHandle = requestAnimationFrame(this._tick);\n        return new Promise((resolve)=>{\n            this._resolve = resolve;\n        });\n    }\n    _inflateValues(renderState) {\n        let values = this._valuesOrCallable;\n        if (typeof this._valuesOrCallable === \"function\") {\n            values = this._valuesOrCallable(renderState.state);\n        }\n        this._values = inflate(this.scope, values);\n    }\n    pause() {\n        if (this._startPauseTime !== null) {\n            return;\n        }\n        if (this._frameHandle) {\n            cancelAnimationFrame(this._frameHandle);\n        }\n        this._startPauseTime = performance.now();\n    }\n    resume() {\n        if (this._startPauseTime === null) {\n            return;\n        }\n        this._frameHandle = requestAnimationFrame(this._tick);\n        this._pausedDuration += performance.now() - this._startPauseTime;\n        this._startPauseTime = null;\n    }\n    cancel(renderState) {\n        var _this$_resolve;\n        (_this$_resolve = this._resolve) === null || _this$_resolve === void 0 ? void 0 : _this$_resolve.call(this);\n        this._resolve = undefined;\n        cancelAnimationFrame(this._frameHandle || -1);\n        this._frameHandle = undefined;\n        if (this._force) {\n            if (!this._values) this._inflateValues(renderState);\n            renderState.updateState(this._values);\n        }\n    }\n    /**\n   *\n   * @param scope a string representation of what fields this mutation affects from the state. This is used to cancel conflicting mutations\n   * @param valuesOrCallable a thunk containing the value to set, or a callback which will return those values\n   */ constructor(scope, valuesOrCallable, options = {}){\n        this._tick = (timing)=>{\n            if (this._startPauseTime !== null) {\n                return;\n            }\n            const progress = Math.min(1, (timing - this._startTime - this._pausedDuration) / this._duration);\n            if (progress === 1) {\n                this._renderState.updateState(this._values);\n                this._frameHandle = undefined;\n                this.cancel(this._renderState);\n            } else {\n                const easedProgress = ease(progress);\n                const stateChanges = getPartialValues(this._startState, this._values, easedProgress);\n                this._renderState.updateState(stateChanges);\n                this._frameHandle = requestAnimationFrame(this._tick);\n            }\n        };\n        this.scope = scope;\n        this._valuesOrCallable = valuesOrCallable;\n        this._duration = options.duration || 0;\n        this._force = options.force;\n        this._pausedDuration = 0;\n        this._startPauseTime = null;\n    }\n}\nMutation.Delay = Delay;\nfunction getPartialValues(startValues, endValues, progress) {\n    const target = {};\n    for(const key in endValues){\n        const endValue = endValues[key];\n        const startValue = startValues === null || startValues === void 0 ? void 0 : startValues[key];\n        if (typeof startValue === \"number\" && typeof endValue === \"number\" && endValue >= 0) {\n            target[key] = progress * (endValue - startValue) + startValue;\n        } else {\n            target[key] = getPartialValues(startValue, endValue, progress);\n        }\n    }\n    return target;\n}\nfunction isAlreadyAtEnd(startValues, endValues) {\n    for(const key in endValues){\n        const endValue = endValues[key];\n        const startValue = startValues === null || startValues === void 0 ? void 0 : startValues[key];\n        if (endValue >= 0) {\n            if (endValue !== startValue) {\n                return false;\n            }\n        } else if (!isAlreadyAtEnd(startValue, endValue)) {\n            return false;\n        }\n    }\n    return true;\n} // from https://github.com/maxwellito/vivus\nconst ease = (x)=>-Math.cos(x * Math.PI) / 2 + 0.5;\nconst showStrokes = (charName, character, duration)=>{\n    return [\n        new Mutation(\"character.\".concat(charName, \".strokes\"), objRepeat({\n            opacity: 1,\n            displayPortion: 1\n        }, character.strokes.length), {\n            duration,\n            force: true\n        })\n    ];\n};\nconst showCharacter = (charName, character, duration)=>{\n    return [\n        new Mutation(\"character.\".concat(charName), {\n            opacity: 1,\n            strokes: objRepeat({\n                opacity: 1,\n                displayPortion: 1\n            }, character.strokes.length)\n        }, {\n            duration,\n            force: true\n        })\n    ];\n};\nconst hideCharacter = (charName, character, duration)=>{\n    return [\n        new Mutation(\"character.\".concat(charName, \".opacity\"), 0, {\n            duration,\n            force: true\n        }),\n        ...showStrokes(charName, character, 0)\n    ];\n};\nconst updateColor = (colorName, colorVal, duration)=>{\n    return [\n        new Mutation(\"options.\".concat(colorName), colorVal, {\n            duration\n        })\n    ];\n};\nconst highlightStroke = (stroke, color, speed)=>{\n    const strokeNum = stroke.strokeNum;\n    const duration = (stroke.getLength() + 600) / (3 * speed);\n    return [\n        new Mutation(\"options.highlightColor\", color),\n        new Mutation(\"character.highlight\", {\n            opacity: 1,\n            strokes: {\n                [strokeNum]: {\n                    displayPortion: 0,\n                    opacity: 0\n                }\n            }\n        }),\n        new Mutation(\"character.highlight.strokes.\".concat(strokeNum), {\n            displayPortion: 1,\n            opacity: 1\n        }, {\n            duration\n        }),\n        new Mutation(\"character.highlight.strokes.\".concat(strokeNum, \".opacity\"), 0, {\n            duration,\n            force: true\n        })\n    ];\n};\nconst animateStroke = (charName, stroke, speed)=>{\n    const strokeNum = stroke.strokeNum;\n    const duration = (stroke.getLength() + 600) / (3 * speed);\n    return [\n        new Mutation(\"character.\".concat(charName), {\n            opacity: 1,\n            strokes: {\n                [strokeNum]: {\n                    displayPortion: 0,\n                    opacity: 1\n                }\n            }\n        }),\n        new Mutation(\"character.\".concat(charName, \".strokes.\").concat(strokeNum, \".displayPortion\"), 1, {\n            duration\n        })\n    ];\n};\nconst animateSingleStroke = (charName, character, strokeNum, speed)=>{\n    const mutationStateFunc = (state)=>{\n        const curCharState = state.character[charName];\n        const mutationState = {\n            opacity: 1,\n            strokes: {}\n        };\n        for(let i = 0; i < character.strokes.length; i++){\n            mutationState.strokes[i] = {\n                opacity: curCharState.opacity * curCharState.strokes[i].opacity\n            };\n        }\n        return mutationState;\n    };\n    const stroke = character.strokes[strokeNum];\n    return [\n        new Mutation(\"character.\".concat(charName), mutationStateFunc),\n        ...animateStroke(charName, stroke, speed)\n    ];\n};\nconst showStroke = (charName, strokeNum, duration)=>{\n    return [\n        new Mutation(\"character.\".concat(charName, \".strokes.\").concat(strokeNum), {\n            displayPortion: 1,\n            opacity: 1\n        }, {\n            duration,\n            force: true\n        })\n    ];\n};\nconst animateCharacter = (charName, character, fadeDuration, speed, delayBetweenStrokes)=>{\n    let mutations = hideCharacter(charName, character, fadeDuration);\n    mutations = mutations.concat(showStrokes(charName, character, 0));\n    mutations.push(new Mutation(\"character.\".concat(charName), {\n        opacity: 1,\n        strokes: objRepeat({\n            opacity: 0\n        }, character.strokes.length)\n    }, {\n        force: true\n    }));\n    character.strokes.forEach((stroke, i)=>{\n        if (i > 0) mutations.push(new Mutation.Delay(delayBetweenStrokes));\n        mutations = mutations.concat(animateStroke(charName, stroke, speed));\n    });\n    return mutations;\n};\nconst animateCharacterLoop = (charName, character, fadeDuration, speed, delayBetweenStrokes, delayBetweenLoops)=>{\n    const mutations = animateCharacter(charName, character, fadeDuration, speed, delayBetweenStrokes);\n    mutations.push(new Mutation.Delay(delayBetweenLoops));\n    return mutations;\n};\nconst startQuiz = (character, fadeDuration, startStrokeNum)=>{\n    return [\n        ...hideCharacter(\"main\", character, fadeDuration),\n        new Mutation(\"character.highlight\", {\n            opacity: 1,\n            strokes: objRepeat({\n                opacity: 0\n            }, character.strokes.length)\n        }, {\n            force: true\n        }),\n        new Mutation(\"character.main\", {\n            opacity: 1,\n            strokes: objRepeatCb(character.strokes.length, (i)=>({\n                    opacity: i < startStrokeNum ? 1 : 0\n                }))\n        }, {\n            force: true\n        })\n    ];\n};\nconst startUserStroke = (id, point)=>{\n    return [\n        new Mutation(\"quiz.activeUserStrokeId\", id, {\n            force: true\n        }),\n        new Mutation(\"userStrokes.\".concat(id), {\n            points: [\n                point\n            ],\n            opacity: 1\n        }, {\n            force: true\n        })\n    ];\n};\nconst updateUserStroke = (userStrokeId, points)=>{\n    return [\n        new Mutation(\"userStrokes.\".concat(userStrokeId, \".points\"), points, {\n            force: true\n        })\n    ];\n};\nconst hideUserStroke = (userStrokeId, duration)=>{\n    return [\n        new Mutation(\"userStrokes.\".concat(userStrokeId, \".opacity\"), 0, {\n            duration\n        })\n    ];\n};\nconst removeAllUserStrokes = (userStrokeIds)=>{\n    return (userStrokeIds === null || userStrokeIds === void 0 ? void 0 : userStrokeIds.map((userStrokeId)=>new Mutation(\"userStrokes.\".concat(userStrokeId), null, {\n            force: true\n        }))) || [];\n};\nconst highlightCompleteChar = (character, color, duration)=>{\n    return [\n        new Mutation(\"options.highlightColor\", color),\n        ...hideCharacter(\"highlight\", character),\n        ...showCharacter(\"highlight\", character, duration / 2),\n        ...hideCharacter(\"highlight\", character, duration / 2)\n    ];\n};\nconst getDrawnPath = (userStroke)=>({\n        pathString: getPathString(userStroke.externalPoints),\n        points: userStroke.points.map((point)=>round(point))\n    });\nclass Quiz {\n    startQuiz(options) {\n        if (this._userStrokesIds) {\n            this._renderState.run(removeAllUserStrokes(this._userStrokesIds));\n        }\n        this._userStrokesIds = [];\n        this._isActive = true;\n        this._options = options;\n        const startIndex = fixIndex(options.quizStartStrokeNum, this._character.strokes.length);\n        this._currentStrokeIndex = Math.min(startIndex, this._character.strokes.length - 1);\n        this._mistakesOnStroke = 0;\n        this._totalMistakes = 0;\n        return this._renderState.run(startQuiz(this._character, options.strokeFadeDuration, this._currentStrokeIndex));\n    }\n    startUserStroke(externalPoint) {\n        var _this$_userStrokesIds;\n        if (!this._isActive) {\n            return null;\n        }\n        if (this._userStroke) {\n            return this.endUserStroke();\n        }\n        const point = this._positioner.convertExternalPoint(externalPoint);\n        const strokeId = counter();\n        this._userStroke = new UserStroke(strokeId, point, externalPoint);\n        (_this$_userStrokesIds = this._userStrokesIds) === null || _this$_userStrokesIds === void 0 ? void 0 : _this$_userStrokesIds.push(strokeId);\n        return this._renderState.run(startUserStroke(strokeId, point));\n    }\n    continueUserStroke(externalPoint) {\n        if (!this._userStroke) {\n            return Promise.resolve();\n        }\n        const point = this._positioner.convertExternalPoint(externalPoint);\n        this._userStroke.appendPoint(point, externalPoint);\n        const nextPoints = this._userStroke.points.slice(0);\n        return this._renderState.run(updateUserStroke(this._userStroke.id, nextPoints));\n    }\n    setPositioner(positioner) {\n        this._positioner = positioner;\n    }\n    endUserStroke() {\n        var _this$_options$drawin;\n        if (!this._userStroke) return;\n        this._renderState.run(hideUserStroke(this._userStroke.id, (_this$_options$drawin = this._options.drawingFadeDuration) !== null && _this$_options$drawin !== void 0 ? _this$_options$drawin : 300)); // skip single-point strokes\n        if (this._userStroke.points.length === 1) {\n            this._userStroke = undefined;\n            return;\n        }\n        const { acceptBackwardsStrokes, markStrokeCorrectAfterMisses } = this._options;\n        const currentStroke = this._getCurrentStroke();\n        const { isMatch, meta } = strokeMatches(this._userStroke, this._character, this._currentStrokeIndex, {\n            isOutlineVisible: this._renderState.state.character.outline.opacity > 0,\n            leniency: this._options.leniency,\n            averageDistanceThreshold: this._options.averageDistanceThreshold\n        }); // if markStrokeCorrectAfterMisses is passed, just force the stroke to count as correct after n tries\n        const isForceAccepted = markStrokeCorrectAfterMisses && this._mistakesOnStroke + 1 >= markStrokeCorrectAfterMisses;\n        const isAccepted = isMatch || isForceAccepted || meta.isStrokeBackwards && acceptBackwardsStrokes;\n        if (isAccepted) {\n            this._handleSuccess(meta);\n        } else {\n            this._handleFailure(meta);\n            const { showHintAfterMisses, highlightColor, strokeHighlightSpeed } = this._options;\n            if (showHintAfterMisses !== false && this._mistakesOnStroke >= showHintAfterMisses) {\n                this._renderState.run(highlightStroke(currentStroke, colorStringToVals(highlightColor), strokeHighlightSpeed));\n            }\n        }\n        this._userStroke = undefined;\n    }\n    cancel() {\n        this._isActive = false;\n        if (this._userStrokesIds) {\n            this._renderState.run(removeAllUserStrokes(this._userStrokesIds));\n        }\n    }\n    _getStrokeData(param) {\n        let { isCorrect, meta } = param;\n        return {\n            character: this._character.symbol,\n            strokeNum: this._currentStrokeIndex,\n            mistakesOnStroke: this._mistakesOnStroke,\n            totalMistakes: this._totalMistakes,\n            strokesRemaining: this._character.strokes.length - this._currentStrokeIndex - (isCorrect ? 1 : 0),\n            drawnPath: getDrawnPath(this._userStroke),\n            isBackwards: meta.isStrokeBackwards\n        };\n    }\n    nextStroke() {\n        if (!this._options) return;\n        const { strokes, symbol } = this._character;\n        const { onComplete, highlightOnComplete, strokeFadeDuration, highlightCompleteColor, highlightColor, strokeHighlightDuration } = this._options;\n        let animation = showStroke(\"main\", this._currentStrokeIndex, strokeFadeDuration);\n        this._mistakesOnStroke = 0;\n        this._currentStrokeIndex += 1;\n        const isComplete = this._currentStrokeIndex === strokes.length;\n        if (isComplete) {\n            this._isActive = false;\n            onComplete === null || onComplete === void 0 ? void 0 : onComplete({\n                character: symbol,\n                totalMistakes: this._totalMistakes\n            });\n            if (highlightOnComplete) {\n                animation = animation.concat(highlightCompleteChar(this._character, colorStringToVals(highlightCompleteColor || highlightColor), (strokeHighlightDuration || 0) * 2));\n            }\n        }\n        this._renderState.run(animation);\n    }\n    _handleSuccess(meta) {\n        if (!this._options) return;\n        const { onCorrectStroke } = this._options;\n        onCorrectStroke === null || onCorrectStroke === void 0 ? void 0 : onCorrectStroke({\n            ...this._getStrokeData({\n                isCorrect: true,\n                meta\n            })\n        });\n        this.nextStroke();\n    }\n    _handleFailure(meta) {\n        var _this$_options$onMist, _this$_options;\n        this._mistakesOnStroke += 1;\n        this._totalMistakes += 1;\n        (_this$_options$onMist = (_this$_options = this._options).onMistake) === null || _this$_options$onMist === void 0 ? void 0 : _this$_options$onMist.call(_this$_options, this._getStrokeData({\n            isCorrect: false,\n            meta\n        }));\n    }\n    _getCurrentStroke() {\n        return this._character.strokes[this._currentStrokeIndex];\n    }\n    constructor(character, renderState, positioner){\n        this._currentStrokeIndex = 0;\n        this._mistakesOnStroke = 0;\n        this._totalMistakes = 0;\n        this._character = character;\n        this._renderState = renderState;\n        this._isActive = false;\n        this._positioner = positioner;\n    }\n}\nfunction createElm(elmType) {\n    return document.createElementNS(\"http://www.w3.org/2000/svg\", elmType);\n}\nfunction attr(elm, name, value) {\n    elm.setAttributeNS(null, name, value);\n}\nfunction attrs(elm, attrsMap) {\n    Object.keys(attrsMap).forEach((attrName)=>attr(elm, attrName, attrsMap[attrName]));\n} // inspired by https://talk.observablehq.com/t/hanzi-writer-renders-incorrectly-inside-an-observable-notebook-on-a-mobile-browser/1898\nfunction urlIdRef(id) {\n    let prefix = \"\";\n    if (window.location && window.location.href) {\n        prefix = window.location.href.replace(/#[^#]*$/, \"\").replace(/\"/gi, \"%22\");\n    }\n    return 'url(\"'.concat(prefix, \"#\").concat(id, '\")');\n}\nfunction removeElm(elm) {\n    var _elm$parentNode;\n    elm === null || elm === void 0 ? void 0 : (_elm$parentNode = elm.parentNode) === null || _elm$parentNode === void 0 ? void 0 : _elm$parentNode.removeChild(elm);\n}\nclass StrokeRendererBase {\n    _getStrokeDashoffset(displayPortion) {\n        return this._pathLength * 0.999 * (1 - displayPortion);\n    }\n    _getColor(param) {\n        let { strokeColor, radicalColor } = param;\n        return radicalColor && this.stroke.isInRadical ? radicalColor : strokeColor;\n    }\n    constructor(stroke){\n        this.stroke = stroke;\n        this._pathLength = stroke.getLength() + StrokeRendererBase.STROKE_WIDTH / 2;\n    }\n}\nStrokeRendererBase.STROKE_WIDTH = 200;\nconst STROKE_WIDTH = 200;\n/** This is a stroke composed of several stroke parts **/ class StrokeRenderer extends StrokeRendererBase {\n    mount(target) {\n        this._animationPath = createElm(\"path\");\n        this._clip = createElm(\"clipPath\");\n        this._strokePath = createElm(\"path\");\n        const maskId = \"mask-\".concat(counter());\n        attr(this._clip, \"id\", maskId);\n        attr(this._strokePath, \"d\", this.stroke.path);\n        this._animationPath.style.opacity = \"0\";\n        attr(this._animationPath, \"clip-path\", urlIdRef(maskId));\n        const extendedMaskPoints = extendStart(this.stroke.points, STROKE_WIDTH / 2);\n        attr(this._animationPath, \"d\", getPathString(extendedMaskPoints));\n        attrs(this._animationPath, {\n            stroke: \"#FFFFFF\",\n            \"stroke-width\": STROKE_WIDTH.toString(),\n            fill: \"none\",\n            \"stroke-linecap\": \"round\",\n            \"stroke-linejoin\": \"miter\",\n            \"stroke-dasharray\": \"\".concat(this._pathLength, \",\").concat(this._pathLength)\n        });\n        this._clip.appendChild(this._strokePath);\n        target.defs.appendChild(this._clip);\n        target.svg.appendChild(this._animationPath);\n        return this;\n    }\n    render(props) {\n        var _this$_oldProps, _this$_oldProps2;\n        if (props === this._oldProps || !this._animationPath) {\n            return;\n        }\n        if (props.displayPortion !== ((_this$_oldProps = this._oldProps) === null || _this$_oldProps === void 0 ? void 0 : _this$_oldProps.displayPortion)) {\n            this._animationPath.style.strokeDashoffset = this._getStrokeDashoffset(props.displayPortion).toString();\n        }\n        const color = this._getColor(props);\n        if (!this._oldProps || color !== this._getColor(this._oldProps)) {\n            const { r, g, b, a } = color;\n            attrs(this._animationPath, {\n                stroke: \"rgba(\".concat(r, \",\").concat(g, \",\").concat(b, \",\").concat(a, \")\")\n            });\n        }\n        if (props.opacity !== ((_this$_oldProps2 = this._oldProps) === null || _this$_oldProps2 === void 0 ? void 0 : _this$_oldProps2.opacity)) {\n            this._animationPath.style.opacity = props.opacity.toString();\n        }\n        this._oldProps = props;\n    }\n    constructor(stroke){\n        super(stroke);\n        this._oldProps = undefined;\n    }\n}\nclass CharacterRenderer {\n    mount(target) {\n        const subTarget = target.createSubRenderTarget();\n        this._group = subTarget.svg;\n        this._strokeRenderers.forEach((strokeRenderer)=>{\n            strokeRenderer.mount(subTarget);\n        });\n    }\n    render(props) {\n        var _this$_oldProps, _this$_oldProps3;\n        if (props === this._oldProps || !this._group) {\n            return;\n        }\n        const { opacity, strokes, strokeColor, radicalColor = null } = props;\n        if (opacity !== ((_this$_oldProps = this._oldProps) === null || _this$_oldProps === void 0 ? void 0 : _this$_oldProps.opacity)) {\n            this._group.style.opacity = opacity.toString(); // MS browsers seem to have a bug where if SVG is set to display:none, it sometimes breaks.\n            // More info: https://github.com/chanind/hanzi-writer/issues/164\n            // this is just a perf improvement, so disable for MS browsers\n            if (!isMsBrowser) {\n                var _this$_oldProps2;\n                if (opacity === 0) {\n                    this._group.style.display = \"none\";\n                } else if (((_this$_oldProps2 = this._oldProps) === null || _this$_oldProps2 === void 0 ? void 0 : _this$_oldProps2.opacity) === 0) {\n                    this._group.style.removeProperty(\"display\");\n                }\n            }\n        }\n        const colorsChanged = !this._oldProps || strokeColor !== this._oldProps.strokeColor || radicalColor !== this._oldProps.radicalColor;\n        if (colorsChanged || strokes !== ((_this$_oldProps3 = this._oldProps) === null || _this$_oldProps3 === void 0 ? void 0 : _this$_oldProps3.strokes)) {\n            for(let i = 0; i < this._strokeRenderers.length; i++){\n                var _this$_oldProps4;\n                if (!colorsChanged && (_this$_oldProps4 = this._oldProps) !== null && _this$_oldProps4 !== void 0 && _this$_oldProps4.strokes && strokes[i] === this._oldProps.strokes[i]) {\n                    continue;\n                }\n                this._strokeRenderers[i].render({\n                    strokeColor,\n                    radicalColor,\n                    opacity: strokes[i].opacity,\n                    displayPortion: strokes[i].displayPortion\n                });\n            }\n        }\n        this._oldProps = props;\n    }\n    constructor(character){\n        this._oldProps = undefined;\n        this._strokeRenderers = character.strokes.map((stroke)=>new StrokeRenderer(stroke));\n    }\n}\nclass UserStrokeRenderer {\n    mount(target) {\n        this._path = createElm(\"path\");\n        target.svg.appendChild(this._path);\n    }\n    render(props) {\n        var _this$_oldProps, _this$_oldProps2, _this$_oldProps3, _this$_oldProps4;\n        if (!this._path || props === this._oldProps) {\n            return;\n        }\n        if (props.strokeColor !== ((_this$_oldProps = this._oldProps) === null || _this$_oldProps === void 0 ? void 0 : _this$_oldProps.strokeColor) || props.strokeWidth !== ((_this$_oldProps2 = this._oldProps) === null || _this$_oldProps2 === void 0 ? void 0 : _this$_oldProps2.strokeWidth)) {\n            const { r, g, b, a } = props.strokeColor;\n            attrs(this._path, {\n                fill: \"none\",\n                stroke: \"rgba(\".concat(r, \",\").concat(g, \",\").concat(b, \",\").concat(a, \")\"),\n                \"stroke-width\": props.strokeWidth.toString(),\n                \"stroke-linecap\": \"round\",\n                \"stroke-linejoin\": \"round\"\n            });\n        }\n        if (props.opacity !== ((_this$_oldProps3 = this._oldProps) === null || _this$_oldProps3 === void 0 ? void 0 : _this$_oldProps3.opacity)) {\n            attr(this._path, \"opacity\", props.opacity.toString());\n        }\n        if (props.points !== ((_this$_oldProps4 = this._oldProps) === null || _this$_oldProps4 === void 0 ? void 0 : _this$_oldProps4.points)) {\n            attr(this._path, \"d\", getPathString(props.points));\n        }\n        this._oldProps = props;\n    }\n    destroy() {\n        removeElm(this._path);\n    }\n    constructor(){\n        this._oldProps = undefined;\n    }\n}\nclass HanziWriterRenderer {\n    mount(target) {\n        const positionedTarget = target.createSubRenderTarget();\n        const group = positionedTarget.svg;\n        const { xOffset, yOffset, height, scale } = this._positioner;\n        attr(group, \"transform\", \"translate(\".concat(xOffset, \", \").concat(height - yOffset, \") scale(\").concat(scale, \", \").concat(-1 * scale, \")\"));\n        this._outlineCharRenderer.mount(positionedTarget);\n        this._mainCharRenderer.mount(positionedTarget);\n        this._highlightCharRenderer.mount(positionedTarget);\n        this._positionedTarget = positionedTarget;\n    }\n    render(props) {\n        const { main, outline, highlight } = props.character;\n        const { outlineColor, radicalColor, highlightColor, strokeColor, drawingWidth, drawingColor } = props.options;\n        this._outlineCharRenderer.render({\n            opacity: outline.opacity,\n            strokes: outline.strokes,\n            strokeColor: outlineColor\n        });\n        this._mainCharRenderer.render({\n            opacity: main.opacity,\n            strokes: main.strokes,\n            strokeColor,\n            radicalColor: radicalColor\n        });\n        this._highlightCharRenderer.render({\n            opacity: highlight.opacity,\n            strokes: highlight.strokes,\n            strokeColor: highlightColor\n        });\n        const userStrokes = props.userStrokes || {};\n        for(const userStrokeId in this._userStrokeRenderers){\n            if (!userStrokes[userStrokeId]) {\n                var _this$_userStrokeRend;\n                (_this$_userStrokeRend = this._userStrokeRenderers[userStrokeId]) === null || _this$_userStrokeRend === void 0 ? void 0 : _this$_userStrokeRend.destroy();\n                delete this._userStrokeRenderers[userStrokeId];\n            }\n        }\n        for(const userStrokeId in userStrokes){\n            const stroke = userStrokes[userStrokeId];\n            if (!stroke) {\n                continue;\n            }\n            const userStrokeProps = {\n                strokeWidth: drawingWidth,\n                strokeColor: drawingColor,\n                ...stroke\n            };\n            const strokeRenderer = (()=>{\n                if (this._userStrokeRenderers[userStrokeId]) {\n                    return this._userStrokeRenderers[userStrokeId];\n                }\n                const newStrokeRenderer = new UserStrokeRenderer();\n                newStrokeRenderer.mount(this._positionedTarget);\n                this._userStrokeRenderers[userStrokeId] = newStrokeRenderer;\n                return newStrokeRenderer;\n            })();\n            strokeRenderer.render(userStrokeProps);\n        }\n    }\n    destroy() {\n        removeElm(this._positionedTarget.svg);\n        this._positionedTarget.defs.innerHTML = \"\";\n    }\n    constructor(character, positioner){\n        this._character = character;\n        this._positioner = positioner;\n        this._mainCharRenderer = new CharacterRenderer(character);\n        this._outlineCharRenderer = new CharacterRenderer(character);\n        this._highlightCharRenderer = new CharacterRenderer(character);\n        this._userStrokeRenderers = {};\n    }\n}\n/** Generic render target */ class RenderTargetBase {\n    addPointerStartListener(callback) {\n        this.node.addEventListener(\"mousedown\", (evt)=>{\n            callback(this._eventify(evt, this._getMousePoint));\n        });\n        this.node.addEventListener(\"touchstart\", (evt)=>{\n            callback(this._eventify(evt, this._getTouchPoint));\n        });\n    }\n    addPointerMoveListener(callback) {\n        this.node.addEventListener(\"mousemove\", (evt)=>{\n            callback(this._eventify(evt, this._getMousePoint));\n        });\n        this.node.addEventListener(\"touchmove\", (evt)=>{\n            callback(this._eventify(evt, this._getTouchPoint));\n        });\n    }\n    addPointerEndListener(callback) {\n        // TODO: find a way to not need global listeners\n        document.addEventListener(\"mouseup\", callback);\n        document.addEventListener(\"touchend\", callback);\n    }\n    getBoundingClientRect() {\n        return this.node.getBoundingClientRect();\n    }\n    updateDimensions(width, height) {\n        this.node.setAttribute(\"width\", \"\".concat(width));\n        this.node.setAttribute(\"height\", \"\".concat(height));\n    }\n    _eventify(evt, pointFunc) {\n        return {\n            getPoint: ()=>pointFunc.call(this, evt),\n            preventDefault: ()=>evt.preventDefault()\n        };\n    }\n    _getMousePoint(evt) {\n        const { left, top } = this.getBoundingClientRect();\n        const x = evt.clientX - left;\n        const y = evt.clientY - top;\n        return {\n            x,\n            y\n        };\n    }\n    _getTouchPoint(evt) {\n        const { left, top } = this.getBoundingClientRect();\n        const x = evt.touches[0].clientX - left;\n        const y = evt.touches[0].clientY - top;\n        return {\n            x,\n            y\n        };\n    }\n    constructor(node){\n        this.node = node;\n    }\n}\nclass RenderTarget extends RenderTargetBase {\n    static init(elmOrId) {\n        let width = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"100%\", height = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"100%\";\n        const element = (()=>{\n            if (typeof elmOrId === \"string\") {\n                return document.getElementById(elmOrId);\n            }\n            return elmOrId;\n        })();\n        if (!element) {\n            throw new Error(\"HanziWriter target element not found: \".concat(elmOrId));\n        }\n        const nodeType = element.nodeName.toUpperCase();\n        const svg = (()=>{\n            if (nodeType === \"SVG\" || nodeType === \"G\") {\n                return element;\n            } else {\n                const svg = createElm(\"svg\");\n                element.appendChild(svg);\n                return svg;\n            }\n        })();\n        attrs(svg, {\n            width,\n            height\n        });\n        const defs = createElm(\"defs\");\n        svg.appendChild(defs);\n        return new RenderTarget(svg, defs);\n    }\n    createSubRenderTarget() {\n        const group = createElm(\"g\");\n        this.svg.appendChild(group);\n        return new RenderTarget(group, this.defs);\n    }\n    _getMousePoint(evt) {\n        if (this._pt) {\n            this._pt.x = evt.clientX;\n            this._pt.y = evt.clientY;\n            if (\"getScreenCTM\" in this.node) {\n                var _this$node$getScreenC;\n                const localPt = this._pt.matrixTransform((_this$node$getScreenC = this.node.getScreenCTM()) === null || _this$node$getScreenC === void 0 ? void 0 : _this$node$getScreenC.inverse());\n                return {\n                    x: localPt.x,\n                    y: localPt.y\n                };\n            }\n        }\n        return super._getMousePoint.call(this, evt);\n    }\n    _getTouchPoint(evt) {\n        if (this._pt) {\n            this._pt.x = evt.touches[0].clientX;\n            this._pt.y = evt.touches[0].clientY;\n            if (\"getScreenCTM\" in this.node) {\n                var _this$node$getScreenC2;\n                const localPt = this._pt.matrixTransform((_this$node$getScreenC2 = this.node.getScreenCTM()) === null || _this$node$getScreenC2 === void 0 ? void 0 : _this$node$getScreenC2.inverse());\n                return {\n                    x: localPt.x,\n                    y: localPt.y\n                };\n            }\n        }\n        return super._getTouchPoint(evt);\n    }\n    constructor(svg, defs){\n        super(svg);\n        this.svg = svg;\n        this.defs = defs;\n        if (\"createSVGPoint\" in svg) {\n            this._pt = svg.createSVGPoint();\n        }\n    }\n}\nvar svgRenderer = {\n    HanziWriterRenderer,\n    createRenderTarget: RenderTarget.init\n};\nconst drawPath = (ctx, points)=>{\n    ctx.beginPath();\n    const start = points[0];\n    const remainingPoints = points.slice(1);\n    ctx.moveTo(start.x, start.y);\n    for (const point of remainingPoints){\n        ctx.lineTo(point.x, point.y);\n    }\n    ctx.stroke();\n};\n/**\n * Break a path string into a series of canvas path commands\n *\n * Note: only works with the subset of SVG paths used by MakeMeAHanzi data\n * @param pathString\n */ const pathStringToCanvas = (pathString)=>{\n    const pathParts = pathString.split(/(^|\\s+)(?=[A-Z])/).filter((part)=>part !== \" \");\n    const commands = [\n        (ctx)=>ctx.beginPath()\n    ];\n    for (const part of pathParts){\n        const [cmd, ...rawParams] = part.split(/\\s+/);\n        const params = rawParams.map((param)=>parseFloat(param));\n        if (cmd === \"M\") {\n            commands.push((ctx)=>ctx.moveTo(...params));\n        } else if (cmd === \"L\") {\n            commands.push((ctx)=>ctx.lineTo(...params));\n        } else if (cmd === \"C\") {\n            commands.push((ctx)=>ctx.bezierCurveTo(...params));\n        } else if (cmd === \"Q\") {\n            commands.push((ctx)=>ctx.quadraticCurveTo(...params));\n        } else ;\n    }\n    return (ctx)=>commands.forEach((cmd)=>cmd(ctx));\n};\n/** this is a stroke composed of several stroke parts */ class StrokeRenderer$1 extends StrokeRendererBase {\n    render(ctx, props) {\n        if (props.opacity < 0.05) {\n            return;\n        }\n        ctx.save();\n        if (this._path2D) {\n            ctx.clip(this._path2D);\n        } else {\n            var _this$_pathCmd;\n            (_this$_pathCmd = this._pathCmd) === null || _this$_pathCmd === void 0 ? void 0 : _this$_pathCmd.call(this, ctx); // wechat bugs out if the clip path isn't stroked or filled\n            ctx.globalAlpha = 0;\n            ctx.stroke();\n            ctx.clip();\n        }\n        const { r, g, b, a } = this._getColor(props);\n        const color = a === 1 ? \"rgb(\".concat(r, \",\").concat(g, \",\").concat(b, \")\") : \"rgb(\".concat(r, \",\").concat(g, \",\").concat(b, \",\").concat(a, \")\");\n        const dashOffset = this._getStrokeDashoffset(props.displayPortion);\n        ctx.globalAlpha = props.opacity;\n        ctx.strokeStyle = color;\n        ctx.fillStyle = color;\n        ctx.lineWidth = StrokeRendererBase.STROKE_WIDTH;\n        ctx.lineCap = \"round\";\n        ctx.lineJoin = \"round\"; // wechat sets dashOffset as a second param here. Should be harmless for browsers to add here too\n        // @ts-ignore\n        ctx.setLineDash([\n            this._pathLength,\n            this._pathLength\n        ], dashOffset);\n        ctx.lineDashOffset = dashOffset;\n        drawPath(ctx, this._extendedMaskPoints);\n        ctx.restore();\n    }\n    constructor(stroke, usePath2D = true){\n        super(stroke);\n        if (usePath2D && Path2D) {\n            this._path2D = new Path2D(this.stroke.path);\n        } else {\n            this._pathCmd = pathStringToCanvas(this.stroke.path);\n        }\n        this._extendedMaskPoints = extendStart(this.stroke.points, StrokeRendererBase.STROKE_WIDTH / 2);\n    }\n}\nclass CharacterRenderer$1 {\n    render(ctx, props) {\n        if (props.opacity < 0.05) return;\n        const { opacity, strokeColor, radicalColor, strokes } = props;\n        for(let i = 0; i < this._strokeRenderers.length; i++){\n            this._strokeRenderers[i].render(ctx, {\n                strokeColor,\n                radicalColor,\n                opacity: strokes[i].opacity * opacity,\n                displayPortion: strokes[i].displayPortion || 0\n            });\n        }\n    }\n    constructor(character){\n        this._strokeRenderers = character.strokes.map((stroke)=>new StrokeRenderer$1(stroke));\n    }\n}\nfunction renderUserStroke(ctx, props) {\n    if (props.opacity < 0.05) {\n        return;\n    }\n    const { opacity, strokeWidth, strokeColor, points } = props;\n    const { r, g, b, a } = strokeColor;\n    ctx.save();\n    ctx.globalAlpha = opacity;\n    ctx.lineWidth = strokeWidth;\n    ctx.strokeStyle = \"rgba(\".concat(r, \",\").concat(g, \",\").concat(b, \",\").concat(a, \")\");\n    ctx.lineCap = \"round\";\n    ctx.lineJoin = \"round\";\n    drawPath(ctx, points);\n    ctx.restore();\n}\nclass HanziWriterRenderer$1 {\n    mount(target) {\n        this._target = target;\n    }\n    _animationFrame(cb) {\n        const { width, height, scale, xOffset, yOffset } = this._positioner;\n        const ctx = this._target.getContext();\n        ctx.clearRect(0, 0, width, height);\n        ctx.save();\n        ctx.translate(xOffset, height - yOffset);\n        ctx.transform(1, 0, 0, -1, 0, 0);\n        ctx.scale(scale, scale);\n        cb(ctx);\n        ctx.restore(); // @ts-expect-error Verify if this is still needed for the \"wechat miniprogram\".\n        if (ctx.draw) {\n            // @ts-expect-error\n            ctx.draw();\n        }\n    }\n    render(props) {\n        const { outline, main, highlight } = props.character;\n        const { outlineColor, strokeColor, radicalColor, highlightColor, drawingColor, drawingWidth } = props.options;\n        this._animationFrame((ctx)=>{\n            this._outlineCharRenderer.render(ctx, {\n                opacity: outline.opacity,\n                strokes: outline.strokes,\n                strokeColor: outlineColor\n            });\n            this._mainCharRenderer.render(ctx, {\n                opacity: main.opacity,\n                strokes: main.strokes,\n                strokeColor: strokeColor,\n                radicalColor: radicalColor\n            });\n            this._highlightCharRenderer.render(ctx, {\n                opacity: highlight.opacity,\n                strokes: highlight.strokes,\n                strokeColor: highlightColor\n            });\n            const userStrokes = props.userStrokes || {};\n            for(const userStrokeId in userStrokes){\n                const userStroke = userStrokes[userStrokeId];\n                if (userStroke) {\n                    const userStrokeProps = {\n                        strokeWidth: drawingWidth,\n                        strokeColor: drawingColor,\n                        ...userStroke\n                    };\n                    renderUserStroke(ctx, userStrokeProps);\n                }\n            }\n        });\n    }\n    constructor(character, positioner){\n        this.destroy = noop;\n        this._character = character;\n        this._positioner = positioner;\n        this._mainCharRenderer = new CharacterRenderer$1(character);\n        this._outlineCharRenderer = new CharacterRenderer$1(character);\n        this._highlightCharRenderer = new CharacterRenderer$1(character);\n    }\n}\nclass RenderTarget$1 extends RenderTargetBase {\n    static init(elmOrId) {\n        let width = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"100%\", height = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"100%\";\n        const element = (()=>{\n            if (typeof elmOrId === \"string\") {\n                return document.getElementById(elmOrId);\n            }\n            return elmOrId;\n        })();\n        if (!element) {\n            throw new Error(\"HanziWriter target element not found: \".concat(elmOrId));\n        }\n        const nodeType = element.nodeName.toUpperCase();\n        const canvas = (()=>{\n            if (nodeType === \"CANVAS\") {\n                return element;\n            }\n            const canvas = document.createElement(\"canvas\");\n            element.appendChild(canvas);\n            return canvas;\n        })();\n        canvas.setAttribute(\"width\", width);\n        canvas.setAttribute(\"height\", height);\n        return new RenderTarget$1(canvas);\n    }\n    getContext() {\n        return this.node.getContext(\"2d\");\n    }\n    constructor(canvas){\n        super(canvas);\n    }\n}\nvar canvasRenderer = {\n    HanziWriterRenderer: HanziWriterRenderer$1,\n    createRenderTarget: RenderTarget$1.init\n};\nconst VERSION = \"2.0.1\";\nconst getCharDataUrl = (char)=>\"https://cdn.jsdelivr.net/npm/hanzi-writer-data@\".concat(VERSION, \"/\").concat(char, \".json\");\nconst defaultCharDataLoader = (char, onLoad, onError)=>{\n    // load char data from hanziwriter cdn (currently hosted on jsdelivr)\n    const xhr = new XMLHttpRequest();\n    if (xhr.overrideMimeType) {\n        // IE 9 and 10 don't seem to support this...\n        xhr.overrideMimeType(\"application/json\");\n    }\n    xhr.open(\"GET\", getCharDataUrl(char), true);\n    xhr.onerror = (event)=>{\n        onError(xhr, event);\n    };\n    xhr.onreadystatechange = ()=>{\n        // TODO: error handling\n        if (xhr.readyState !== 4) return;\n        if (xhr.status === 200) {\n            onLoad(JSON.parse(xhr.responseText));\n        } else if (xhr.status !== 0 && onError) {\n            onError(xhr);\n        }\n    };\n    xhr.send(null);\n};\nconst defaultOptions = {\n    charDataLoader: defaultCharDataLoader,\n    onLoadCharDataError: null,\n    onLoadCharDataSuccess: null,\n    showOutline: true,\n    showCharacter: true,\n    renderer: \"svg\",\n    // positioning options\n    width: 0,\n    height: 0,\n    padding: 20,\n    // animation options\n    strokeAnimationSpeed: 1,\n    strokeFadeDuration: 400,\n    strokeHighlightDuration: 200,\n    strokeHighlightSpeed: 2,\n    delayBetweenStrokes: 1000,\n    delayBetweenLoops: 2000,\n    // colors\n    strokeColor: \"#555\",\n    radicalColor: null,\n    highlightColor: \"#AAF\",\n    outlineColor: \"#DDD\",\n    drawingColor: \"#333\",\n    // quiz options\n    leniency: 1,\n    showHintAfterMisses: 3,\n    highlightOnComplete: true,\n    highlightCompleteColor: null,\n    markStrokeCorrectAfterMisses: false,\n    acceptBackwardsStrokes: false,\n    quizStartStrokeNum: 0,\n    averageDistanceThreshold: 350,\n    // undocumented obscure options\n    drawingFadeDuration: 300,\n    drawingWidth: 4,\n    strokeWidth: 2,\n    outlineWidth: 2,\n    rendererOverride: {}\n};\nclass LoadingManager {\n    _debouncedLoad(char, count) {\n        // these wrappers ignore all responses except the most recent.\n        const wrappedResolve = (data)=>{\n            if (count === this._loadCounter) {\n                var _this$_resolve;\n                (_this$_resolve = this._resolve) === null || _this$_resolve === void 0 ? void 0 : _this$_resolve.call(this, data);\n            }\n        };\n        const wrappedReject = (reason)=>{\n            if (count === this._loadCounter) {\n                var _this$_reject;\n                (_this$_reject = this._reject) === null || _this$_reject === void 0 ? void 0 : _this$_reject.call(this, reason);\n            }\n        };\n        const returnedData = this._options.charDataLoader(char, wrappedResolve, wrappedReject);\n        if (returnedData) {\n            if (\"then\" in returnedData) {\n                returnedData.then(wrappedResolve).catch(wrappedReject);\n            } else {\n                wrappedResolve(returnedData);\n            }\n        }\n    }\n    _setupLoadingPromise() {\n        return new Promise((resolve, reject)=>{\n            this._resolve = resolve;\n            this._reject = reject;\n        }).then((data)=>{\n            var _this$_options$onLoad, _this$_options;\n            this._isLoading = false;\n            (_this$_options$onLoad = (_this$_options = this._options).onLoadCharDataSuccess) === null || _this$_options$onLoad === void 0 ? void 0 : _this$_options$onLoad.call(_this$_options, data);\n            return data;\n        }).catch((reason)=>{\n            this._isLoading = false;\n            this.loadingFailed = true; // If the user has provided an \"onLoadCharDataError\", call this function\n            // Otherwise, throw the promise\n            if (this._options.onLoadCharDataError) {\n                this._options.onLoadCharDataError(reason);\n                return;\n            } // If error callback wasn't provided, throw an error so the developer will be aware something went wrong\n            if (reason instanceof Error) {\n                throw reason;\n            }\n            const err = new Error(\"Failed to load char data for \".concat(this._loadingChar));\n            err.reason = reason;\n            throw err;\n        });\n    }\n    loadCharData(char) {\n        this._loadingChar = char;\n        const promise = this._setupLoadingPromise();\n        this.loadingFailed = false;\n        this._isLoading = true;\n        this._loadCounter++;\n        this._debouncedLoad(char, this._loadCounter);\n        return promise;\n    }\n    constructor(options){\n        this._loadCounter = 0;\n        this._isLoading = false;\n        /** use this to attribute to determine if there was a problem with loading */ this.loadingFailed = false;\n        this._options = options;\n    }\n}\nclass HanziWriter {\n    /** Main entry point */ static create(element, character, options) {\n        const writer = new HanziWriter(element, options);\n        writer.setCharacter(character);\n        return writer;\n    }\n    static loadCharacterData(character) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const loadingManager = (()=>{\n            const { _loadingManager, _loadingOptions } = HanziWriter;\n            if ((_loadingManager === null || _loadingManager === void 0 ? void 0 : _loadingManager._loadingChar) === character && _loadingOptions === options) {\n                return _loadingManager;\n            }\n            return new LoadingManager({\n                ...defaultOptions,\n                ...options\n            });\n        })();\n        HanziWriter._loadingManager = loadingManager;\n        HanziWriter._loadingOptions = options;\n        return loadingManager.loadCharData(character);\n    }\n    static getScalingTransform(width, height) {\n        let padding = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        const positioner = new Positioner({\n            width,\n            height,\n            padding\n        });\n        return {\n            x: positioner.xOffset,\n            y: positioner.yOffset,\n            scale: positioner.scale,\n            transform: trim(\"\\n        translate(\".concat(positioner.xOffset, \", \").concat(positioner.height - positioner.yOffset, \")\\n        scale(\").concat(positioner.scale, \", \").concat(-1 * positioner.scale, \")\\n      \")).replace(/\\s+/g, \" \")\n        };\n    }\n    showCharacter() {\n        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        this._options.showCharacter = true;\n        return this._withData(()=>{\n            var _this$_renderState;\n            return (_this$_renderState = this._renderState) === null || _this$_renderState === void 0 ? void 0 : _this$_renderState.run(showCharacter(\"main\", this._character, typeof options.duration === \"number\" ? options.duration : this._options.strokeFadeDuration)).then((res)=>{\n                var _options$onComplete;\n                (_options$onComplete = options.onComplete) === null || _options$onComplete === void 0 ? void 0 : _options$onComplete.call(options, res);\n                return res;\n            });\n        });\n    }\n    hideCharacter() {\n        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        this._options.showCharacter = false;\n        return this._withData(()=>{\n            var _this$_renderState2;\n            return (_this$_renderState2 = this._renderState) === null || _this$_renderState2 === void 0 ? void 0 : _this$_renderState2.run(hideCharacter(\"main\", this._character, typeof options.duration === \"number\" ? options.duration : this._options.strokeFadeDuration)).then((res)=>{\n                var _options$onComplete2;\n                (_options$onComplete2 = options.onComplete) === null || _options$onComplete2 === void 0 ? void 0 : _options$onComplete2.call(options, res);\n                return res;\n            });\n        });\n    }\n    animateCharacter() {\n        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        this.cancelQuiz();\n        return this._withData(()=>{\n            var _this$_renderState3;\n            return (_this$_renderState3 = this._renderState) === null || _this$_renderState3 === void 0 ? void 0 : _this$_renderState3.run(animateCharacter(\"main\", this._character, this._options.strokeFadeDuration, this._options.strokeAnimationSpeed, this._options.delayBetweenStrokes)).then((res)=>{\n                var _options$onComplete3;\n                (_options$onComplete3 = options.onComplete) === null || _options$onComplete3 === void 0 ? void 0 : _options$onComplete3.call(options, res);\n                return res;\n            });\n        });\n    }\n    animateStroke(strokeNum) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        this.cancelQuiz();\n        return this._withData(()=>{\n            var _this$_renderState4;\n            return (_this$_renderState4 = this._renderState) === null || _this$_renderState4 === void 0 ? void 0 : _this$_renderState4.run(animateSingleStroke(\"main\", this._character, fixIndex(strokeNum, this._character.strokes.length), this._options.strokeAnimationSpeed)).then((res)=>{\n                var _options$onComplete4;\n                (_options$onComplete4 = options.onComplete) === null || _options$onComplete4 === void 0 ? void 0 : _options$onComplete4.call(options, res);\n                return res;\n            });\n        });\n    }\n    highlightStroke(strokeNum) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const promise = ()=>{\n            if (!this._character || !this._renderState) {\n                return;\n            }\n            return this._renderState.run(highlightStroke(selectIndex(this._character.strokes, strokeNum), colorStringToVals(this._options.highlightColor), this._options.strokeHighlightSpeed)).then((res)=>{\n                var _options$onComplete5;\n                (_options$onComplete5 = options.onComplete) === null || _options$onComplete5 === void 0 ? void 0 : _options$onComplete5.call(options, res);\n                return res;\n            });\n        };\n        return this._withData(promise);\n    }\n    async loopCharacterAnimation() {\n        this.cancelQuiz();\n        return this._withData(()=>this._renderState.run(animateCharacterLoop(\"main\", this._character, this._options.strokeFadeDuration, this._options.strokeAnimationSpeed, this._options.delayBetweenStrokes, this._options.delayBetweenLoops), {\n                loop: true\n            }));\n    }\n    pauseAnimation() {\n        return this._withData(()=>{\n            var _this$_renderState5;\n            return (_this$_renderState5 = this._renderState) === null || _this$_renderState5 === void 0 ? void 0 : _this$_renderState5.pauseAll();\n        });\n    }\n    resumeAnimation() {\n        return this._withData(()=>{\n            var _this$_renderState6;\n            return (_this$_renderState6 = this._renderState) === null || _this$_renderState6 === void 0 ? void 0 : _this$_renderState6.resumeAll();\n        });\n    }\n    showOutline() {\n        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        this._options.showOutline = true;\n        return this._withData(()=>{\n            var _this$_renderState7;\n            return (_this$_renderState7 = this._renderState) === null || _this$_renderState7 === void 0 ? void 0 : _this$_renderState7.run(showCharacter(\"outline\", this._character, typeof options.duration === \"number\" ? options.duration : this._options.strokeFadeDuration)).then((res)=>{\n                var _options$onComplete6;\n                (_options$onComplete6 = options.onComplete) === null || _options$onComplete6 === void 0 ? void 0 : _options$onComplete6.call(options, res);\n                return res;\n            });\n        });\n    }\n    hideOutline() {\n        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        this._options.showOutline = false;\n        return this._withData(()=>{\n            var _this$_renderState8;\n            return (_this$_renderState8 = this._renderState) === null || _this$_renderState8 === void 0 ? void 0 : _this$_renderState8.run(hideCharacter(\"outline\", this._character, typeof options.duration === \"number\" ? options.duration : this._options.strokeFadeDuration)).then((res)=>{\n                var _options$onComplete7;\n                (_options$onComplete7 = options.onComplete) === null || _options$onComplete7 === void 0 ? void 0 : _options$onComplete7.call(options, res);\n                return res;\n            });\n        });\n    }\n    /** Updates the size of the writer instance without resetting render state */ updateDimensions(param) {\n        let { width, height, padding } = param;\n        if (width !== undefined) this._options.width = width;\n        if (height !== undefined) this._options.height = height;\n        if (padding !== undefined) this._options.padding = padding;\n        this.target.updateDimensions(this._options.width, this._options.height); // if there's already a character drawn, destroy and recreate the renderer in the same state\n        if (this._character && this._renderState && this._hanziWriterRenderer && this._positioner) {\n            this._hanziWriterRenderer.destroy();\n            const hanziWriterRenderer = this._initAndMountHanziWriterRenderer(this._character); // TODO: this should probably implement EventEmitter instead of manually tracking updates like this\n            this._renderState.overwriteOnStateChange((nextState)=>hanziWriterRenderer.render(nextState));\n            hanziWriterRenderer.render(this._renderState.state); // update the current quiz as well, if one is active\n            if (this._quiz) {\n                this._quiz.setPositioner(this._positioner);\n            }\n        }\n    }\n    updateColor(colorName, colorVal) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        var _options$duration;\n        let mutations = [];\n        const fixedColorVal = (()=>{\n            // If we're removing radical color, tween it to the stroke color\n            if (colorName === \"radicalColor\" && !colorVal) {\n                return this._options.strokeColor;\n            }\n            return colorVal;\n        })();\n        const mappedColor = colorStringToVals(fixedColorVal);\n        this._options[colorName] = colorVal;\n        const duration = (_options$duration = options.duration) !== null && _options$duration !== void 0 ? _options$duration : this._options.strokeFadeDuration;\n        mutations = mutations.concat(updateColor(colorName, mappedColor, duration)); // make sure to set radicalColor back to null after the transition finishes if val == null\n        if (colorName === \"radicalColor\" && !colorVal) {\n            mutations = mutations.concat(updateColor(colorName, null, 0));\n        }\n        return this._withData(()=>{\n            var _this$_renderState9;\n            return (_this$_renderState9 = this._renderState) === null || _this$_renderState9 === void 0 ? void 0 : _this$_renderState9.run(mutations).then((res)=>{\n                var _options$onComplete8;\n                (_options$onComplete8 = options.onComplete) === null || _options$onComplete8 === void 0 ? void 0 : _options$onComplete8.call(options, res);\n                return res;\n            });\n        });\n    }\n    quiz() {\n        let quizOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        return this._withData(async ()=>{\n            if (this._character && this._renderState && this._positioner) {\n                this.cancelQuiz();\n                this._quiz = new Quiz(this._character, this._renderState, this._positioner);\n                this._options = {\n                    ...this._options,\n                    ...quizOptions\n                };\n                this._quiz.startQuiz(this._options);\n            }\n        });\n    }\n    skipQuizStroke() {\n        if (this._quiz) {\n            this._quiz.nextStroke();\n        }\n    }\n    cancelQuiz() {\n        if (this._quiz) {\n            this._quiz.cancel();\n            this._quiz = undefined;\n        }\n    }\n    setCharacter(char) {\n        this.cancelQuiz();\n        this._char = char;\n        if (this._hanziWriterRenderer) {\n            this._hanziWriterRenderer.destroy();\n        }\n        if (this._renderState) {\n            this._renderState.cancelAll();\n        }\n        this._hanziWriterRenderer = null;\n        this._withDataPromise = this._loadingManager.loadCharData(char).then((pathStrings)=>{\n            // if \"pathStrings\" isn't set, \".catch()\"\" was probably called and loading likely failed\n            if (!pathStrings || this._loadingManager.loadingFailed) {\n                return;\n            }\n            this._character = parseCharData(char, pathStrings);\n            this._renderState = new RenderState(this._character, this._options, (nextState)=>hanziWriterRenderer.render(nextState));\n            const hanziWriterRenderer = this._initAndMountHanziWriterRenderer(this._character);\n            hanziWriterRenderer.render(this._renderState.state);\n        });\n        return this._withDataPromise;\n    }\n    _initAndMountHanziWriterRenderer(character) {\n        const { width, height, padding } = this._options;\n        this._positioner = new Positioner({\n            width,\n            height,\n            padding\n        });\n        const hanziWriterRenderer = new this._renderer.HanziWriterRenderer(character, this._positioner);\n        hanziWriterRenderer.mount(this.target);\n        this._hanziWriterRenderer = hanziWriterRenderer;\n        return hanziWriterRenderer;\n    }\n    async getCharacterData() {\n        if (!this._char) {\n            throw new Error(\"setCharacter() must be called before calling getCharacterData()\");\n        }\n        const character = await this._withData(()=>this._character);\n        return character;\n    }\n    _assignOptions(options) {\n        const mergedOptions = {\n            ...defaultOptions,\n            ...options\n        }; // backfill strokeAnimationSpeed if deprecated strokeAnimationDuration is provided instead\n        if (options.strokeAnimationDuration && !options.strokeAnimationSpeed) {\n            mergedOptions.strokeAnimationSpeed = 500 / options.strokeAnimationDuration;\n        }\n        if (options.strokeHighlightDuration && !options.strokeHighlightSpeed) {\n            mergedOptions.strokeHighlightSpeed = 500 / mergedOptions.strokeHighlightDuration;\n        }\n        if (!options.highlightCompleteColor) {\n            mergedOptions.highlightCompleteColor = mergedOptions.highlightColor;\n        }\n        return this._fillWidthAndHeight(mergedOptions);\n    }\n    /** returns a new options object with width and height filled in if missing */ _fillWidthAndHeight(options) {\n        const filledOpts = {\n            ...options\n        };\n        if (filledOpts.width && !filledOpts.height) {\n            filledOpts.height = filledOpts.width;\n        } else if (filledOpts.height && !filledOpts.width) {\n            filledOpts.width = filledOpts.height;\n        } else if (!filledOpts.width && !filledOpts.height) {\n            const { width, height } = this.target.getBoundingClientRect();\n            const minDim = Math.min(width, height);\n            filledOpts.width = minDim;\n            filledOpts.height = minDim;\n        }\n        return filledOpts;\n    }\n    _withData(func) {\n        // if this._loadingManager.loadingFailed, then loading failed before this method was called\n        if (this._loadingManager.loadingFailed) {\n            throw Error(\"Failed to load character data. Call setCharacter and try again.\");\n        }\n        if (this._withDataPromise) {\n            return this._withDataPromise.then(()=>{\n                if (!this._loadingManager.loadingFailed) {\n                    return func();\n                }\n            });\n        }\n        return Promise.resolve().then(func);\n    }\n    _setupListeners() {\n        this.target.addPointerStartListener((evt)=>{\n            if (this._quiz) {\n                evt.preventDefault();\n                this._quiz.startUserStroke(evt.getPoint());\n            }\n        });\n        this.target.addPointerMoveListener((evt)=>{\n            if (this._quiz) {\n                evt.preventDefault();\n                this._quiz.continueUserStroke(evt.getPoint());\n            }\n        });\n        this.target.addPointerEndListener(()=>{\n            var _this$_quiz;\n            (_this$_quiz = this._quiz) === null || _this$_quiz === void 0 ? void 0 : _this$_quiz.endUserStroke();\n        });\n    }\n    constructor(element, options = {}){\n        const { HanziWriterRenderer, createRenderTarget } = options.renderer === \"canvas\" ? canvasRenderer : svgRenderer;\n        const rendererOverride = options.rendererOverride || {};\n        this._renderer = {\n            HanziWriterRenderer: rendererOverride.HanziWriterRenderer || HanziWriterRenderer,\n            createRenderTarget: rendererOverride.createRenderTarget || createRenderTarget\n        }; // wechat miniprogram component needs direct access to the render target, so this is public\n        this.target = this._renderer.createRenderTarget(element, options.width, options.height);\n        this._options = this._assignOptions(options);\n        this._loadingManager = new LoadingManager(this._options);\n        this._setupListeners();\n    }\n}\n/** Singleton instance of LoadingManager. Only set in `loadCharacterData` */ HanziWriter._loadingManager = null;\n/** Singleton loading options. Only set in `loadCharacterData` */ HanziWriter._loadingOptions = null;\n/* harmony default export */ __webpack_exports__[\"default\"] = (HanziWriter); //# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9oYW56aS13cml0ZXIvZGlzdC9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6IjtBQUFBOztDQUVDLEdBRUQsSUFBSUEsdUJBQXVCQyx1QkFBdUJDLHNCQUFzQixzRkFBc0Y7QUFHOUosTUFBTUMsWUFBWSxNQUFrQixHQUFjQyxDQUFNQSxHQUFHQztBQUMzRCxNQUFNQyxpQkFBaUJILFVBQVVJLFdBQVcsSUFBSyxLQUFNSixVQUFVSSxXQUFXLENBQUNDLEdBQUcsRUFBQyxLQUFPLEtBQU1DLEtBQUtELEdBQUcsRUFBQztBQUN2RyxNQUFNRSx3QkFBd0IsQ0FBQyxDQUFDVix3QkFBd0JHLFVBQVVPLHFCQUFxQixNQUFNLFFBQVFWLDBCQUEwQixLQUFLLElBQUksS0FBSyxJQUFJQSxzQkFBc0JXLElBQUksQ0FBQ1IsVUFBUyxLQUFPUyxDQUFBQSxDQUFBQSxXQUFZQyxXQUFXLElBQU1ELFNBQVNOLG1CQUFtQixPQUFPLEdBQUU7QUFDOVAsTUFBTVEsdUJBQXVCLENBQUMsQ0FBQ2Isd0JBQXdCRSxVQUFVVyxvQkFBb0IsTUFBTSxRQUFRYiwwQkFBMEIsS0FBSyxJQUFJLEtBQUssSUFBSUEsc0JBQXNCVSxJQUFJLENBQUNSLFVBQVMsS0FBTVksY0FBYyx3Q0FBd0M7QUFDL08sU0FBU0MsUUFBUUMsR0FBRztJQUNsQixPQUFPQSxHQUFHLENBQUNBLElBQUlDLE1BQU0sR0FBRyxFQUFFO0FBQzVCO0FBQ0EsTUFBTUMsV0FBVyxDQUFDQyxPQUFPRjtJQUN2QixxREFBcUQ7SUFDckQsSUFBSUUsUUFBUSxHQUFHO1FBQ2IsT0FBT0YsU0FBU0U7SUFDbEI7SUFFQSxPQUFPQTtBQUNUO0FBQ0EsTUFBTUMsY0FBYyxDQUFDSixLQUFLRztJQUN4Qix5RUFBeUU7SUFDekUsT0FBT0gsR0FBRyxDQUFDRSxTQUFTQyxPQUFPSCxJQUFJQyxNQUFNLEVBQUU7QUFDekM7QUFDQSxTQUFTSSxpQkFBaUJDLElBQUksRUFBRUMsUUFB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WkE5UixZQUFZbWEsT0FBTyxFQUFFMWMsVUFBVSxDQUFDLENBQUMsQ0FBRTtRQUNqQyxNQUFNLEVBQ0pzYSxtQkFBbUIsRUFDbkJpRCxrQkFBa0IsRUFDbkIsR0FBR3ZkLFFBQVEraEIsUUFBUSxLQUFLLFdBQVd4QixpQkFBaUJqRDtRQUNyRCxNQUFNNEUsbUJBQW1CbGlCLFFBQVFraUIsZ0JBQWdCLElBQUksQ0FBQztRQUN0RCxJQUFJLENBQUNtRSxTQUFTLEdBQUc7WUFDZi9MLHFCQUFxQjRILGlCQUFpQjVILG1CQUFtQixJQUFJQTtZQUM3RGlELG9CQUFvQjJFLGlCQUFpQjNFLGtCQUFrQixJQUFJQTtRQUM3RCxHQUFHLDJGQUEyRjtRQUU5RixJQUFJLENBQUNoTSxNQUFNLEdBQUcsSUFBSSxDQUFDOFUsU0FBUyxDQUFDOUksa0JBQWtCLENBQUNiLFNBQVMxYyxRQUFRbUwsS0FBSyxFQUFFbkwsUUFBUWdMLE1BQU07UUFDdEYsSUFBSSxDQUFDMkksUUFBUSxHQUFHLElBQUksQ0FBQzRTLGNBQWMsQ0FBQ3ZtQjtRQUNwQyxJQUFJLENBQUM2akIsZUFBZSxHQUFHLElBQUkxQixlQUFlLElBQUksQ0FBQ3hPLFFBQVE7UUFFdkQsSUFBSSxDQUFDbVQsZUFBZTtJQUN0QjtBQWdaRjtBQUNBLDBFQUEwRSxHQUUxRXZELFlBQVlNLGVBQWUsR0FBRztBQUM5QiwrREFBK0QsR0FFL0ROLFlBQVlPLGVBQWUsR0FBRztBQUU5QiwrREFBZVAsV0FBV0EsRUFBQyxDQUMzQixxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2hhbnppLXdyaXRlci9kaXN0L2luZGV4LmVzbS5qcz9hZmRmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSGFuemkgV3JpdGVyIHYzLjcuMyB8IGh0dHBzOi8vY2hhbmluZC5naXRodWIuaW8vaGFuemktd3JpdGVyXG4gKi9cblxudmFyIF9nbG9iYWxPYmokcmVxdWVzdEFuaSwgX2dsb2JhbE9iaiRjYW5jZWxBbmltLCBfZ2xvYmFsT2JqJG5hdmlnYXRvcjsgLy8gaGFja3kgd2F5IHRvIGdldCBhcm91bmQgcm9sbHVwIG5vdCBwcm9wZXJseSBzZXR0aW5nIGBnbG9iYWxgIHRvIGB3aW5kb3dgIGluIGJyb3dzZXJcblxuXG5jb25zdCBnbG9iYWxPYmogPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHdpbmRvdztcbmNvbnN0IHBlcmZvcm1hbmNlTm93ID0gZ2xvYmFsT2JqLnBlcmZvcm1hbmNlICYmICgoKSA9PiBnbG9iYWxPYmoucGVyZm9ybWFuY2Uubm93KCkpIHx8ICgoKSA9PiBEYXRlLm5vdygpKTtcbmNvbnN0IHJlcXVlc3RBbmltYXRpb25GcmFtZSA9ICgoX2dsb2JhbE9iaiRyZXF1ZXN0QW5pID0gZ2xvYmFsT2JqLnJlcXVlc3RBbmltYXRpb25GcmFtZSkgPT09IG51bGwgfHwgX2dsb2JhbE9iaiRyZXF1ZXN0QW5pID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2xvYmFsT2JqJHJlcXVlc3RBbmkuYmluZChnbG9iYWxPYmopKSB8fCAoY2FsbGJhY2sgPT4gc2V0VGltZW91dCgoKSA9PiBjYWxsYmFjayhwZXJmb3JtYW5jZU5vdygpKSwgMTAwMCAvIDYwKSk7XG5jb25zdCBjYW5jZWxBbmltYXRpb25GcmFtZSA9ICgoX2dsb2JhbE9iaiRjYW5jZWxBbmltID0gZ2xvYmFsT2JqLmNhbmNlbEFuaW1hdGlvbkZyYW1lKSA9PT0gbnVsbCB8fCBfZ2xvYmFsT2JqJGNhbmNlbEFuaW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nbG9iYWxPYmokY2FuY2VsQW5pbS5iaW5kKGdsb2JhbE9iaikpIHx8IGNsZWFyVGltZW91dDsgLy8gT2JqZWN0LmFzc2lnbiBwb2x5ZmlsbCwgYmVjYXVzZSBJRSA6L1xuZnVuY3Rpb24gYXJyTGFzdChhcnIpIHtcbiAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV07XG59XG5jb25zdCBmaXhJbmRleCA9IChpbmRleCwgbGVuZ3RoKSA9PiB7XG4gIC8vIGhlbHBlciB0byBoYW5kbGUgbmVnYXRpdmUgaW5kZXhlcyBpbiBhcnJheSBpbmRpY2VzXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gbGVuZ3RoICsgaW5kZXg7XG4gIH1cblxuICByZXR1cm4gaW5kZXg7XG59O1xuY29uc3Qgc2VsZWN0SW5kZXggPSAoYXJyLCBpbmRleCkgPT4ge1xuICAvLyBoZWxwZXIgdG8gc2VsZWN0IGl0ZW0gZnJvbSBhcnJheSBhdCBpbmRleCwgc3VwcG9ydGluZyBuZWdhdGl2ZSBpbmRleGVzXG4gIHJldHVybiBhcnJbZml4SW5kZXgoaW5kZXgsIGFyci5sZW5ndGgpXTtcbn07XG5mdW5jdGlvbiBjb3B5QW5kTWVyZ2VEZWVwKGJhc2UsIG92ZXJyaWRlKSB7XG4gIGNvbnN0IG91dHB1dCA9IHsgLi4uYmFzZVxuICB9O1xuXG4gIGZvciAoY29uc3Qga2V5IGluIG92ZXJyaWRlKSB7XG4gICAgY29uc3QgYmFzZVZhbCA9IGJhc2Vba2V5XTtcbiAgICBjb25zdCBvdmVycmlkZVZhbCA9IG92ZXJyaWRlW2tleV07XG5cbiAgICBpZiAoYmFzZVZhbCA9PT0gb3ZlcnJpZGVWYWwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChiYXNlVmFsICYmIG92ZXJyaWRlVmFsICYmIHR5cGVvZiBiYXNlVmFsID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3ZlcnJpZGVWYWwgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG92ZXJyaWRlVmFsKSkge1xuICAgICAgb3V0cHV0W2tleV0gPSBjb3B5QW5kTWVyZ2VEZWVwKGJhc2VWYWwsIG92ZXJyaWRlVmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgb3V0cHV0W2tleV0gPSBvdmVycmlkZVZhbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuLyoqIGJhc2ljYWxseSBhIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiBsb2Rhc2guZ2V0LCBzZWxlY3RzIGEga2V5IG91dCBvZiBhbiBvYmplY3QgbGlrZSAnYS5iJyBmcm9tIHthOiB7YjogN319ICovXG5cbmZ1bmN0aW9uIGluZmxhdGUoc2NvcGUsIG9iaikge1xuICBjb25zdCBwYXJ0cyA9IHNjb3BlLnNwbGl0KCcuJyk7XG4gIGNvbnN0IGZpbmFsID0ge307XG4gIGxldCBjdXJyZW50ID0gZmluYWw7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNhcCA9IGkgPT09IHBhcnRzLmxlbmd0aCAtIDEgPyBvYmogOiB7fTtcbiAgICBjdXJyZW50W3BhcnRzW2ldXSA9IGNhcDtcbiAgICBjdXJyZW50ID0gY2FwO1xuICB9XG5cbiAgcmV0dXJuIGZpbmFsO1xufVxubGV0IGNvdW50ID0gMDtcbmZ1bmN0aW9uIGNvdW50ZXIoKSB7XG4gIGNvdW50Kys7XG4gIHJldHVybiBjb3VudDtcbn1cbmZ1bmN0aW9uIGF2ZXJhZ2UoYXJyKSB7XG4gIGNvbnN0IHN1bSA9IGFyci5yZWR1Y2UoKGFjYywgdmFsKSA9PiB2YWwgKyBhY2MsIDApO1xuICByZXR1cm4gc3VtIC8gYXJyLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGNvbG9yU3RyaW5nVG9WYWxzKGNvbG9yU3RyaW5nKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRDb2xvciA9IGNvbG9yU3RyaW5nLnRvVXBwZXJDYXNlKCkudHJpbSgpOyAvLyBiYXNlZCBvbiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjE2NDg1MDhcblxuICBpZiAoL14jKFtBLUYwLTldezN9KXsxLDJ9JC8udGVzdChub3JtYWxpemVkQ29sb3IpKSB7XG4gICAgbGV0IGhleFBhcnRzID0gbm9ybWFsaXplZENvbG9yLnN1YnN0cmluZygxKS5zcGxpdCgnJyk7XG5cbiAgICBpZiAoaGV4UGFydHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBoZXhQYXJ0cyA9IFtoZXhQYXJ0c1swXSwgaGV4UGFydHNbMF0sIGhleFBhcnRzWzFdLCBoZXhQYXJ0c1sxXSwgaGV4UGFydHNbMl0sIGhleFBhcnRzWzJdXTtcbiAgICB9XG5cbiAgICBjb25zdCBoZXhTdHIgPSBgJHtoZXhQYXJ0cy5qb2luKCcnKX1gO1xuICAgIHJldHVybiB7XG4gICAgICByOiBwYXJzZUludChoZXhTdHIuc2xpY2UoMCwgMiksIDE2KSxcbiAgICAgIGc6IHBhcnNlSW50KGhleFN0ci5zbGljZSgyLCA0KSwgMTYpLFxuICAgICAgYjogcGFyc2VJbnQoaGV4U3RyLnNsaWNlKDQsIDYpLCAxNiksXG4gICAgICBhOiAxXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHJnYk1hdGNoID0gbm9ybWFsaXplZENvbG9yLm1hdGNoKC9eUkdCQT9cXCgoXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKykoPzpcXHMqLFxccyooXFxkKlxcLj9cXGQrKSk/XFwpJC8pO1xuXG4gIGlmIChyZ2JNYXRjaCkge1xuICAgIHJldHVybiB7XG4gICAgICByOiBwYXJzZUludChyZ2JNYXRjaFsxXSwgMTApLFxuICAgICAgZzogcGFyc2VJbnQocmdiTWF0Y2hbMl0sIDEwKSxcbiAgICAgIGI6IHBhcnNlSW50KHJnYk1hdGNoWzNdLCAxMCksXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHRzLW1pZ3JhdGUoMjU1NCkgRklYTUU6IEV4cGVjdGVkIDEgYXJndW1lbnRzLCBidXQgZ290IDIuXG4gICAgICBhOiBwYXJzZUZsb2F0KHJnYk1hdGNoWzRdIHx8IDEsIDEwKVxuICAgIH07XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY29sb3I6ICR7Y29sb3JTdHJpbmd9YCk7XG59XG5jb25zdCB0cmltID0gc3RyaW5nID0+IHN0cmluZy5yZXBsYWNlKC9eXFxzKy8sICcnKS5yZXBsYWNlKC9cXHMrJC8sICcnKTsgLy8gcmV0dXJuIGEgbmV3IGFycmF5LWxpa2Ugb2JqZWN0IHdpdGggaW50IGtleXMgd2hlcmUgZWFjaCBrZXkgaXMgaXRlbVxuLy8gZXg6IG9ialJlcGVhdCh7eDogOH0sIDMpID09PSB7MDoge3g6IDh9LCAxOiB7eDogOH0sIDI6IHt4OiA4fX1cblxuZnVuY3Rpb24gb2JqUmVwZWF0KGl0ZW0sIHRpbWVzKSB7XG4gIGNvbnN0IG9iaiA9IHt9O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZXM7IGkrKykge1xuICAgIG9ialtpXSA9IGl0ZW07XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSAvLyBzaW1pbGFyIHRvIG9ialJlcGVhdCwgYnV0IHRha2VzIGluIGEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGZvciBlYWNoIGluZGV4IGluIHRoZSBvYmplY3RcblxuZnVuY3Rpb24gb2JqUmVwZWF0Q2IodGltZXMsIGNiKSB7XG4gIGNvbnN0IG9iaiA9IHt9O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZXM7IGkrKykge1xuICAgIG9ialtpXSA9IGNiKGkpO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cbmNvbnN0IHVhID0gKChfZ2xvYmFsT2JqJG5hdmlnYXRvciA9IGdsb2JhbE9iai5uYXZpZ2F0b3IpID09PSBudWxsIHx8IF9nbG9iYWxPYmokbmF2aWdhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2xvYmFsT2JqJG5hdmlnYXRvci51c2VyQWdlbnQpIHx8ICcnO1xuY29uc3QgaXNNc0Jyb3dzZXIgPSB1YS5pbmRleE9mKCdNU0lFICcpID4gMCB8fCB1YS5pbmRleE9mKCdUcmlkZW50LycpID4gMCB8fCB1YS5pbmRleE9mKCdFZGdlLycpID4gMDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuXG5jb25zdCBub29wID0gKCkgPT4ge307XG5cbmNsYXNzIFJlbmRlclN0YXRlIHtcbiAgY29uc3RydWN0b3IoY2hhcmFjdGVyLCBvcHRpb25zLCBvblN0YXRlQ2hhbmdlID0gbm9vcCkge1xuICAgIHRoaXMuX211dGF0aW9uQ2hhaW5zID0gW107XG4gICAgdGhpcy5fb25TdGF0ZUNoYW5nZSA9IG9uU3RhdGVDaGFuZ2U7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgZHJhd2luZ0ZhZGVEdXJhdGlvbjogb3B0aW9ucy5kcmF3aW5nRmFkZUR1cmF0aW9uLFxuICAgICAgICBkcmF3aW5nV2lkdGg6IG9wdGlvbnMuZHJhd2luZ1dpZHRoLFxuICAgICAgICBkcmF3aW5nQ29sb3I6IGNvbG9yU3RyaW5nVG9WYWxzKG9wdGlvbnMuZHJhd2luZ0NvbG9yKSxcbiAgICAgICAgc3Ryb2tlQ29sb3I6IGNvbG9yU3RyaW5nVG9WYWxzKG9wdGlvbnMuc3Ryb2tlQ29sb3IpLFxuICAgICAgICBvdXRsaW5lQ29sb3I6IGNvbG9yU3RyaW5nVG9WYWxzKG9wdGlvbnMub3V0bGluZUNvbG9yKSxcbiAgICAgICAgcmFkaWNhbENvbG9yOiBjb2xvclN0cmluZ1RvVmFscyhvcHRpb25zLnJhZGljYWxDb2xvciB8fCBvcHRpb25zLnN0cm9rZUNvbG9yKSxcbiAgICAgICAgaGlnaGxpZ2h0Q29sb3I6IGNvbG9yU3RyaW5nVG9WYWxzKG9wdGlvbnMuaGlnaGxpZ2h0Q29sb3IpXG4gICAgICB9LFxuICAgICAgY2hhcmFjdGVyOiB7XG4gICAgICAgIG1haW46IHtcbiAgICAgICAgICBvcGFjaXR5OiBvcHRpb25zLnNob3dDaGFyYWN0ZXIgPyAxIDogMCxcbiAgICAgICAgICBzdHJva2VzOiB7fVxuICAgICAgICB9LFxuICAgICAgICBvdXRsaW5lOiB7XG4gICAgICAgICAgb3BhY2l0eTogb3B0aW9ucy5zaG93T3V0bGluZSA/IDEgOiAwLFxuICAgICAgICAgIHN0cm9rZXM6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgc3Ryb2tlczoge31cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZXJTdHJva2VzOiBudWxsXG4gICAgfTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcmFjdGVyLnN0cm9rZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuc3RhdGUuY2hhcmFjdGVyLm1haW4uc3Ryb2tlc1tpXSA9IHtcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgZGlzcGxheVBvcnRpb246IDFcbiAgICAgIH07XG4gICAgICB0aGlzLnN0YXRlLmNoYXJhY3Rlci5vdXRsaW5lLnN0cm9rZXNbaV0gPSB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIGRpc3BsYXlQb3J0aW9uOiAxXG4gICAgICB9O1xuICAgICAgdGhpcy5zdGF0ZS5jaGFyYWN0ZXIuaGlnaGxpZ2h0LnN0cm9rZXNbaV0gPSB7XG4gICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgIGRpc3BsYXlQb3J0aW9uOiAxXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIG92ZXJ3cml0ZU9uU3RhdGVDaGFuZ2Uob25TdGF0ZUNoYW5nZSkge1xuICAgIHRoaXMuX29uU3RhdGVDaGFuZ2UgPSBvblN0YXRlQ2hhbmdlO1xuICB9XG5cbiAgdXBkYXRlU3RhdGUoc3RhdGVDaGFuZ2VzKSB7XG4gICAgY29uc3QgbmV4dFN0YXRlID0gY29weUFuZE1lcmdlRGVlcCh0aGlzLnN0YXRlLCBzdGF0ZUNoYW5nZXMpO1xuXG4gICAgdGhpcy5fb25TdGF0ZUNoYW5nZShuZXh0U3RhdGUsIHRoaXMuc3RhdGUpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgfVxuXG4gIHJ1bihtdXRhdGlvbnMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHNjb3BlcyA9IG11dGF0aW9ucy5tYXAobXV0ID0+IG11dC5zY29wZSk7XG4gICAgdGhpcy5jYW5jZWxNdXRhdGlvbnMoc2NvcGVzKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBjb25zdCBtdXRhdGlvbkNoYWluID0ge1xuICAgICAgICBfaXNBY3RpdmU6IHRydWUsXG4gICAgICAgIF9pbmRleDogMCxcbiAgICAgICAgX3Jlc29sdmU6IHJlc29sdmUsXG4gICAgICAgIF9tdXRhdGlvbnM6IG11dGF0aW9ucyxcbiAgICAgICAgX2xvb3A6IG9wdGlvbnMubG9vcCxcbiAgICAgICAgX3Njb3Blczogc2NvcGVzXG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9tdXRhdGlvbkNoYWlucy5wdXNoKG11dGF0aW9uQ2hhaW4pO1xuXG4gICAgICB0aGlzLl9ydW4obXV0YXRpb25DaGFpbik7XG4gICAgfSk7XG4gIH1cblxuICBfcnVuKG11dGF0aW9uQ2hhaW4pIHtcbiAgICBpZiAoIW11dGF0aW9uQ2hhaW4uX2lzQWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbXV0YXRpb25zID0gbXV0YXRpb25DaGFpbi5fbXV0YXRpb25zO1xuXG4gICAgaWYgKG11dGF0aW9uQ2hhaW4uX2luZGV4ID49IG11dGF0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGlmIChtdXRhdGlvbkNoYWluLl9sb29wKSB7XG4gICAgICAgIG11dGF0aW9uQ2hhaW4uX2luZGV4ID0gMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXV0YXRpb25DaGFpbi5faXNBY3RpdmUgPSBmYWxzZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuXG4gICAgICAgIHRoaXMuX211dGF0aW9uQ2hhaW5zID0gdGhpcy5fbXV0YXRpb25DaGFpbnMuZmlsdGVyKGNoYWluID0+IGNoYWluICE9PSBtdXRhdGlvbkNoYWluKTsgLy8gVGhlIGNoYWluIGlzIGRvbmUgLSByZXNvbHZlIHRoZSBwcm9taXNlIHRvIHNpZ25hbCBpdCBmaW5pc2hlZCBzdWNjZXNzZnVsbHlcblxuICAgICAgICBtdXRhdGlvbkNoYWluLl9yZXNvbHZlKHtcbiAgICAgICAgICBjYW5jZWxlZDogZmFsc2VcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGFjdGl2ZU11dGF0aW9uID0gbXV0YXRpb25DaGFpbi5fbXV0YXRpb25zW211dGF0aW9uQ2hhaW4uX2luZGV4XTtcbiAgICBhY3RpdmVNdXRhdGlvbi5ydW4odGhpcykudGhlbigoKSA9PiB7XG4gICAgICBpZiAobXV0YXRpb25DaGFpbi5faXNBY3RpdmUpIHtcbiAgICAgICAgbXV0YXRpb25DaGFpbi5faW5kZXgrKzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuXG4gICAgICAgIHRoaXMuX3J1bihtdXRhdGlvbkNoYWluKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9nZXRBY3RpdmVNdXRhdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX211dGF0aW9uQ2hhaW5zLm1hcChjaGFpbiA9PiBjaGFpbi5fbXV0YXRpb25zW2NoYWluLl9pbmRleF0pO1xuICB9XG5cbiAgcGF1c2VBbGwoKSB7XG4gICAgdGhpcy5fZ2V0QWN0aXZlTXV0YXRpb25zKCkuZm9yRWFjaChtdXRhdGlvbiA9PiBtdXRhdGlvbi5wYXVzZSgpKTtcbiAgfVxuXG4gIHJlc3VtZUFsbCgpIHtcbiAgICB0aGlzLl9nZXRBY3RpdmVNdXRhdGlvbnMoKS5mb3JFYWNoKG11dGF0aW9uID0+IG11dGF0aW9uLnJlc3VtZSgpKTtcbiAgfVxuXG4gIGNhbmNlbE11dGF0aW9ucyhzY29wZXNUb0NhbmNlbCkge1xuICAgIGZvciAoY29uc3QgY2hhaW4gb2YgdGhpcy5fbXV0YXRpb25DaGFpbnMpIHtcbiAgICAgIGZvciAoY29uc3QgY2hhaW5JZCBvZiBjaGFpbi5fc2NvcGVzKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc2NvcGVUb0NhbmNlbCBvZiBzY29wZXNUb0NhbmNlbCkge1xuICAgICAgICAgIGlmIChjaGFpbklkLnN0YXJ0c1dpdGgoc2NvcGVUb0NhbmNlbCkgfHwgc2NvcGVUb0NhbmNlbC5zdGFydHNXaXRoKGNoYWluSWQpKSB7XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxNdXRhdGlvbkNoYWluKGNoYWluKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjYW5jZWxBbGwoKSB7XG4gICAgdGhpcy5jYW5jZWxNdXRhdGlvbnMoWycnXSk7XG4gIH1cblxuICBfY2FuY2VsTXV0YXRpb25DaGFpbihtdXRhdGlvbkNoYWluKSB7XG4gICAgdmFyIF9tdXRhdGlvbkNoYWluJF9yZXNvbDtcblxuICAgIG11dGF0aW9uQ2hhaW4uX2lzQWN0aXZlID0gZmFsc2U7XG5cbiAgICBmb3IgKGxldCBpID0gbXV0YXRpb25DaGFpbi5faW5kZXg7IGkgPCBtdXRhdGlvbkNoYWluLl9tdXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG11dGF0aW9uQ2hhaW4uX211dGF0aW9uc1tpXS5jYW5jZWwodGhpcyk7XG4gICAgfVxuXG4gICAgKF9tdXRhdGlvbkNoYWluJF9yZXNvbCA9IG11dGF0aW9uQ2hhaW4uX3Jlc29sdmUpID09PSBudWxsIHx8IF9tdXRhdGlvbkNoYWluJF9yZXNvbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX211dGF0aW9uQ2hhaW4kX3Jlc29sLmNhbGwobXV0YXRpb25DaGFpbiwge1xuICAgICAgY2FuY2VsZWQ6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLl9tdXRhdGlvbkNoYWlucyA9IHRoaXMuX211dGF0aW9uQ2hhaW5zLmZpbHRlcihjaGFpbiA9PiBjaGFpbiAhPT0gbXV0YXRpb25DaGFpbik7XG4gIH1cblxufVxuXG5jb25zdCBzdWJ0cmFjdCA9IChwMSwgcDIpID0+ICh7XG4gIHg6IHAxLnggLSBwMi54LFxuICB5OiBwMS55IC0gcDIueVxufSk7XG5jb25zdCBtYWduaXR1ZGUgPSBwb2ludCA9PiBNYXRoLnNxcnQoTWF0aC5wb3cocG9pbnQueCwgMikgKyBNYXRoLnBvdyhwb2ludC55LCAyKSk7XG5jb25zdCBkaXN0YW5jZSA9IChwb2ludDEsIHBvaW50MikgPT4gbWFnbml0dWRlKHN1YnRyYWN0KHBvaW50MSwgcG9pbnQyKSk7XG5jb25zdCBlcXVhbHMgPSAocG9pbnQxLCBwb2ludDIpID0+IHBvaW50MS54ID09PSBwb2ludDIueCAmJiBwb2ludDEueSA9PT0gcG9pbnQyLnk7XG5jb25zdCByb3VuZCA9IChwb2ludCwgcHJlY2lzaW9uID0gMSkgPT4ge1xuICBjb25zdCBtdWx0aXBsaWVyID0gcHJlY2lzaW9uICogMTA7XG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5yb3VuZChtdWx0aXBsaWVyICogcG9pbnQueCkgLyBtdWx0aXBsaWVyLFxuICAgIHk6IE1hdGgucm91bmQobXVsdGlwbGllciAqIHBvaW50LnkpIC8gbXVsdGlwbGllclxuICB9O1xufTtcbmNvbnN0IGxlbmd0aCA9IHBvaW50cyA9PiB7XG4gIGxldCBsYXN0UG9pbnQgPSBwb2ludHNbMF07XG4gIGNvbnN0IHBvaW50c1NhbnNGaXJzdCA9IHBvaW50cy5zbGljZSgxKTtcbiAgcmV0dXJuIHBvaW50c1NhbnNGaXJzdC5yZWR1Y2UoKGFjYywgcG9pbnQpID0+IHtcbiAgICBjb25zdCBkaXN0ID0gZGlzdGFuY2UocG9pbnQsIGxhc3RQb2ludCk7XG4gICAgbGFzdFBvaW50ID0gcG9pbnQ7XG4gICAgcmV0dXJuIGFjYyArIGRpc3Q7XG4gIH0sIDApO1xufTtcbmNvbnN0IGNvc2luZVNpbWlsYXJpdHkgPSAocG9pbnQxLCBwb2ludDIpID0+IHtcbiAgY29uc3QgcmF3RG90UHJvZHVjdCA9IHBvaW50MS54ICogcG9pbnQyLnggKyBwb2ludDEueSAqIHBvaW50Mi55O1xuICByZXR1cm4gcmF3RG90UHJvZHVjdCAvIG1hZ25pdHVkZShwb2ludDEpIC8gbWFnbml0dWRlKHBvaW50Mik7XG59O1xuLyoqXG4gKiByZXR1cm4gYSBuZXcgcG9pbnQsIHAzLCB3aGljaCBpcyBvbiB0aGUgc2FtZSBsaW5lIGFzIHAxIGFuZCBwMiwgYnV0IGRpc3RhbmNlIGF3YXlcbiAqIGZyb20gcDIuIHAxLCBwMiwgcDMgd2lsbCBhbHdheXMgbGllIG9uIHRoZSBsaW5lIGluIHRoYXQgb3JkZXJcbiAqL1xuXG5jb25zdCBfZXh0ZW5kUG9pbnRPbkxpbmUgPSAocDEsIHAyLCBkaXN0KSA9PiB7XG4gIGNvbnN0IHZlY3QgPSBzdWJ0cmFjdChwMiwgcDEpO1xuICBjb25zdCBub3JtID0gZGlzdCAvIG1hZ25pdHVkZSh2ZWN0KTtcbiAgcmV0dXJuIHtcbiAgICB4OiBwMi54ICsgbm9ybSAqIHZlY3QueCxcbiAgICB5OiBwMi55ICsgbm9ybSAqIHZlY3QueVxuICB9O1xufTtcbi8qKiBiYXNlZCBvbiBodHRwOi8vd3d3LmtyLnR1d2llbi5hYy5hdC9zdGFmZi9laXRlci9ldC1hcmNoaXZlL2NkdHI5NDY0LnBkZiAqL1xuXG5jb25zdCBmcmVjaGV0RGlzdCA9IChjdXJ2ZTEsIGN1cnZlMikgPT4ge1xuICBjb25zdCBsb25nQ3VydmUgPSBjdXJ2ZTEubGVuZ3RoID49IGN1cnZlMi5sZW5ndGggPyBjdXJ2ZTEgOiBjdXJ2ZTI7XG4gIGNvbnN0IHNob3J0Q3VydmUgPSBjdXJ2ZTEubGVuZ3RoID49IGN1cnZlMi5sZW5ndGggPyBjdXJ2ZTIgOiBjdXJ2ZTE7XG5cbiAgY29uc3QgY2FsY1ZhbCA9IChpLCBqLCBwcmV2UmVzdWx0c0NvbCwgY3VyUmVzdWx0c0NvbCkgPT4ge1xuICAgIGlmIChpID09PSAwICYmIGogPT09IDApIHtcbiAgICAgIHJldHVybiBkaXN0YW5jZShsb25nQ3VydmVbMF0sIHNob3J0Q3VydmVbMF0pO1xuICAgIH1cblxuICAgIGlmIChpID4gMCAmJiBqID09PSAwKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgocHJldlJlc3VsdHNDb2xbMF0sIGRpc3RhbmNlKGxvbmdDdXJ2ZVtpXSwgc2hvcnRDdXJ2ZVswXSkpO1xuICAgIH1cblxuICAgIGNvbnN0IGxhc3RSZXN1bHQgPSBjdXJSZXN1bHRzQ29sW2N1clJlc3VsdHNDb2wubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoaSA9PT0gMCAmJiBqID4gMCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KGxhc3RSZXN1bHQsIGRpc3RhbmNlKGxvbmdDdXJ2ZVswXSwgc2hvcnRDdXJ2ZVtqXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihwcmV2UmVzdWx0c0NvbFtqXSwgcHJldlJlc3VsdHNDb2xbaiAtIDFdLCBsYXN0UmVzdWx0KSwgZGlzdGFuY2UobG9uZ0N1cnZlW2ldLCBzaG9ydEN1cnZlW2pdKSk7XG4gIH07XG5cbiAgbGV0IHByZXZSZXN1bHRzQ29sID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb25nQ3VydmUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjdXJSZXN1bHRzQ29sID0gW107XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNob3J0Q3VydmUubGVuZ3RoOyBqKyspIHtcbiAgICAgIC8vIHdlIG9ubHkgbmVlZCB0aGUgcmVzdWx0cyBmcm9tIGkgLSAxIGFuZCBqIC0gMSB0byBjb250aW51ZSB0aGUgY2FsY3VsYXRpb25cbiAgICAgIC8vIHNvIHdlIG9ubHkgbmVlZCB0byBob2xkIG9udG8gdGhlIGxhc3QgY29sdW1uIG9mIGNhbGN1bGF0ZWQgcmVzdWx0c1xuICAgICAgLy8gcHJldlJlc3VsdHNDb2wgaXMgcmVzdWx0c1tpLTFdWzpdIGluIHRoZSBvcmlnaW5hbCBhbGdvcml0aG1cbiAgICAgIC8vIGN1clJlc3VsdHNDb2wgaXMgcmVzdWx0c1tpXVs6ai0xXSBpbiB0aGUgb3JpZ2luYWwgYWxnb3JpdGhtXG4gICAgICBjdXJSZXN1bHRzQ29sLnB1c2goY2FsY1ZhbChpLCBqLCBwcmV2UmVzdWx0c0NvbCwgY3VyUmVzdWx0c0NvbCkpO1xuICAgIH1cblxuICAgIHByZXZSZXN1bHRzQ29sID0gY3VyUmVzdWx0c0NvbDtcbiAgfVxuXG4gIHJldHVybiBwcmV2UmVzdWx0c0NvbFtzaG9ydEN1cnZlLmxlbmd0aCAtIDFdO1xufTtcbi8qKiBicmVhayB1cCBsb25nIHNlZ21lbnRzIGluIHRoZSBjdXJ2ZSBpbnRvIHNtYWxsZXIgc2VnbWVudHMgb2YgbGVuIG1heExlbiBvciBzbWFsbGVyICovXG5cbmNvbnN0IHN1YmRpdmlkZUN1cnZlID0gKGN1cnZlLCBtYXhMZW4gPSAwLjA1KSA9PiB7XG4gIGNvbnN0IG5ld0N1cnZlID0gY3VydmUuc2xpY2UoMCwgMSk7XG5cbiAgZm9yIChjb25zdCBwb2ludCBvZiBjdXJ2ZS5zbGljZSgxKSkge1xuICAgIGNvbnN0IHByZXZQb2ludCA9IG5ld0N1cnZlW25ld0N1cnZlLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHNlZ0xlbiA9IGRpc3RhbmNlKHBvaW50LCBwcmV2UG9pbnQpO1xuXG4gICAgaWYgKHNlZ0xlbiA+IG1heExlbikge1xuICAgICAgY29uc3QgbnVtTmV3UG9pbnRzID0gTWF0aC5jZWlsKHNlZ0xlbiAvIG1heExlbik7XG4gICAgICBjb25zdCBuZXdTZWdMZW4gPSBzZWdMZW4gLyBudW1OZXdQb2ludHM7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtTmV3UG9pbnRzOyBpKyspIHtcbiAgICAgICAgbmV3Q3VydmUucHVzaChfZXh0ZW5kUG9pbnRPbkxpbmUocG9pbnQsIHByZXZQb2ludCwgLTEgKiBuZXdTZWdMZW4gKiAoaSArIDEpKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0N1cnZlLnB1c2gocG9pbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdDdXJ2ZTtcbn07XG4vKiogcmVkcmF3IHRoZSBjdXJ2ZSB1c2luZyBudW1Qb2ludHMgZXF1YWxseSBzcGFjZWQgb3V0IGFsb25nIHRoZSBsZW5ndGggb2YgdGhlIGN1cnZlICovXG5cbmNvbnN0IG91dGxpbmVDdXJ2ZSA9IChjdXJ2ZSwgbnVtUG9pbnRzID0gMzApID0+IHtcbiAgY29uc3QgY3VydmVMZW4gPSBsZW5ndGgoY3VydmUpO1xuICBjb25zdCBzZWdtZW50TGVuID0gY3VydmVMZW4gLyAobnVtUG9pbnRzIC0gMSk7XG4gIGNvbnN0IG91dGxpbmVQb2ludHMgPSBbY3VydmVbMF1dO1xuICBjb25zdCBlbmRQb2ludCA9IGFyckxhc3QoY3VydmUpO1xuICBjb25zdCByZW1haW5pbmdDdXJ2ZVBvaW50cyA9IGN1cnZlLnNsaWNlKDEpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUG9pbnRzIC0gMjsgaSsrKSB7XG4gICAgbGV0IGxhc3RQb2ludCA9IGFyckxhc3Qob3V0bGluZVBvaW50cyk7XG4gICAgbGV0IHJlbWFpbmluZ0Rpc3QgPSBzZWdtZW50TGVuO1xuICAgIGxldCBvdXRsaW5lUG9pbnRGb3VuZCA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKCFvdXRsaW5lUG9pbnRGb3VuZCkge1xuICAgICAgY29uc3QgbmV4dFBvaW50RGlzdCA9IGRpc3RhbmNlKGxhc3RQb2ludCwgcmVtYWluaW5nQ3VydmVQb2ludHNbMF0pO1xuXG4gICAgICBpZiAobmV4dFBvaW50RGlzdCA8IHJlbWFpbmluZ0Rpc3QpIHtcbiAgICAgICAgcmVtYWluaW5nRGlzdCAtPSBuZXh0UG9pbnREaXN0O1xuICAgICAgICBsYXN0UG9pbnQgPSByZW1haW5pbmdDdXJ2ZVBvaW50cy5zaGlmdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbmV4dFBvaW50ID0gX2V4dGVuZFBvaW50T25MaW5lKGxhc3RQb2ludCwgcmVtYWluaW5nQ3VydmVQb2ludHNbMF0sIHJlbWFpbmluZ0Rpc3QgLSBuZXh0UG9pbnREaXN0KTtcblxuICAgICAgICBvdXRsaW5lUG9pbnRzLnB1c2gobmV4dFBvaW50KTtcbiAgICAgICAgb3V0bGluZVBvaW50Rm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG91dGxpbmVQb2ludHMucHVzaChlbmRQb2ludCk7XG4gIHJldHVybiBvdXRsaW5lUG9pbnRzO1xufTtcbi8qKiB0cmFuc2xhdGUgYW5kIHNjYWxlIGZyb20gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUHJvY3J1c3Rlc19hbmFseXNpcyAqL1xuXG5jb25zdCBub3JtYWxpemVDdXJ2ZSA9IGN1cnZlID0+IHtcbiAgY29uc3Qgb3V0bGluZWRDdXJ2ZSA9IG91dGxpbmVDdXJ2ZShjdXJ2ZSk7XG4gIGNvbnN0IG1lYW5YID0gYXZlcmFnZShvdXRsaW5lZEN1cnZlLm1hcChwb2ludCA9PiBwb2ludC54KSk7XG4gIGNvbnN0IG1lYW5ZID0gYXZlcmFnZShvdXRsaW5lZEN1cnZlLm1hcChwb2ludCA9PiBwb2ludC55KSk7XG4gIGNvbnN0IG1lYW4gPSB7XG4gICAgeDogbWVhblgsXG4gICAgeTogbWVhbllcbiAgfTtcbiAgY29uc3QgdHJhbnNsYXRlZEN1cnZlID0gb3V0bGluZWRDdXJ2ZS5tYXAocG9pbnQgPT4gc3VidHJhY3QocG9pbnQsIG1lYW4pKTtcbiAgY29uc3Qgc2NhbGUgPSBNYXRoLnNxcnQoYXZlcmFnZShbTWF0aC5wb3codHJhbnNsYXRlZEN1cnZlWzBdLngsIDIpICsgTWF0aC5wb3codHJhbnNsYXRlZEN1cnZlWzBdLnksIDIpLCBNYXRoLnBvdyhhcnJMYXN0KHRyYW5zbGF0ZWRDdXJ2ZSkueCwgMikgKyBNYXRoLnBvdyhhcnJMYXN0KHRyYW5zbGF0ZWRDdXJ2ZSkueSwgMildKSk7XG4gIGNvbnN0IHNjYWxlZEN1cnZlID0gdHJhbnNsYXRlZEN1cnZlLm1hcChwb2ludCA9PiAoe1xuICAgIHg6IHBvaW50LnggLyBzY2FsZSxcbiAgICB5OiBwb2ludC55IC8gc2NhbGVcbiAgfSkpO1xuICByZXR1cm4gc3ViZGl2aWRlQ3VydmUoc2NhbGVkQ3VydmUpO1xufTsgLy8gcm90YXRlIGFyb3VuZCB0aGUgb3JpZ2luXG5cbmNvbnN0IHJvdGF0ZSA9IChjdXJ2ZSwgdGhldGEpID0+IHtcbiAgcmV0dXJuIGN1cnZlLm1hcChwb2ludCA9PiAoe1xuICAgIHg6IE1hdGguY29zKHRoZXRhKSAqIHBvaW50LnggLSBNYXRoLnNpbih0aGV0YSkgKiBwb2ludC55LFxuICAgIHk6IE1hdGguc2luKHRoZXRhKSAqIHBvaW50LnggKyBNYXRoLmNvcyh0aGV0YSkgKiBwb2ludC55XG4gIH0pKTtcbn07IC8vIHJlbW92ZSBpbnRlcm1lZGlhdGUgcG9pbnRzIHRoYXQgYXJlIG9uIHRoZSBzYW1lIGxpbmUgYXMgdGhlIHBvaW50cyB0byBlaXRoZXIgc2lkZVxuXG5jb25zdCBfZmlsdGVyUGFyYWxsZWxQb2ludHMgPSBwb2ludHMgPT4ge1xuICBpZiAocG9pbnRzLmxlbmd0aCA8IDMpIHJldHVybiBwb2ludHM7XG4gIGNvbnN0IGZpbHRlcmVkUG9pbnRzID0gW3BvaW50c1swXSwgcG9pbnRzWzFdXTtcbiAgcG9pbnRzLnNsaWNlKDIpLmZvckVhY2gocG9pbnQgPT4ge1xuICAgIGNvbnN0IG51bUZpbHRlcmVkUG9pbnRzID0gZmlsdGVyZWRQb2ludHMubGVuZ3RoO1xuICAgIGNvbnN0IGN1clZlY3QgPSBzdWJ0cmFjdChwb2ludCwgZmlsdGVyZWRQb2ludHNbbnVtRmlsdGVyZWRQb2ludHMgLSAxXSk7XG4gICAgY29uc3QgcHJldlZlY3QgPSBzdWJ0cmFjdChmaWx0ZXJlZFBvaW50c1tudW1GaWx0ZXJlZFBvaW50cyAtIDFdLCBmaWx0ZXJlZFBvaW50c1tudW1GaWx0ZXJlZFBvaW50cyAtIDJdKTsgLy8gdGhpcyBpcyB0aGUgeiBjb29yZCBvZiB0aGUgY3Jvc3MtcHJvZHVjdC4gSWYgdGhpcyBpcyAwIHRoZW4gdGhleSdyZSBwYXJhbGxlbFxuXG4gICAgY29uc3QgaXNQYXJhbGxlbCA9IGN1clZlY3QueSAqIHByZXZWZWN0LnggLSBjdXJWZWN0LnggKiBwcmV2VmVjdC55ID09PSAwO1xuXG4gICAgaWYgKGlzUGFyYWxsZWwpIHtcbiAgICAgIGZpbHRlcmVkUG9pbnRzLnBvcCgpO1xuICAgIH1cblxuICAgIGZpbHRlcmVkUG9pbnRzLnB1c2gocG9pbnQpO1xuICB9KTtcbiAgcmV0dXJuIGZpbHRlcmVkUG9pbnRzO1xufTtcbmZ1bmN0aW9uIGdldFBhdGhTdHJpbmcocG9pbnRzLCBjbG9zZSA9IGZhbHNlKSB7XG4gIGNvbnN0IHN0YXJ0ID0gcm91bmQocG9pbnRzWzBdKTtcbiAgY29uc3QgcmVtYWluaW5nUG9pbnRzID0gcG9pbnRzLnNsaWNlKDEpO1xuICBsZXQgcGF0aFN0cmluZyA9IGBNICR7c3RhcnQueH0gJHtzdGFydC55fWA7XG4gIHJlbWFpbmluZ1BvaW50cy5mb3JFYWNoKHBvaW50ID0+IHtcbiAgICBjb25zdCByb3VuZGVkUG9pbnQgPSByb3VuZChwb2ludCk7XG4gICAgcGF0aFN0cmluZyArPSBgIEwgJHtyb3VuZGVkUG9pbnQueH0gJHtyb3VuZGVkUG9pbnQueX1gO1xuICB9KTtcblxuICBpZiAoY2xvc2UpIHtcbiAgICBwYXRoU3RyaW5nICs9ICdaJztcbiAgfVxuXG4gIHJldHVybiBwYXRoU3RyaW5nO1xufVxuLyoqIHRha2UgcG9pbnRzIG9uIGEgcGF0aCBhbmQgbW92ZSB0aGVpciBzdGFydCBwb2ludCBiYWNrd2FyZHMgYnkgZGlzdGFuY2UgKi9cblxuY29uc3QgZXh0ZW5kU3RhcnQgPSAocG9pbnRzLCBkaXN0KSA9PiB7XG4gIGNvbnN0IGZpbHRlcmVkUG9pbnRzID0gX2ZpbHRlclBhcmFsbGVsUG9pbnRzKHBvaW50cyk7XG5cbiAgaWYgKGZpbHRlcmVkUG9pbnRzLmxlbmd0aCA8IDIpIHJldHVybiBmaWx0ZXJlZFBvaW50cztcbiAgY29uc3QgcDEgPSBmaWx0ZXJlZFBvaW50c1sxXTtcbiAgY29uc3QgcDIgPSBmaWx0ZXJlZFBvaW50c1swXTtcblxuICBjb25zdCBuZXdTdGFydCA9IF9leHRlbmRQb2ludE9uTGluZShwMSwgcDIsIGRpc3QpO1xuXG4gIGNvbnN0IGV4dGVuZGVkUG9pbnRzID0gZmlsdGVyZWRQb2ludHMuc2xpY2UoMSk7XG4gIGV4dGVuZGVkUG9pbnRzLnVuc2hpZnQobmV3U3RhcnQpO1xuICByZXR1cm4gZXh0ZW5kZWRQb2ludHM7XG59O1xuXG5jbGFzcyBTdHJva2Uge1xuICBjb25zdHJ1Y3RvcihwYXRoLCBwb2ludHMsIHN0cm9rZU51bSwgaXNJblJhZGljYWwgPSBmYWxzZSkge1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5wb2ludHMgPSBwb2ludHM7XG4gICAgdGhpcy5zdHJva2VOdW0gPSBzdHJva2VOdW07XG4gICAgdGhpcy5pc0luUmFkaWNhbCA9IGlzSW5SYWRpY2FsO1xuICB9XG5cbiAgZ2V0U3RhcnRpbmdQb2ludCgpIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludHNbMF07XG4gIH1cblxuICBnZXRFbmRpbmdQb2ludCgpIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludHNbdGhpcy5wb2ludHMubGVuZ3RoIC0gMV07XG4gIH1cblxuICBnZXRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIGxlbmd0aCh0aGlzLnBvaW50cyk7XG4gIH1cblxuICBnZXRWZWN0b3JzKCkge1xuICAgIGxldCBsYXN0UG9pbnQgPSB0aGlzLnBvaW50c1swXTtcbiAgICBjb25zdCBwb2ludHNTYW5zRmlyc3QgPSB0aGlzLnBvaW50cy5zbGljZSgxKTtcbiAgICByZXR1cm4gcG9pbnRzU2Fuc0ZpcnN0Lm1hcChwb2ludCA9PiB7XG4gICAgICBjb25zdCB2ZWN0b3IgPSBzdWJ0cmFjdChwb2ludCwgbGFzdFBvaW50KTtcbiAgICAgIGxhc3RQb2ludCA9IHBvaW50O1xuICAgICAgcmV0dXJuIHZlY3RvcjtcbiAgICB9KTtcbiAgfVxuXG4gIGdldERpc3RhbmNlKHBvaW50KSB7XG4gICAgY29uc3QgZGlzdGFuY2VzID0gdGhpcy5wb2ludHMubWFwKHN0cm9rZVBvaW50ID0+IGRpc3RhbmNlKHN0cm9rZVBvaW50LCBwb2ludCkpO1xuICAgIHJldHVybiBNYXRoLm1pbiguLi5kaXN0YW5jZXMpO1xuICB9XG5cbiAgZ2V0QXZlcmFnZURpc3RhbmNlKHBvaW50cykge1xuICAgIGNvbnN0IHRvdGFsRGlzdCA9IHBvaW50cy5yZWR1Y2UoKGFjYywgcG9pbnQpID0+IGFjYyArIHRoaXMuZ2V0RGlzdGFuY2UocG9pbnQpLCAwKTtcbiAgICByZXR1cm4gdG90YWxEaXN0IC8gcG9pbnRzLmxlbmd0aDtcbiAgfVxuXG59XG5cbmNsYXNzIENoYXJhY3RlciB7XG4gIGNvbnN0cnVjdG9yKHN5bWJvbCwgc3Ryb2tlcykge1xuICAgIHRoaXMuc3ltYm9sID0gc3ltYm9sO1xuICAgIHRoaXMuc3Ryb2tlcyA9IHN0cm9rZXM7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVN0cm9rZXMoe1xuICByYWRTdHJva2VzLFxuICBzdHJva2VzLFxuICBtZWRpYW5zXG59KSB7XG4gIGNvbnN0IGlzSW5SYWRpY2FsID0gc3Ryb2tlTnVtID0+IHtcbiAgICB2YXIgX3JhZFN0cm9rZXMkaW5kZXhPZjtcblxuICAgIHJldHVybiAoKF9yYWRTdHJva2VzJGluZGV4T2YgPSByYWRTdHJva2VzID09PSBudWxsIHx8IHJhZFN0cm9rZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJhZFN0cm9rZXMuaW5kZXhPZihzdHJva2VOdW0pKSAhPT0gbnVsbCAmJiBfcmFkU3Ryb2tlcyRpbmRleE9mICE9PSB2b2lkIDAgPyBfcmFkU3Ryb2tlcyRpbmRleE9mIDogLTEpID49IDA7XG4gIH07XG5cbiAgcmV0dXJuIHN0cm9rZXMubWFwKChwYXRoLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHBvaW50cyA9IG1lZGlhbnNbaW5kZXhdLm1hcChwb2ludERhdGEgPT4ge1xuICAgICAgY29uc3QgW3gsIHldID0gcG9pbnREYXRhO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFN0cm9rZShwYXRoLCBwb2ludHMsIGluZGV4LCBpc0luUmFkaWNhbChpbmRleCkpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VDaGFyRGF0YShzeW1ib2wsIGNoYXJKc29uKSB7XG4gIGNvbnN0IHN0cm9rZXMgPSBnZW5lcmF0ZVN0cm9rZXMoY2hhckpzb24pO1xuICByZXR1cm4gbmV3IENoYXJhY3RlcihzeW1ib2wsIHN0cm9rZXMpO1xufVxuXG4vLyBBbGwgbWFrZW1lYWhhbnppIGNoYXJhY3RlcnMgaGF2ZSB0aGUgc2FtZSBib3VuZGluZyBib3hcbmNvbnN0IENIQVJBQ1RFUl9CT1VORFMgPSBbe1xuICB4OiAwLFxuICB5OiAtMTI0XG59LCB7XG4gIHg6IDEwMjQsXG4gIHk6IDkwMFxufV07XG5jb25zdCBbZnJvbSwgdG9dID0gQ0hBUkFDVEVSX0JPVU5EUztcbmNvbnN0IHByZVNjYWxlZFdpZHRoID0gdG8ueCAtIGZyb20ueDtcbmNvbnN0IHByZVNjYWxlZEhlaWdodCA9IHRvLnkgLSBmcm9tLnk7XG5jbGFzcyBQb3NpdGlvbmVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZGRpbmcsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBvcHRpb25zO1xuICAgIHRoaXMucGFkZGluZyA9IHBhZGRpbmc7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGNvbnN0IGVmZmVjdGl2ZVdpZHRoID0gd2lkdGggLSAyICogcGFkZGluZztcbiAgICBjb25zdCBlZmZlY3RpdmVIZWlnaHQgPSBoZWlnaHQgLSAyICogcGFkZGluZztcbiAgICBjb25zdCBzY2FsZVggPSBlZmZlY3RpdmVXaWR0aCAvIHByZVNjYWxlZFdpZHRoO1xuICAgIGNvbnN0IHNjYWxlWSA9IGVmZmVjdGl2ZUhlaWdodCAvIHByZVNjYWxlZEhlaWdodDtcbiAgICB0aGlzLnNjYWxlID0gTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpO1xuICAgIGNvbnN0IHhDZW50ZXJpbmdCdWZmZXIgPSBwYWRkaW5nICsgKGVmZmVjdGl2ZVdpZHRoIC0gdGhpcy5zY2FsZSAqIHByZVNjYWxlZFdpZHRoKSAvIDI7XG4gICAgY29uc3QgeUNlbnRlcmluZ0J1ZmZlciA9IHBhZGRpbmcgKyAoZWZmZWN0aXZlSGVpZ2h0IC0gdGhpcy5zY2FsZSAqIHByZVNjYWxlZEhlaWdodCkgLyAyO1xuICAgIHRoaXMueE9mZnNldCA9IC0xICogZnJvbS54ICogdGhpcy5zY2FsZSArIHhDZW50ZXJpbmdCdWZmZXI7XG4gICAgdGhpcy55T2Zmc2V0ID0gLTEgKiBmcm9tLnkgKiB0aGlzLnNjYWxlICsgeUNlbnRlcmluZ0J1ZmZlcjtcbiAgfVxuXG4gIGNvbnZlcnRFeHRlcm5hbFBvaW50KHBvaW50KSB7XG4gICAgY29uc3QgeCA9IChwb2ludC54IC0gdGhpcy54T2Zmc2V0KSAvIHRoaXMuc2NhbGU7XG4gICAgY29uc3QgeSA9ICh0aGlzLmhlaWdodCAtIHRoaXMueU9mZnNldCAtIHBvaW50LnkpIC8gdGhpcy5zY2FsZTtcbiAgICByZXR1cm4ge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICB9XG5cbn1cblxuY29uc3QgQ09TSU5FX1NJTUlMQVJJVFlfVEhSRVNIT0xEID0gMDsgLy8gLTEgdG8gMSwgc21hbGxlciA9IG1vcmUgbGVuaWVudFxuXG5jb25zdCBTVEFSVF9BTkRfRU5EX0RJU1RfVEhSRVNIT0xEID0gMjUwOyAvLyBiaWdnZXIgPSBtb3JlIGxlbmllbnRcblxuY29uc3QgRlJFQ0hFVF9USFJFU0hPTEQgPSAwLjQ7IC8vIGJpZ2dlciA9IG1vcmUgbGVuaWVudFxuXG5jb25zdCBNSU5fTEVOX1RIUkVTSE9MRCA9IDAuMzU7IC8vIHNtYWxsZXIgPSBtb3JlIGxlbmllbnRcblxuZnVuY3Rpb24gc3Ryb2tlTWF0Y2hlcyh1c2VyU3Ryb2tlLCBjaGFyYWN0ZXIsIHN0cm9rZU51bSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHN0cm9rZXMgPSBjaGFyYWN0ZXIuc3Ryb2tlcztcbiAgY29uc3QgcG9pbnRzID0gc3RyaXBEdXBsaWNhdGVzKHVzZXJTdHJva2UucG9pbnRzKTtcblxuICBpZiAocG9pbnRzLmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaDogZmFsc2UsXG4gICAgICBtZXRhOiB7XG4gICAgICAgIGlzU3Ryb2tlQmFja3dhcmRzOiBmYWxzZVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBjb25zdCB7XG4gICAgaXNNYXRjaCxcbiAgICBtZXRhLFxuICAgIGF2Z0Rpc3RcbiAgfSA9IGdldE1hdGNoRGF0YShwb2ludHMsIHN0cm9rZXNbc3Ryb2tlTnVtXSwgb3B0aW9ucyk7XG5cbiAgaWYgKCFpc01hdGNoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBtZXRhXG4gICAgfTtcbiAgfSAvLyBpZiB0aGVyZSBpcyBhIGJldHRlciBtYXRjaCBhbW9uZyBzdHJva2VzIHRoZSB1c2VyIGhhc24ndCBkcmF3biB5ZXQsIHRoZSB1c2VyIHByb2JhYmx5IGRyZXcgdGhlIHdyb25nIHN0cm9rZVxuXG5cbiAgY29uc3QgbGF0ZXJTdHJva2VzID0gc3Ryb2tlcy5zbGljZShzdHJva2VOdW0gKyAxKTtcbiAgbGV0IGNsb3Nlc3RNYXRjaERpc3QgPSBhdmdEaXN0O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGF0ZXJTdHJva2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIGF2Z0Rpc3RcbiAgICB9ID0gZ2V0TWF0Y2hEYXRhKHBvaW50cywgbGF0ZXJTdHJva2VzW2ldLCB7IC4uLm9wdGlvbnMsXG4gICAgICBjaGVja0JhY2t3YXJkczogZmFsc2VcbiAgICB9KTtcblxuICAgIGlmIChpc01hdGNoICYmIGF2Z0Rpc3QgPCBjbG9zZXN0TWF0Y2hEaXN0KSB7XG4gICAgICBjbG9zZXN0TWF0Y2hEaXN0ID0gYXZnRGlzdDtcbiAgICB9XG4gIH0gLy8gaWYgdGhlcmUncyBhIGJldHRlciBtYXRjaCwgcmF0aGVyIHRoYXQgcmV0dXJuaW5nIGZhbHNlIGF1dG9tYXRpY2FsbHksIHRyeSByZWR1Y2luZyBsZW5pZW5jeSBpbnN0ZWFkXG4gIC8vIGlmIGxlbmllbmN5IGlzIGFscmVhZHkgcmVhbGx5IGhpZ2ggd2UgY2FuIGFsbG93IHNvbWUgc2ltaWxhciBzdHJva2VzIHRvIHBhc3NcblxuXG4gIGlmIChjbG9zZXN0TWF0Y2hEaXN0IDwgYXZnRGlzdCkge1xuICAgIC8vIGFkanVzdCBsZW5pZW5jeSBiZXR3ZWVuIDAuMyBhbmQgMC42IGRlcGVuZGluZyBvbiBob3cgbXVjaCBvZiBhIGJldHRlciBtYXRjaCB0aGUgbmV3IG1hdGNoIGlzXG4gICAgY29uc3QgbGVuaWVuY3lBZGp1c3RtZW50ID0gMC42ICogKGNsb3Nlc3RNYXRjaERpc3QgKyBhdmdEaXN0KSAvICgyICogYXZnRGlzdCk7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIG1ldGFcbiAgICB9ID0gZ2V0TWF0Y2hEYXRhKHBvaW50cywgc3Ryb2tlc1tzdHJva2VOdW1dLCB7IC4uLm9wdGlvbnMsXG4gICAgICBsZW5pZW5jeTogKG9wdGlvbnMubGVuaWVuY3kgfHwgMSkgKiBsZW5pZW5jeUFkanVzdG1lbnRcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIG1ldGFcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpc01hdGNoLFxuICAgIG1ldGFcbiAgfTtcbn1cblxuY29uc3Qgc3RhcnRBbmRFbmRNYXRjaGVzID0gKHBvaW50cywgY2xvc2VzdFN0cm9rZSwgbGVuaWVuY3kpID0+IHtcbiAgY29uc3Qgc3RhcnRpbmdEaXN0ID0gZGlzdGFuY2UoY2xvc2VzdFN0cm9rZS5nZXRTdGFydGluZ1BvaW50KCksIHBvaW50c1swXSk7XG4gIGNvbnN0IGVuZGluZ0Rpc3QgPSBkaXN0YW5jZShjbG9zZXN0U3Ryb2tlLmdldEVuZGluZ1BvaW50KCksIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0pO1xuICByZXR1cm4gc3RhcnRpbmdEaXN0IDw9IFNUQVJUX0FORF9FTkRfRElTVF9USFJFU0hPTEQgKiBsZW5pZW5jeSAmJiBlbmRpbmdEaXN0IDw9IFNUQVJUX0FORF9FTkRfRElTVF9USFJFU0hPTEQgKiBsZW5pZW5jeTtcbn07IC8vIHJldHVybnMgYSBsaXN0IG9mIHRoZSBkaXJlY3Rpb24gb2YgYWxsIHNlZ21lbnRzIGluIHRoZSBsaW5lIGNvbm5lY3RpbmcgdGhlIHBvaW50c1xuXG5cbmNvbnN0IGdldEVkZ2VWZWN0b3JzID0gcG9pbnRzID0+IHtcbiAgY29uc3QgdmVjdG9ycyA9IFtdO1xuICBsZXQgbGFzdFBvaW50ID0gcG9pbnRzWzBdO1xuICBwb2ludHMuc2xpY2UoMSkuZm9yRWFjaChwb2ludCA9PiB7XG4gICAgdmVjdG9ycy5wdXNoKHN1YnRyYWN0KHBvaW50LCBsYXN0UG9pbnQpKTtcbiAgICBsYXN0UG9pbnQgPSBwb2ludDtcbiAgfSk7XG4gIHJldHVybiB2ZWN0b3JzO1xufTtcblxuY29uc3QgZGlyZWN0aW9uTWF0Y2hlcyA9IChwb2ludHMsIHN0cm9rZSkgPT4ge1xuICBjb25zdCBlZGdlVmVjdG9ycyA9IGdldEVkZ2VWZWN0b3JzKHBvaW50cyk7XG4gIGNvbnN0IHN0cm9rZVZlY3RvcnMgPSBzdHJva2UuZ2V0VmVjdG9ycygpO1xuICBjb25zdCBzaW1pbGFyaXRpZXMgPSBlZGdlVmVjdG9ycy5tYXAoZWRnZVZlY3RvciA9PiB7XG4gICAgY29uc3Qgc3Ryb2tlU2ltaWxhcml0aWVzID0gc3Ryb2tlVmVjdG9ycy5tYXAoc3Ryb2tlVmVjdG9yID0+IGNvc2luZVNpbWlsYXJpdHkoc3Ryb2tlVmVjdG9yLCBlZGdlVmVjdG9yKSk7XG4gICAgcmV0dXJuIE1hdGgubWF4KC4uLnN0cm9rZVNpbWlsYXJpdGllcyk7XG4gIH0pO1xuICBjb25zdCBhdmdTaW1pbGFyaXR5ID0gYXZlcmFnZShzaW1pbGFyaXRpZXMpO1xuICByZXR1cm4gYXZnU2ltaWxhcml0eSA+IENPU0lORV9TSU1JTEFSSVRZX1RIUkVTSE9MRDtcbn07XG5cbmNvbnN0IGxlbmd0aE1hdGNoZXMgPSAocG9pbnRzLCBzdHJva2UsIGxlbmllbmN5KSA9PiB7XG4gIHJldHVybiBsZW5pZW5jeSAqIChsZW5ndGgocG9pbnRzKSArIDI1KSAvIChzdHJva2UuZ2V0TGVuZ3RoKCkgKyAyNSkgPj0gTUlOX0xFTl9USFJFU0hPTEQ7XG59O1xuXG5jb25zdCBzdHJpcER1cGxpY2F0ZXMgPSBwb2ludHMgPT4ge1xuICBpZiAocG9pbnRzLmxlbmd0aCA8IDIpIHJldHVybiBwb2ludHM7XG4gIGNvbnN0IFtmaXJzdFBvaW50LCAuLi5yZXN0XSA9IHBvaW50cztcbiAgY29uc3QgZGVkdXBlZFBvaW50cyA9IFtmaXJzdFBvaW50XTtcblxuICBmb3IgKGNvbnN0IHBvaW50IG9mIHJlc3QpIHtcbiAgICBpZiAoIWVxdWFscyhwb2ludCwgZGVkdXBlZFBvaW50c1tkZWR1cGVkUG9pbnRzLmxlbmd0aCAtIDFdKSkge1xuICAgICAgZGVkdXBlZFBvaW50cy5wdXNoKHBvaW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVkdXBlZFBvaW50cztcbn07XG5cbmNvbnN0IFNIQVBFX0ZJVF9ST1RBVElPTlMgPSBbTWF0aC5QSSAvIDE2LCBNYXRoLlBJIC8gMzIsIDAsIC0xICogTWF0aC5QSSAvIDMyLCAtMSAqIE1hdGguUEkgLyAxNl07XG5cbmNvbnN0IHNoYXBlRml0ID0gKGN1cnZlMSwgY3VydmUyLCBsZW5pZW5jeSkgPT4ge1xuICBjb25zdCBub3JtQ3VydmUxID0gbm9ybWFsaXplQ3VydmUoY3VydmUxKTtcbiAgY29uc3Qgbm9ybUN1cnZlMiA9IG5vcm1hbGl6ZUN1cnZlKGN1cnZlMik7XG4gIGxldCBtaW5EaXN0ID0gSW5maW5pdHk7XG4gIFNIQVBFX0ZJVF9ST1RBVElPTlMuZm9yRWFjaCh0aGV0YSA9PiB7XG4gICAgY29uc3QgZGlzdCA9IGZyZWNoZXREaXN0KG5vcm1DdXJ2ZTEsIHJvdGF0ZShub3JtQ3VydmUyLCB0aGV0YSkpO1xuXG4gICAgaWYgKGRpc3QgPCBtaW5EaXN0KSB7XG4gICAgICBtaW5EaXN0ID0gZGlzdDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbWluRGlzdCA8PSBGUkVDSEVUX1RIUkVTSE9MRCAqIGxlbmllbmN5O1xufTtcblxuY29uc3QgZ2V0TWF0Y2hEYXRhID0gKHBvaW50cywgc3Ryb2tlLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBsZW5pZW5jeSA9IDEsXG4gICAgaXNPdXRsaW5lVmlzaWJsZSA9IGZhbHNlLFxuICAgIGNoZWNrQmFja3dhcmRzID0gdHJ1ZSxcbiAgICBhdmVyYWdlRGlzdGFuY2VUaHJlc2hvbGQgPSAzNTBcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGF2Z0Rpc3QgPSBzdHJva2UuZ2V0QXZlcmFnZURpc3RhbmNlKHBvaW50cyk7XG4gIGNvbnN0IGRpc3RNb2QgPSBpc091dGxpbmVWaXNpYmxlIHx8IHN0cm9rZS5zdHJva2VOdW0gPiAwID8gMC41IDogMTtcbiAgY29uc3Qgd2l0aGluRGlzdFRocmVzaCA9IGF2Z0Rpc3QgPD0gYXZlcmFnZURpc3RhbmNlVGhyZXNob2xkICogZGlzdE1vZCAqIGxlbmllbmN5OyAvLyBzaG9ydCBjaXJjdWl0IGZvciBmYXN0ZXIgbWF0Y2hpbmdcblxuICBpZiAoIXdpdGhpbkRpc3RUaHJlc2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaDogZmFsc2UsXG4gICAgICBhdmdEaXN0LFxuICAgICAgbWV0YToge1xuICAgICAgICBpc1N0cm9rZUJhY2t3YXJkczogZmFsc2VcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgY29uc3Qgc3RhcnRBbmRFbmRNYXRjaCA9IHN0YXJ0QW5kRW5kTWF0Y2hlcyhwb2ludHMsIHN0cm9rZSwgbGVuaWVuY3kpO1xuICBjb25zdCBkaXJlY3Rpb25NYXRjaCA9IGRpcmVjdGlvbk1hdGNoZXMocG9pbnRzLCBzdHJva2UpO1xuICBjb25zdCBzaGFwZU1hdGNoID0gc2hhcGVGaXQocG9pbnRzLCBzdHJva2UucG9pbnRzLCBsZW5pZW5jeSk7XG4gIGNvbnN0IGxlbmd0aE1hdGNoID0gbGVuZ3RoTWF0Y2hlcyhwb2ludHMsIHN0cm9rZSwgbGVuaWVuY3kpO1xuICBjb25zdCBpc01hdGNoID0gd2l0aGluRGlzdFRocmVzaCAmJiBzdGFydEFuZEVuZE1hdGNoICYmIGRpcmVjdGlvbk1hdGNoICYmIHNoYXBlTWF0Y2ggJiYgbGVuZ3RoTWF0Y2g7XG5cbiAgaWYgKGNoZWNrQmFja3dhcmRzICYmICFpc01hdGNoKSB7XG4gICAgY29uc3QgYmFja3dhcmRzTWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKFsuLi5wb2ludHNdLnJldmVyc2UoKSwgc3Ryb2tlLCB7IC4uLm9wdGlvbnMsXG4gICAgICBjaGVja0JhY2t3YXJkczogZmFsc2VcbiAgICB9KTtcblxuICAgIGlmIChiYWNrd2FyZHNNYXRjaERhdGEuaXNNYXRjaCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNNYXRjaCxcbiAgICAgICAgYXZnRGlzdCxcbiAgICAgICAgbWV0YToge1xuICAgICAgICAgIGlzU3Ryb2tlQmFja3dhcmRzOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpc01hdGNoLFxuICAgIGF2Z0Rpc3QsXG4gICAgbWV0YToge1xuICAgICAgaXNTdHJva2VCYWNrd2FyZHM6IGZhbHNlXG4gICAgfVxuICB9O1xufTtcblxuY2xhc3MgVXNlclN0cm9rZSB7XG4gIGNvbnN0cnVjdG9yKGlkLCBzdGFydGluZ1BvaW50LCBzdGFydGluZ0V4dGVybmFsUG9pbnQpIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5wb2ludHMgPSBbc3RhcnRpbmdQb2ludF07XG4gICAgdGhpcy5leHRlcm5hbFBvaW50cyA9IFtzdGFydGluZ0V4dGVybmFsUG9pbnRdO1xuICB9XG5cbiAgYXBwZW5kUG9pbnQocG9pbnQsIGV4dGVybmFsUG9pbnQpIHtcbiAgICB0aGlzLnBvaW50cy5wdXNoKHBvaW50KTtcbiAgICB0aGlzLmV4dGVybmFsUG9pbnRzLnB1c2goZXh0ZXJuYWxQb2ludCk7XG4gIH1cblxufVxuXG5jbGFzcyBEZWxheSB7XG4gIGNvbnN0cnVjdG9yKGR1cmF0aW9uKSB7XG4gICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMuc2NvcGUgPSBgZGVsYXkuJHtkdXJhdGlvbn1gO1xuICB9XG5cbiAgcnVuKCkge1xuICAgIHRoaXMuX3N0YXJ0VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG4gICAgdGhpcy5fcnVubmluZ1Byb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlOyAvLyBAdHMtaWdub3JlIHJldHVybiB0eXBlIG9mIFwic2V0VGltZW91dFwiIGluIGJ1aWxkcyBpcyBwYXJzZWQgYXMgYG51bWJlcmAgaW5zdGVhZCBvZiBgVGltZW91dGBcblxuICAgICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5jYW5jZWwoKSwgdGhpcy5fZHVyYXRpb24pO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl9ydW5uaW5nUHJvbWlzZTtcbiAgfVxuXG4gIHBhdXNlKCkge1xuICAgIGlmICh0aGlzLl9wYXVzZWQpIHJldHVybjsgLy8gdG8gcGF1c2UsIGNsZWFyIHRoZSB0aW1lb3V0IGFuZCByZXdyaXRlIHRoaXMuX2R1cmF0aW9uIHdpdGggd2hhdGV2ZXIgdGltZSBpcyByZW1haW5pbmdcblxuICAgIGNvbnN0IGVsYXBzZWREZWxheSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gKHRoaXMuX3N0YXJ0VGltZSB8fCAwKTtcbiAgICB0aGlzLl9kdXJhdGlvbiA9IE1hdGgubWF4KDAsIHRoaXMuX2R1cmF0aW9uIC0gZWxhcHNlZERlbGF5KTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgfVxuXG4gIHJlc3VtZSgpIHtcbiAgICBpZiAoIXRoaXMuX3BhdXNlZCkgcmV0dXJuO1xuICAgIHRoaXMuX3N0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpOyAvLyBAdHMtaWdub3JlIHJldHVybiB0eXBlIG9mIFwic2V0VGltZW91dFwiIGluIGJ1aWxkcyBpcyBwYXJzZWQgYXMgYG51bWJlcmAgaW5zdGVhZCBvZiBgVGltZW91dGBcblxuICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuY2FuY2VsKCksIHRoaXMuX2R1cmF0aW9uKTtcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGNhbmNlbCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG5cbiAgICBpZiAodGhpcy5fcmVzb2x2ZSkge1xuICAgICAgdGhpcy5fcmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gIH1cblxufVxuXG5jbGFzcyBNdXRhdGlvbiB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gc2NvcGUgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2Ygd2hhdCBmaWVsZHMgdGhpcyBtdXRhdGlvbiBhZmZlY3RzIGZyb20gdGhlIHN0YXRlLiBUaGlzIGlzIHVzZWQgdG8gY2FuY2VsIGNvbmZsaWN0aW5nIG11dGF0aW9uc1xuICAgKiBAcGFyYW0gdmFsdWVzT3JDYWxsYWJsZSBhIHRodW5rIGNvbnRhaW5pbmcgdGhlIHZhbHVlIHRvIHNldCwgb3IgYSBjYWxsYmFjayB3aGljaCB3aWxsIHJldHVybiB0aG9zZSB2YWx1ZXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNjb3BlLCB2YWx1ZXNPckNhbGxhYmxlLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl90aWNrID0gdGltaW5nID0+IHtcbiAgICAgIGlmICh0aGlzLl9zdGFydFBhdXNlVGltZSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5taW4oMSwgKHRpbWluZyAtIHRoaXMuX3N0YXJ0VGltZSAtIHRoaXMuX3BhdXNlZER1cmF0aW9uKSAvIHRoaXMuX2R1cmF0aW9uKTtcblxuICAgICAgaWYgKHByb2dyZXNzID09PSAxKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnVwZGF0ZVN0YXRlKHRoaXMuX3ZhbHVlcyk7XG5cbiAgICAgICAgdGhpcy5fZnJhbWVIYW5kbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2FuY2VsKHRoaXMuX3JlbmRlclN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVhc2VkUHJvZ3Jlc3MgPSBlYXNlKHByb2dyZXNzKTtcbiAgICAgICAgY29uc3Qgc3RhdGVDaGFuZ2VzID0gZ2V0UGFydGlhbFZhbHVlcyh0aGlzLl9zdGFydFN0YXRlLCB0aGlzLl92YWx1ZXMsIGVhc2VkUHJvZ3Jlc3MpO1xuXG4gICAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnVwZGF0ZVN0YXRlKHN0YXRlQ2hhbmdlcyk7XG5cbiAgICAgICAgdGhpcy5fZnJhbWVIYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fdGljayk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLl92YWx1ZXNPckNhbGxhYmxlID0gdmFsdWVzT3JDYWxsYWJsZTtcbiAgICB0aGlzLl9kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gfHwgMDtcbiAgICB0aGlzLl9mb3JjZSA9IG9wdGlvbnMuZm9yY2U7XG4gICAgdGhpcy5fcGF1c2VkRHVyYXRpb24gPSAwO1xuICAgIHRoaXMuX3N0YXJ0UGF1c2VUaW1lID0gbnVsbDtcbiAgfVxuXG4gIHJ1bihyZW5kZXJTdGF0ZSkge1xuICAgIGlmICghdGhpcy5fdmFsdWVzKSB0aGlzLl9pbmZsYXRlVmFsdWVzKHJlbmRlclN0YXRlKTtcbiAgICBpZiAodGhpcy5fZHVyYXRpb24gPT09IDApIHJlbmRlclN0YXRlLnVwZGF0ZVN0YXRlKHRoaXMuX3ZhbHVlcyk7XG5cbiAgICBpZiAodGhpcy5fZHVyYXRpb24gPT09IDAgfHwgaXNBbHJlYWR5QXRFbmQocmVuZGVyU3RhdGUuc3RhdGUsIHRoaXMuX3ZhbHVlcykpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZW5kZXJTdGF0ZSA9IHJlbmRlclN0YXRlO1xuICAgIHRoaXMuX3N0YXJ0U3RhdGUgPSByZW5kZXJTdGF0ZS5zdGF0ZTtcbiAgICB0aGlzLl9zdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB0aGlzLl9mcmFtZUhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl90aWNrKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgfVxuXG4gIF9pbmZsYXRlVmFsdWVzKHJlbmRlclN0YXRlKSB7XG4gICAgbGV0IHZhbHVlcyA9IHRoaXMuX3ZhbHVlc09yQ2FsbGFibGU7XG5cbiAgICBpZiAodHlwZW9mIHRoaXMuX3ZhbHVlc09yQ2FsbGFibGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhbHVlcyA9IHRoaXMuX3ZhbHVlc09yQ2FsbGFibGUocmVuZGVyU3RhdGUuc3RhdGUpO1xuICAgIH1cblxuICAgIHRoaXMuX3ZhbHVlcyA9IGluZmxhdGUodGhpcy5zY29wZSwgdmFsdWVzKTtcbiAgfVxuXG4gIHBhdXNlKCkge1xuICAgIGlmICh0aGlzLl9zdGFydFBhdXNlVGltZSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9mcmFtZUhhbmRsZSkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fZnJhbWVIYW5kbGUpO1xuICAgIH1cblxuICAgIHRoaXMuX3N0YXJ0UGF1c2VUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gIH1cblxuICByZXN1bWUoKSB7XG4gICAgaWYgKHRoaXMuX3N0YXJ0UGF1c2VUaW1lID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZnJhbWVIYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fdGljayk7XG4gICAgdGhpcy5fcGF1c2VkRHVyYXRpb24gKz0gcGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLl9zdGFydFBhdXNlVGltZTtcbiAgICB0aGlzLl9zdGFydFBhdXNlVGltZSA9IG51bGw7XG4gIH1cblxuICBjYW5jZWwocmVuZGVyU3RhdGUpIHtcbiAgICB2YXIgX3RoaXMkX3Jlc29sdmU7XG5cbiAgICAoX3RoaXMkX3Jlc29sdmUgPSB0aGlzLl9yZXNvbHZlKSA9PT0gbnVsbCB8fCBfdGhpcyRfcmVzb2x2ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkX3Jlc29sdmUuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX2ZyYW1lSGFuZGxlIHx8IC0xKTtcbiAgICB0aGlzLl9mcmFtZUhhbmRsZSA9IHVuZGVmaW5lZDtcblxuICAgIGlmICh0aGlzLl9mb3JjZSkge1xuICAgICAgaWYgKCF0aGlzLl92YWx1ZXMpIHRoaXMuX2luZmxhdGVWYWx1ZXMocmVuZGVyU3RhdGUpO1xuICAgICAgcmVuZGVyU3RhdGUudXBkYXRlU3RhdGUodGhpcy5fdmFsdWVzKTtcbiAgICB9XG4gIH1cblxufVxuTXV0YXRpb24uRGVsYXkgPSBEZWxheTtcblxuZnVuY3Rpb24gZ2V0UGFydGlhbFZhbHVlcyhzdGFydFZhbHVlcywgZW5kVmFsdWVzLCBwcm9ncmVzcykge1xuICBjb25zdCB0YXJnZXQgPSB7fTtcblxuICBmb3IgKGNvbnN0IGtleSBpbiBlbmRWYWx1ZXMpIHtcbiAgICBjb25zdCBlbmRWYWx1ZSA9IGVuZFZhbHVlc1trZXldO1xuICAgIGNvbnN0IHN0YXJ0VmFsdWUgPSBzdGFydFZhbHVlcyA9PT0gbnVsbCB8fCBzdGFydFZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RhcnRWYWx1ZXNba2V5XTtcblxuICAgIGlmICh0eXBlb2Ygc3RhcnRWYWx1ZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGVuZFZhbHVlID09PSAnbnVtYmVyJyAmJiBlbmRWYWx1ZSA+PSAwKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHByb2dyZXNzICogKGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSkgKyBzdGFydFZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXRba2V5XSA9IGdldFBhcnRpYWxWYWx1ZXMoc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIHByb2dyZXNzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBpc0FscmVhZHlBdEVuZChzdGFydFZhbHVlcywgZW5kVmFsdWVzKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIGVuZFZhbHVlcykge1xuICAgIGNvbnN0IGVuZFZhbHVlID0gZW5kVmFsdWVzW2tleV07XG4gICAgY29uc3Qgc3RhcnRWYWx1ZSA9IHN0YXJ0VmFsdWVzID09PSBudWxsIHx8IHN0YXJ0VmFsdWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdGFydFZhbHVlc1trZXldO1xuXG4gICAgaWYgKGVuZFZhbHVlID49IDApIHtcbiAgICAgIGlmIChlbmRWYWx1ZSAhPT0gc3RhcnRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNBbHJlYWR5QXRFbmQoc3RhcnRWYWx1ZSwgZW5kVmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59IC8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21heHdlbGxpdG8vdml2dXNcblxuXG5jb25zdCBlYXNlID0geCA9PiAtTWF0aC5jb3MoeCAqIE1hdGguUEkpIC8gMiArIDAuNTtcblxuY29uc3Qgc2hvd1N0cm9rZXMgPSAoY2hhck5hbWUsIGNoYXJhY3RlciwgZHVyYXRpb24pID0+IHtcbiAgcmV0dXJuIFtuZXcgTXV0YXRpb24oYGNoYXJhY3Rlci4ke2NoYXJOYW1lfS5zdHJva2VzYCwgb2JqUmVwZWF0KHtcbiAgICBvcGFjaXR5OiAxLFxuICAgIGRpc3BsYXlQb3J0aW9uOiAxXG4gIH0sIGNoYXJhY3Rlci5zdHJva2VzLmxlbmd0aCksIHtcbiAgICBkdXJhdGlvbixcbiAgICBmb3JjZTogdHJ1ZVxuICB9KV07XG59O1xuY29uc3Qgc2hvd0NoYXJhY3RlciA9IChjaGFyTmFtZSwgY2hhcmFjdGVyLCBkdXJhdGlvbikgPT4ge1xuICByZXR1cm4gW25ldyBNdXRhdGlvbihgY2hhcmFjdGVyLiR7Y2hhck5hbWV9YCwge1xuICAgIG9wYWNpdHk6IDEsXG4gICAgc3Ryb2tlczogb2JqUmVwZWF0KHtcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICBkaXNwbGF5UG9ydGlvbjogMVxuICAgIH0sIGNoYXJhY3Rlci5zdHJva2VzLmxlbmd0aClcbiAgfSwge1xuICAgIGR1cmF0aW9uLFxuICAgIGZvcmNlOiB0cnVlXG4gIH0pXTtcbn07XG5jb25zdCBoaWRlQ2hhcmFjdGVyID0gKGNoYXJOYW1lLCBjaGFyYWN0ZXIsIGR1cmF0aW9uKSA9PiB7XG4gIHJldHVybiBbbmV3IE11dGF0aW9uKGBjaGFyYWN0ZXIuJHtjaGFyTmFtZX0ub3BhY2l0eWAsIDAsIHtcbiAgICBkdXJhdGlvbixcbiAgICBmb3JjZTogdHJ1ZVxuICB9KSwgLi4uc2hvd1N0cm9rZXMoY2hhck5hbWUsIGNoYXJhY3RlciwgMCldO1xufTtcbmNvbnN0IHVwZGF0ZUNvbG9yID0gKGNvbG9yTmFtZSwgY29sb3JWYWwsIGR1cmF0aW9uKSA9PiB7XG4gIHJldHVybiBbbmV3IE11dGF0aW9uKGBvcHRpb25zLiR7Y29sb3JOYW1lfWAsIGNvbG9yVmFsLCB7XG4gICAgZHVyYXRpb25cbiAgfSldO1xufTtcbmNvbnN0IGhpZ2hsaWdodFN0cm9rZSA9IChzdHJva2UsIGNvbG9yLCBzcGVlZCkgPT4ge1xuICBjb25zdCBzdHJva2VOdW0gPSBzdHJva2Uuc3Ryb2tlTnVtO1xuICBjb25zdCBkdXJhdGlvbiA9IChzdHJva2UuZ2V0TGVuZ3RoKCkgKyA2MDApIC8gKDMgKiBzcGVlZCk7XG4gIHJldHVybiBbbmV3IE11dGF0aW9uKCdvcHRpb25zLmhpZ2hsaWdodENvbG9yJywgY29sb3IpLCBuZXcgTXV0YXRpb24oJ2NoYXJhY3Rlci5oaWdobGlnaHQnLCB7XG4gICAgb3BhY2l0eTogMSxcbiAgICBzdHJva2VzOiB7XG4gICAgICBbc3Ryb2tlTnVtXToge1xuICAgICAgICBkaXNwbGF5UG9ydGlvbjogMCxcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfVxuICAgIH1cbiAgfSksIG5ldyBNdXRhdGlvbihgY2hhcmFjdGVyLmhpZ2hsaWdodC5zdHJva2VzLiR7c3Ryb2tlTnVtfWAsIHtcbiAgICBkaXNwbGF5UG9ydGlvbjogMSxcbiAgICBvcGFjaXR5OiAxXG4gIH0sIHtcbiAgICBkdXJhdGlvblxuICB9KSwgbmV3IE11dGF0aW9uKGBjaGFyYWN0ZXIuaGlnaGxpZ2h0LnN0cm9rZXMuJHtzdHJva2VOdW19Lm9wYWNpdHlgLCAwLCB7XG4gICAgZHVyYXRpb24sXG4gICAgZm9yY2U6IHRydWVcbiAgfSldO1xufTtcbmNvbnN0IGFuaW1hdGVTdHJva2UgPSAoY2hhck5hbWUsIHN0cm9rZSwgc3BlZWQpID0+IHtcbiAgY29uc3Qgc3Ryb2tlTnVtID0gc3Ryb2tlLnN0cm9rZU51bTtcbiAgY29uc3QgZHVyYXRpb24gPSAoc3Ryb2tlLmdldExlbmd0aCgpICsgNjAwKSAvICgzICogc3BlZWQpO1xuICByZXR1cm4gW25ldyBNdXRhdGlvbihgY2hhcmFjdGVyLiR7Y2hhck5hbWV9YCwge1xuICAgIG9wYWNpdHk6IDEsXG4gICAgc3Ryb2tlczoge1xuICAgICAgW3N0cm9rZU51bV06IHtcbiAgICAgICAgZGlzcGxheVBvcnRpb246IDAsXG4gICAgICAgIG9wYWNpdHk6IDFcbiAgICAgIH1cbiAgICB9XG4gIH0pLCBuZXcgTXV0YXRpb24oYGNoYXJhY3Rlci4ke2NoYXJOYW1lfS5zdHJva2VzLiR7c3Ryb2tlTnVtfS5kaXNwbGF5UG9ydGlvbmAsIDEsIHtcbiAgICBkdXJhdGlvblxuICB9KV07XG59O1xuY29uc3QgYW5pbWF0ZVNpbmdsZVN0cm9rZSA9IChjaGFyTmFtZSwgY2hhcmFjdGVyLCBzdHJva2VOdW0sIHNwZWVkKSA9PiB7XG4gIGNvbnN0IG11dGF0aW9uU3RhdGVGdW5jID0gc3RhdGUgPT4ge1xuICAgIGNvbnN0IGN1ckNoYXJTdGF0ZSA9IHN0YXRlLmNoYXJhY3RlcltjaGFyTmFtZV07XG4gICAgY29uc3QgbXV0YXRpb25TdGF0ZSA9IHtcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICBzdHJva2VzOiB7fVxuICAgIH07XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJhY3Rlci5zdHJva2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBtdXRhdGlvblN0YXRlLnN0cm9rZXNbaV0gPSB7XG4gICAgICAgIG9wYWNpdHk6IGN1ckNoYXJTdGF0ZS5vcGFjaXR5ICogY3VyQ2hhclN0YXRlLnN0cm9rZXNbaV0ub3BhY2l0eVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbXV0YXRpb25TdGF0ZTtcbiAgfTtcblxuICBjb25zdCBzdHJva2UgPSBjaGFyYWN0ZXIuc3Ryb2tlc1tzdHJva2VOdW1dO1xuICByZXR1cm4gW25ldyBNdXRhdGlvbihgY2hhcmFjdGVyLiR7Y2hhck5hbWV9YCwgbXV0YXRpb25TdGF0ZUZ1bmMpLCAuLi5hbmltYXRlU3Ryb2tlKGNoYXJOYW1lLCBzdHJva2UsIHNwZWVkKV07XG59O1xuY29uc3Qgc2hvd1N0cm9rZSA9IChjaGFyTmFtZSwgc3Ryb2tlTnVtLCBkdXJhdGlvbikgPT4ge1xuICByZXR1cm4gW25ldyBNdXRhdGlvbihgY2hhcmFjdGVyLiR7Y2hhck5hbWV9LnN0cm9rZXMuJHtzdHJva2VOdW19YCwge1xuICAgIGRpc3BsYXlQb3J0aW9uOiAxLFxuICAgIG9wYWNpdHk6IDFcbiAgfSwge1xuICAgIGR1cmF0aW9uLFxuICAgIGZvcmNlOiB0cnVlXG4gIH0pXTtcbn07XG5jb25zdCBhbmltYXRlQ2hhcmFjdGVyID0gKGNoYXJOYW1lLCBjaGFyYWN0ZXIsIGZhZGVEdXJhdGlvbiwgc3BlZWQsIGRlbGF5QmV0d2VlblN0cm9rZXMpID0+IHtcbiAgbGV0IG11dGF0aW9ucyA9IGhpZGVDaGFyYWN0ZXIoY2hhck5hbWUsIGNoYXJhY3RlciwgZmFkZUR1cmF0aW9uKTtcbiAgbXV0YXRpb25zID0gbXV0YXRpb25zLmNvbmNhdChzaG93U3Ryb2tlcyhjaGFyTmFtZSwgY2hhcmFjdGVyLCAwKSk7XG4gIG11dGF0aW9ucy5wdXNoKG5ldyBNdXRhdGlvbihgY2hhcmFjdGVyLiR7Y2hhck5hbWV9YCwge1xuICAgIG9wYWNpdHk6IDEsXG4gICAgc3Ryb2tlczogb2JqUmVwZWF0KHtcbiAgICAgIG9wYWNpdHk6IDBcbiAgICB9LCBjaGFyYWN0ZXIuc3Ryb2tlcy5sZW5ndGgpXG4gIH0sIHtcbiAgICBmb3JjZTogdHJ1ZVxuICB9KSk7XG4gIGNoYXJhY3Rlci5zdHJva2VzLmZvckVhY2goKHN0cm9rZSwgaSkgPT4ge1xuICAgIGlmIChpID4gMCkgbXV0YXRpb25zLnB1c2gobmV3IE11dGF0aW9uLkRlbGF5KGRlbGF5QmV0d2VlblN0cm9rZXMpKTtcbiAgICBtdXRhdGlvbnMgPSBtdXRhdGlvbnMuY29uY2F0KGFuaW1hdGVTdHJva2UoY2hhck5hbWUsIHN0cm9rZSwgc3BlZWQpKTtcbiAgfSk7XG4gIHJldHVybiBtdXRhdGlvbnM7XG59O1xuY29uc3QgYW5pbWF0ZUNoYXJhY3Rlckxvb3AgPSAoY2hhck5hbWUsIGNoYXJhY3RlciwgZmFkZUR1cmF0aW9uLCBzcGVlZCwgZGVsYXlCZXR3ZWVuU3Ryb2tlcywgZGVsYXlCZXR3ZWVuTG9vcHMpID0+IHtcbiAgY29uc3QgbXV0YXRpb25zID0gYW5pbWF0ZUNoYXJhY3RlcihjaGFyTmFtZSwgY2hhcmFjdGVyLCBmYWRlRHVyYXRpb24sIHNwZWVkLCBkZWxheUJldHdlZW5TdHJva2VzKTtcbiAgbXV0YXRpb25zLnB1c2gobmV3IE11dGF0aW9uLkRlbGF5KGRlbGF5QmV0d2Vlbkxvb3BzKSk7XG4gIHJldHVybiBtdXRhdGlvbnM7XG59O1xuXG5jb25zdCBzdGFydFF1aXogPSAoY2hhcmFjdGVyLCBmYWRlRHVyYXRpb24sIHN0YXJ0U3Ryb2tlTnVtKSA9PiB7XG4gIHJldHVybiBbLi4uaGlkZUNoYXJhY3RlcignbWFpbicsIGNoYXJhY3RlciwgZmFkZUR1cmF0aW9uKSwgbmV3IE11dGF0aW9uKCdjaGFyYWN0ZXIuaGlnaGxpZ2h0Jywge1xuICAgIG9wYWNpdHk6IDEsXG4gICAgc3Ryb2tlczogb2JqUmVwZWF0KHtcbiAgICAgIG9wYWNpdHk6IDBcbiAgICB9LCBjaGFyYWN0ZXIuc3Ryb2tlcy5sZW5ndGgpXG4gIH0sIHtcbiAgICBmb3JjZTogdHJ1ZVxuICB9KSwgbmV3IE11dGF0aW9uKCdjaGFyYWN0ZXIubWFpbicsIHtcbiAgICBvcGFjaXR5OiAxLFxuICAgIHN0cm9rZXM6IG9ialJlcGVhdENiKGNoYXJhY3Rlci5zdHJva2VzLmxlbmd0aCwgaSA9PiAoe1xuICAgICAgb3BhY2l0eTogaSA8IHN0YXJ0U3Ryb2tlTnVtID8gMSA6IDBcbiAgICB9KSlcbiAgfSwge1xuICAgIGZvcmNlOiB0cnVlXG4gIH0pXTtcbn07XG5jb25zdCBzdGFydFVzZXJTdHJva2UgPSAoaWQsIHBvaW50KSA9PiB7XG4gIHJldHVybiBbbmV3IE11dGF0aW9uKCdxdWl6LmFjdGl2ZVVzZXJTdHJva2VJZCcsIGlkLCB7XG4gICAgZm9yY2U6IHRydWVcbiAgfSksIG5ldyBNdXRhdGlvbihgdXNlclN0cm9rZXMuJHtpZH1gLCB7XG4gICAgcG9pbnRzOiBbcG9pbnRdLFxuICAgIG9wYWNpdHk6IDFcbiAgfSwge1xuICAgIGZvcmNlOiB0cnVlXG4gIH0pXTtcbn07XG5jb25zdCB1cGRhdGVVc2VyU3Ryb2tlID0gKHVzZXJTdHJva2VJZCwgcG9pbnRzKSA9PiB7XG4gIHJldHVybiBbbmV3IE11dGF0aW9uKGB1c2VyU3Ryb2tlcy4ke3VzZXJTdHJva2VJZH0ucG9pbnRzYCwgcG9pbnRzLCB7XG4gICAgZm9yY2U6IHRydWVcbiAgfSldO1xufTtcbmNvbnN0IGhpZGVVc2VyU3Ryb2tlID0gKHVzZXJTdHJva2VJZCwgZHVyYXRpb24pID0+IHtcbiAgcmV0dXJuIFtuZXcgTXV0YXRpb24oYHVzZXJTdHJva2VzLiR7dXNlclN0cm9rZUlkfS5vcGFjaXR5YCwgMCwge1xuICAgIGR1cmF0aW9uXG4gIH0pXTtcbn07XG5jb25zdCByZW1vdmVBbGxVc2VyU3Ryb2tlcyA9IHVzZXJTdHJva2VJZHMgPT4ge1xuICByZXR1cm4gKHVzZXJTdHJva2VJZHMgPT09IG51bGwgfHwgdXNlclN0cm9rZUlkcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXNlclN0cm9rZUlkcy5tYXAodXNlclN0cm9rZUlkID0+IG5ldyBNdXRhdGlvbihgdXNlclN0cm9rZXMuJHt1c2VyU3Ryb2tlSWR9YCwgbnVsbCwge1xuICAgIGZvcmNlOiB0cnVlXG4gIH0pKSkgfHwgW107XG59O1xuY29uc3QgaGlnaGxpZ2h0Q29tcGxldGVDaGFyID0gKGNoYXJhY3RlciwgY29sb3IsIGR1cmF0aW9uKSA9PiB7XG4gIHJldHVybiBbbmV3IE11dGF0aW9uKCdvcHRpb25zLmhpZ2hsaWdodENvbG9yJywgY29sb3IpLCAuLi5oaWRlQ2hhcmFjdGVyKCdoaWdobGlnaHQnLCBjaGFyYWN0ZXIpLCAuLi5zaG93Q2hhcmFjdGVyKCdoaWdobGlnaHQnLCBjaGFyYWN0ZXIsIGR1cmF0aW9uIC8gMiksIC4uLmhpZGVDaGFyYWN0ZXIoJ2hpZ2hsaWdodCcsIGNoYXJhY3RlciwgZHVyYXRpb24gLyAyKV07XG59O1xuXG5jb25zdCBnZXREcmF3blBhdGggPSB1c2VyU3Ryb2tlID0+ICh7XG4gIHBhdGhTdHJpbmc6IGdldFBhdGhTdHJpbmcodXNlclN0cm9rZS5leHRlcm5hbFBvaW50cyksXG4gIHBvaW50czogdXNlclN0cm9rZS5wb2ludHMubWFwKHBvaW50ID0+IHJvdW5kKHBvaW50KSlcbn0pO1xuXG5jbGFzcyBRdWl6IHtcbiAgY29uc3RydWN0b3IoY2hhcmFjdGVyLCByZW5kZXJTdGF0ZSwgcG9zaXRpb25lcikge1xuICAgIHRoaXMuX2N1cnJlbnRTdHJva2VJbmRleCA9IDA7XG4gICAgdGhpcy5fbWlzdGFrZXNPblN0cm9rZSA9IDA7XG4gICAgdGhpcy5fdG90YWxNaXN0YWtlcyA9IDA7XG4gICAgdGhpcy5fY2hhcmFjdGVyID0gY2hhcmFjdGVyO1xuICAgIHRoaXMuX3JlbmRlclN0YXRlID0gcmVuZGVyU3RhdGU7XG4gICAgdGhpcy5faXNBY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLl9wb3NpdGlvbmVyID0gcG9zaXRpb25lcjtcbiAgfVxuXG4gIHN0YXJ0UXVpeihvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuX3VzZXJTdHJva2VzSWRzKSB7XG4gICAgICB0aGlzLl9yZW5kZXJTdGF0ZS5ydW4ocmVtb3ZlQWxsVXNlclN0cm9rZXModGhpcy5fdXNlclN0cm9rZXNJZHMpKTtcbiAgICB9XG5cbiAgICB0aGlzLl91c2VyU3Ryb2tlc0lkcyA9IFtdO1xuICAgIHRoaXMuX2lzQWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICBjb25zdCBzdGFydEluZGV4ID0gZml4SW5kZXgob3B0aW9ucy5xdWl6U3RhcnRTdHJva2VOdW0sIHRoaXMuX2NoYXJhY3Rlci5zdHJva2VzLmxlbmd0aCk7XG4gICAgdGhpcy5fY3VycmVudFN0cm9rZUluZGV4ID0gTWF0aC5taW4oc3RhcnRJbmRleCwgdGhpcy5fY2hhcmFjdGVyLnN0cm9rZXMubGVuZ3RoIC0gMSk7XG4gICAgdGhpcy5fbWlzdGFrZXNPblN0cm9rZSA9IDA7XG4gICAgdGhpcy5fdG90YWxNaXN0YWtlcyA9IDA7XG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlclN0YXRlLnJ1bihzdGFydFF1aXoodGhpcy5fY2hhcmFjdGVyLCBvcHRpb25zLnN0cm9rZUZhZGVEdXJhdGlvbiwgdGhpcy5fY3VycmVudFN0cm9rZUluZGV4KSk7XG4gIH1cblxuICBzdGFydFVzZXJTdHJva2UoZXh0ZXJuYWxQb2ludCkge1xuICAgIHZhciBfdGhpcyRfdXNlclN0cm9rZXNJZHM7XG5cbiAgICBpZiAoIXRoaXMuX2lzQWN0aXZlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdXNlclN0cm9rZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5kVXNlclN0cm9rZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IHBvaW50ID0gdGhpcy5fcG9zaXRpb25lci5jb252ZXJ0RXh0ZXJuYWxQb2ludChleHRlcm5hbFBvaW50KTtcblxuICAgIGNvbnN0IHN0cm9rZUlkID0gY291bnRlcigpO1xuICAgIHRoaXMuX3VzZXJTdHJva2UgPSBuZXcgVXNlclN0cm9rZShzdHJva2VJZCwgcG9pbnQsIGV4dGVybmFsUG9pbnQpO1xuICAgIChfdGhpcyRfdXNlclN0cm9rZXNJZHMgPSB0aGlzLl91c2VyU3Ryb2tlc0lkcykgPT09IG51bGwgfHwgX3RoaXMkX3VzZXJTdHJva2VzSWRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRfdXNlclN0cm9rZXNJZHMucHVzaChzdHJva2VJZCk7XG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlclN0YXRlLnJ1bihzdGFydFVzZXJTdHJva2Uoc3Ryb2tlSWQsIHBvaW50KSk7XG4gIH1cblxuICBjb250aW51ZVVzZXJTdHJva2UoZXh0ZXJuYWxQb2ludCkge1xuICAgIGlmICghdGhpcy5fdXNlclN0cm9rZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IHBvaW50ID0gdGhpcy5fcG9zaXRpb25lci5jb252ZXJ0RXh0ZXJuYWxQb2ludChleHRlcm5hbFBvaW50KTtcblxuICAgIHRoaXMuX3VzZXJTdHJva2UuYXBwZW5kUG9pbnQocG9pbnQsIGV4dGVybmFsUG9pbnQpO1xuXG4gICAgY29uc3QgbmV4dFBvaW50cyA9IHRoaXMuX3VzZXJTdHJva2UucG9pbnRzLnNsaWNlKDApO1xuXG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlclN0YXRlLnJ1bih1cGRhdGVVc2VyU3Ryb2tlKHRoaXMuX3VzZXJTdHJva2UuaWQsIG5leHRQb2ludHMpKTtcbiAgfVxuXG4gIHNldFBvc2l0aW9uZXIocG9zaXRpb25lcikge1xuICAgIHRoaXMuX3Bvc2l0aW9uZXIgPSBwb3NpdGlvbmVyO1xuICB9XG5cbiAgZW5kVXNlclN0cm9rZSgpIHtcbiAgICB2YXIgX3RoaXMkX29wdGlvbnMkZHJhd2luO1xuXG4gICAgaWYgKCF0aGlzLl91c2VyU3Ryb2tlKSByZXR1cm47XG5cbiAgICB0aGlzLl9yZW5kZXJTdGF0ZS5ydW4oaGlkZVVzZXJTdHJva2UodGhpcy5fdXNlclN0cm9rZS5pZCwgKF90aGlzJF9vcHRpb25zJGRyYXdpbiA9IHRoaXMuX29wdGlvbnMuZHJhd2luZ0ZhZGVEdXJhdGlvbikgIT09IG51bGwgJiYgX3RoaXMkX29wdGlvbnMkZHJhd2luICE9PSB2b2lkIDAgPyBfdGhpcyRfb3B0aW9ucyRkcmF3aW4gOiAzMDApKTsgLy8gc2tpcCBzaW5nbGUtcG9pbnQgc3Ryb2tlc1xuXG5cbiAgICBpZiAodGhpcy5fdXNlclN0cm9rZS5wb2ludHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLl91c2VyU3Ryb2tlID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGFjY2VwdEJhY2t3YXJkc1N0cm9rZXMsXG4gICAgICBtYXJrU3Ryb2tlQ29ycmVjdEFmdGVyTWlzc2VzXG4gICAgfSA9IHRoaXMuX29wdGlvbnM7XG5cbiAgICBjb25zdCBjdXJyZW50U3Ryb2tlID0gdGhpcy5fZ2V0Q3VycmVudFN0cm9rZSgpO1xuXG4gICAgY29uc3Qge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIG1ldGFcbiAgICB9ID0gc3Ryb2tlTWF0Y2hlcyh0aGlzLl91c2VyU3Ryb2tlLCB0aGlzLl9jaGFyYWN0ZXIsIHRoaXMuX2N1cnJlbnRTdHJva2VJbmRleCwge1xuICAgICAgaXNPdXRsaW5lVmlzaWJsZTogdGhpcy5fcmVuZGVyU3RhdGUuc3RhdGUuY2hhcmFjdGVyLm91dGxpbmUub3BhY2l0eSA+IDAsXG4gICAgICBsZW5pZW5jeTogdGhpcy5fb3B0aW9ucy5sZW5pZW5jeSxcbiAgICAgIGF2ZXJhZ2VEaXN0YW5jZVRocmVzaG9sZDogdGhpcy5fb3B0aW9ucy5hdmVyYWdlRGlzdGFuY2VUaHJlc2hvbGRcbiAgICB9KTsgLy8gaWYgbWFya1N0cm9rZUNvcnJlY3RBZnRlck1pc3NlcyBpcyBwYXNzZWQsIGp1c3QgZm9yY2UgdGhlIHN0cm9rZSB0byBjb3VudCBhcyBjb3JyZWN0IGFmdGVyIG4gdHJpZXNcblxuICAgIGNvbnN0IGlzRm9yY2VBY2NlcHRlZCA9IG1hcmtTdHJva2VDb3JyZWN0QWZ0ZXJNaXNzZXMgJiYgdGhpcy5fbWlzdGFrZXNPblN0cm9rZSArIDEgPj0gbWFya1N0cm9rZUNvcnJlY3RBZnRlck1pc3NlcztcbiAgICBjb25zdCBpc0FjY2VwdGVkID0gaXNNYXRjaCB8fCBpc0ZvcmNlQWNjZXB0ZWQgfHwgbWV0YS5pc1N0cm9rZUJhY2t3YXJkcyAmJiBhY2NlcHRCYWNrd2FyZHNTdHJva2VzO1xuXG4gICAgaWYgKGlzQWNjZXB0ZWQpIHtcbiAgICAgIHRoaXMuX2hhbmRsZVN1Y2Nlc3MobWV0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hhbmRsZUZhaWx1cmUobWV0YSk7XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2hvd0hpbnRBZnRlck1pc3NlcyxcbiAgICAgICAgaGlnaGxpZ2h0Q29sb3IsXG4gICAgICAgIHN0cm9rZUhpZ2hsaWdodFNwZWVkXG4gICAgICB9ID0gdGhpcy5fb3B0aW9ucztcblxuICAgICAgaWYgKHNob3dIaW50QWZ0ZXJNaXNzZXMgIT09IGZhbHNlICYmIHRoaXMuX21pc3Rha2VzT25TdHJva2UgPj0gc2hvd0hpbnRBZnRlck1pc3Nlcykge1xuICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZS5ydW4oaGlnaGxpZ2h0U3Ryb2tlKGN1cnJlbnRTdHJva2UsIGNvbG9yU3RyaW5nVG9WYWxzKGhpZ2hsaWdodENvbG9yKSwgc3Ryb2tlSGlnaGxpZ2h0U3BlZWQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl91c2VyU3Ryb2tlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgY2FuY2VsKCkge1xuICAgIHRoaXMuX2lzQWN0aXZlID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5fdXNlclN0cm9rZXNJZHMpIHtcbiAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnJ1bihyZW1vdmVBbGxVc2VyU3Ryb2tlcyh0aGlzLl91c2VyU3Ryb2tlc0lkcykpO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRTdHJva2VEYXRhKHtcbiAgICBpc0NvcnJlY3QsXG4gICAgbWV0YVxuICB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoYXJhY3RlcjogdGhpcy5fY2hhcmFjdGVyLnN5bWJvbCxcbiAgICAgIHN0cm9rZU51bTogdGhpcy5fY3VycmVudFN0cm9rZUluZGV4LFxuICAgICAgbWlzdGFrZXNPblN0cm9rZTogdGhpcy5fbWlzdGFrZXNPblN0cm9rZSxcbiAgICAgIHRvdGFsTWlzdGFrZXM6IHRoaXMuX3RvdGFsTWlzdGFrZXMsXG4gICAgICBzdHJva2VzUmVtYWluaW5nOiB0aGlzLl9jaGFyYWN0ZXIuc3Ryb2tlcy5sZW5ndGggLSB0aGlzLl9jdXJyZW50U3Ryb2tlSW5kZXggLSAoaXNDb3JyZWN0ID8gMSA6IDApLFxuICAgICAgZHJhd25QYXRoOiBnZXREcmF3blBhdGgodGhpcy5fdXNlclN0cm9rZSksXG4gICAgICBpc0JhY2t3YXJkczogbWV0YS5pc1N0cm9rZUJhY2t3YXJkc1xuICAgIH07XG4gIH1cblxuICBuZXh0U3Ryb2tlKCkge1xuICAgIGlmICghdGhpcy5fb3B0aW9ucykgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0cm9rZXMsXG4gICAgICBzeW1ib2xcbiAgICB9ID0gdGhpcy5fY2hhcmFjdGVyO1xuICAgIGNvbnN0IHtcbiAgICAgIG9uQ29tcGxldGUsXG4gICAgICBoaWdobGlnaHRPbkNvbXBsZXRlLFxuICAgICAgc3Ryb2tlRmFkZUR1cmF0aW9uLFxuICAgICAgaGlnaGxpZ2h0Q29tcGxldGVDb2xvcixcbiAgICAgIGhpZ2hsaWdodENvbG9yLFxuICAgICAgc3Ryb2tlSGlnaGxpZ2h0RHVyYXRpb25cbiAgICB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBsZXQgYW5pbWF0aW9uID0gc2hvd1N0cm9rZSgnbWFpbicsIHRoaXMuX2N1cnJlbnRTdHJva2VJbmRleCwgc3Ryb2tlRmFkZUR1cmF0aW9uKTtcbiAgICB0aGlzLl9taXN0YWtlc09uU3Ryb2tlID0gMDtcbiAgICB0aGlzLl9jdXJyZW50U3Ryb2tlSW5kZXggKz0gMTtcbiAgICBjb25zdCBpc0NvbXBsZXRlID0gdGhpcy5fY3VycmVudFN0cm9rZUluZGV4ID09PSBzdHJva2VzLmxlbmd0aDtcblxuICAgIGlmIChpc0NvbXBsZXRlKSB7XG4gICAgICB0aGlzLl9pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgb25Db21wbGV0ZSA9PT0gbnVsbCB8fCBvbkNvbXBsZXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNvbXBsZXRlKHtcbiAgICAgICAgY2hhcmFjdGVyOiBzeW1ib2wsXG4gICAgICAgIHRvdGFsTWlzdGFrZXM6IHRoaXMuX3RvdGFsTWlzdGFrZXNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaGlnaGxpZ2h0T25Db21wbGV0ZSkge1xuICAgICAgICBhbmltYXRpb24gPSBhbmltYXRpb24uY29uY2F0KGhpZ2hsaWdodENvbXBsZXRlQ2hhcih0aGlzLl9jaGFyYWN0ZXIsIGNvbG9yU3RyaW5nVG9WYWxzKGhpZ2hsaWdodENvbXBsZXRlQ29sb3IgfHwgaGlnaGxpZ2h0Q29sb3IpLCAoc3Ryb2tlSGlnaGxpZ2h0RHVyYXRpb24gfHwgMCkgKiAyKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fcmVuZGVyU3RhdGUucnVuKGFuaW1hdGlvbik7XG4gIH1cblxuICBfaGFuZGxlU3VjY2VzcyhtZXRhKSB7XG4gICAgaWYgKCF0aGlzLl9vcHRpb25zKSByZXR1cm47XG4gICAgY29uc3Qge1xuICAgICAgb25Db3JyZWN0U3Ryb2tlXG4gICAgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgb25Db3JyZWN0U3Ryb2tlID09PSBudWxsIHx8IG9uQ29ycmVjdFN0cm9rZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25Db3JyZWN0U3Ryb2tlKHsgLi4udGhpcy5fZ2V0U3Ryb2tlRGF0YSh7XG4gICAgICAgIGlzQ29ycmVjdDogdHJ1ZSxcbiAgICAgICAgbWV0YVxuICAgICAgfSlcbiAgICB9KTtcbiAgICB0aGlzLm5leHRTdHJva2UoKTtcbiAgfVxuXG4gIF9oYW5kbGVGYWlsdXJlKG1ldGEpIHtcbiAgICB2YXIgX3RoaXMkX29wdGlvbnMkb25NaXN0LCBfdGhpcyRfb3B0aW9ucztcblxuICAgIHRoaXMuX21pc3Rha2VzT25TdHJva2UgKz0gMTtcbiAgICB0aGlzLl90b3RhbE1pc3Rha2VzICs9IDE7XG4gICAgKF90aGlzJF9vcHRpb25zJG9uTWlzdCA9IChfdGhpcyRfb3B0aW9ucyA9IHRoaXMuX29wdGlvbnMpLm9uTWlzdGFrZSkgPT09IG51bGwgfHwgX3RoaXMkX29wdGlvbnMkb25NaXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRfb3B0aW9ucyRvbk1pc3QuY2FsbChfdGhpcyRfb3B0aW9ucywgdGhpcy5fZ2V0U3Ryb2tlRGF0YSh7XG4gICAgICBpc0NvcnJlY3Q6IGZhbHNlLFxuICAgICAgbWV0YVxuICAgIH0pKTtcbiAgfVxuXG4gIF9nZXRDdXJyZW50U3Ryb2tlKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFyYWN0ZXIuc3Ryb2tlc1t0aGlzLl9jdXJyZW50U3Ryb2tlSW5kZXhdO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxtKGVsbVR5cGUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBlbG1UeXBlKTtcbn1cbmZ1bmN0aW9uIGF0dHIoZWxtLCBuYW1lLCB2YWx1ZSkge1xuICBlbG0uc2V0QXR0cmlidXRlTlMobnVsbCwgbmFtZSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gYXR0cnMoZWxtLCBhdHRyc01hcCkge1xuICBPYmplY3Qua2V5cyhhdHRyc01hcCkuZm9yRWFjaChhdHRyTmFtZSA9PiBhdHRyKGVsbSwgYXR0ck5hbWUsIGF0dHJzTWFwW2F0dHJOYW1lXSkpO1xufSAvLyBpbnNwaXJlZCBieSBodHRwczovL3RhbGsub2JzZXJ2YWJsZWhxLmNvbS90L2hhbnppLXdyaXRlci1yZW5kZXJzLWluY29ycmVjdGx5LWluc2lkZS1hbi1vYnNlcnZhYmxlLW5vdGVib29rLW9uLWEtbW9iaWxlLWJyb3dzZXIvMTg5OFxuXG5mdW5jdGlvbiB1cmxJZFJlZihpZCkge1xuICBsZXQgcHJlZml4ID0gJyc7XG5cbiAgaWYgKHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaHJlZikge1xuICAgIHByZWZpeCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLnJlcGxhY2UoLyNbXiNdKiQvLCAnJykucmVwbGFjZSgvXCIvZ2ksICclMjInKTtcbiAgfVxuXG4gIHJldHVybiBgdXJsKFwiJHtwcmVmaXh9IyR7aWR9XCIpYDtcbn1cbmZ1bmN0aW9uIHJlbW92ZUVsbShlbG0pIHtcbiAgdmFyIF9lbG0kcGFyZW50Tm9kZTtcblxuICBlbG0gPT09IG51bGwgfHwgZWxtID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2VsbSRwYXJlbnROb2RlID0gZWxtLnBhcmVudE5vZGUpID09PSBudWxsIHx8IF9lbG0kcGFyZW50Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VsbSRwYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsbSk7XG59XG5cbmNsYXNzIFN0cm9rZVJlbmRlcmVyQmFzZSB7XG4gIGNvbnN0cnVjdG9yKHN0cm9rZSkge1xuICAgIHRoaXMuc3Ryb2tlID0gc3Ryb2tlO1xuICAgIHRoaXMuX3BhdGhMZW5ndGggPSBzdHJva2UuZ2V0TGVuZ3RoKCkgKyBTdHJva2VSZW5kZXJlckJhc2UuU1RST0tFX1dJRFRIIC8gMjtcbiAgfVxuXG4gIF9nZXRTdHJva2VEYXNob2Zmc2V0KGRpc3BsYXlQb3J0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhdGhMZW5ndGggKiAwLjk5OSAqICgxIC0gZGlzcGxheVBvcnRpb24pO1xuICB9XG5cbiAgX2dldENvbG9yKHtcbiAgICBzdHJva2VDb2xvcixcbiAgICByYWRpY2FsQ29sb3JcbiAgfSkge1xuICAgIHJldHVybiByYWRpY2FsQ29sb3IgJiYgdGhpcy5zdHJva2UuaXNJblJhZGljYWwgPyByYWRpY2FsQ29sb3IgOiBzdHJva2VDb2xvcjtcbiAgfVxuXG59XG5TdHJva2VSZW5kZXJlckJhc2UuU1RST0tFX1dJRFRIID0gMjAwO1xuXG5jb25zdCBTVFJPS0VfV0lEVEggPSAyMDA7XG4vKiogVGhpcyBpcyBhIHN0cm9rZSBjb21wb3NlZCBvZiBzZXZlcmFsIHN0cm9rZSBwYXJ0cyAqKi9cblxuY2xhc3MgU3Ryb2tlUmVuZGVyZXIgZXh0ZW5kcyBTdHJva2VSZW5kZXJlckJhc2Uge1xuICBjb25zdHJ1Y3RvcihzdHJva2UpIHtcbiAgICBzdXBlcihzdHJva2UpO1xuICAgIHRoaXMuX29sZFByb3BzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgbW91bnQodGFyZ2V0KSB7XG4gICAgdGhpcy5fYW5pbWF0aW9uUGF0aCA9IGNyZWF0ZUVsbSgncGF0aCcpO1xuICAgIHRoaXMuX2NsaXAgPSBjcmVhdGVFbG0oJ2NsaXBQYXRoJyk7XG4gICAgdGhpcy5fc3Ryb2tlUGF0aCA9IGNyZWF0ZUVsbSgncGF0aCcpO1xuICAgIGNvbnN0IG1hc2tJZCA9IGBtYXNrLSR7Y291bnRlcigpfWA7XG4gICAgYXR0cih0aGlzLl9jbGlwLCAnaWQnLCBtYXNrSWQpO1xuICAgIGF0dHIodGhpcy5fc3Ryb2tlUGF0aCwgJ2QnLCB0aGlzLnN0cm9rZS5wYXRoKTtcbiAgICB0aGlzLl9hbmltYXRpb25QYXRoLnN0eWxlLm9wYWNpdHkgPSAnMCc7XG4gICAgYXR0cih0aGlzLl9hbmltYXRpb25QYXRoLCAnY2xpcC1wYXRoJywgdXJsSWRSZWYobWFza0lkKSk7XG4gICAgY29uc3QgZXh0ZW5kZWRNYXNrUG9pbnRzID0gZXh0ZW5kU3RhcnQodGhpcy5zdHJva2UucG9pbnRzLCBTVFJPS0VfV0lEVEggLyAyKTtcbiAgICBhdHRyKHRoaXMuX2FuaW1hdGlvblBhdGgsICdkJywgZ2V0UGF0aFN0cmluZyhleHRlbmRlZE1hc2tQb2ludHMpKTtcbiAgICBhdHRycyh0aGlzLl9hbmltYXRpb25QYXRoLCB7XG4gICAgICBzdHJva2U6ICcjRkZGRkZGJyxcbiAgICAgICdzdHJva2Utd2lkdGgnOiBTVFJPS0VfV0lEVEgudG9TdHJpbmcoKSxcbiAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICdzdHJva2UtbGluZWNhcCc6ICdyb3VuZCcsXG4gICAgICAnc3Ryb2tlLWxpbmVqb2luJzogJ21pdGVyJyxcbiAgICAgICdzdHJva2UtZGFzaGFycmF5JzogYCR7dGhpcy5fcGF0aExlbmd0aH0sJHt0aGlzLl9wYXRoTGVuZ3RofWBcbiAgICB9KTtcblxuICAgIHRoaXMuX2NsaXAuYXBwZW5kQ2hpbGQodGhpcy5fc3Ryb2tlUGF0aCk7XG5cbiAgICB0YXJnZXQuZGVmcy5hcHBlbmRDaGlsZCh0aGlzLl9jbGlwKTtcbiAgICB0YXJnZXQuc3ZnLmFwcGVuZENoaWxkKHRoaXMuX2FuaW1hdGlvblBhdGgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmVuZGVyKHByb3BzKSB7XG4gICAgdmFyIF90aGlzJF9vbGRQcm9wcywgX3RoaXMkX29sZFByb3BzMjtcblxuICAgIGlmIChwcm9wcyA9PT0gdGhpcy5fb2xkUHJvcHMgfHwgIXRoaXMuX2FuaW1hdGlvblBhdGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMuZGlzcGxheVBvcnRpb24gIT09ICgoX3RoaXMkX29sZFByb3BzID0gdGhpcy5fb2xkUHJvcHMpID09PSBudWxsIHx8IF90aGlzJF9vbGRQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkX29sZFByb3BzLmRpc3BsYXlQb3J0aW9uKSkge1xuICAgICAgdGhpcy5fYW5pbWF0aW9uUGF0aC5zdHlsZS5zdHJva2VEYXNob2Zmc2V0ID0gdGhpcy5fZ2V0U3Ryb2tlRGFzaG9mZnNldChwcm9wcy5kaXNwbGF5UG9ydGlvbikudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb2xvciA9IHRoaXMuX2dldENvbG9yKHByb3BzKTtcblxuICAgIGlmICghdGhpcy5fb2xkUHJvcHMgfHwgY29sb3IgIT09IHRoaXMuX2dldENvbG9yKHRoaXMuX29sZFByb3BzKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICByLFxuICAgICAgICBnLFxuICAgICAgICBiLFxuICAgICAgICBhXG4gICAgICB9ID0gY29sb3I7XG4gICAgICBhdHRycyh0aGlzLl9hbmltYXRpb25QYXRoLCB7XG4gICAgICAgIHN0cm9rZTogYHJnYmEoJHtyfSwke2d9LCR7Yn0sJHthfSlgXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMub3BhY2l0eSAhPT0gKChfdGhpcyRfb2xkUHJvcHMyID0gdGhpcy5fb2xkUHJvcHMpID09PSBudWxsIHx8IF90aGlzJF9vbGRQcm9wczIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJF9vbGRQcm9wczIub3BhY2l0eSkpIHtcbiAgICAgIHRoaXMuX2FuaW1hdGlvblBhdGguc3R5bGUub3BhY2l0eSA9IHByb3BzLm9wYWNpdHkudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9vbGRQcm9wcyA9IHByb3BzO1xuICB9XG5cbn1cblxuY2xhc3MgQ2hhcmFjdGVyUmVuZGVyZXIge1xuICBjb25zdHJ1Y3RvcihjaGFyYWN0ZXIpIHtcbiAgICB0aGlzLl9vbGRQcm9wcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdHJva2VSZW5kZXJlcnMgPSBjaGFyYWN0ZXIuc3Ryb2tlcy5tYXAoc3Ryb2tlID0+IG5ldyBTdHJva2VSZW5kZXJlcihzdHJva2UpKTtcbiAgfVxuXG4gIG1vdW50KHRhcmdldCkge1xuICAgIGNvbnN0IHN1YlRhcmdldCA9IHRhcmdldC5jcmVhdGVTdWJSZW5kZXJUYXJnZXQoKTtcbiAgICB0aGlzLl9ncm91cCA9IHN1YlRhcmdldC5zdmc7XG5cbiAgICB0aGlzLl9zdHJva2VSZW5kZXJlcnMuZm9yRWFjaChzdHJva2VSZW5kZXJlciA9PiB7XG4gICAgICBzdHJva2VSZW5kZXJlci5tb3VudChzdWJUYXJnZXQpO1xuICAgIH0pO1xuICB9XG5cbiAgcmVuZGVyKHByb3BzKSB7XG4gICAgdmFyIF90aGlzJF9vbGRQcm9wcywgX3RoaXMkX29sZFByb3BzMztcblxuICAgIGlmIChwcm9wcyA9PT0gdGhpcy5fb2xkUHJvcHMgfHwgIXRoaXMuX2dyb3VwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgb3BhY2l0eSxcbiAgICAgIHN0cm9rZXMsXG4gICAgICBzdHJva2VDb2xvcixcbiAgICAgIHJhZGljYWxDb2xvciA9IG51bGxcbiAgICB9ID0gcHJvcHM7XG5cbiAgICBpZiAob3BhY2l0eSAhPT0gKChfdGhpcyRfb2xkUHJvcHMgPSB0aGlzLl9vbGRQcm9wcykgPT09IG51bGwgfHwgX3RoaXMkX29sZFByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRfb2xkUHJvcHMub3BhY2l0eSkpIHtcbiAgICAgIHRoaXMuX2dyb3VwLnN0eWxlLm9wYWNpdHkgPSBvcGFjaXR5LnRvU3RyaW5nKCk7IC8vIE1TIGJyb3dzZXJzIHNlZW0gdG8gaGF2ZSBhIGJ1ZyB3aGVyZSBpZiBTVkcgaXMgc2V0IHRvIGRpc3BsYXk6bm9uZSwgaXQgc29tZXRpbWVzIGJyZWFrcy5cbiAgICAgIC8vIE1vcmUgaW5mbzogaHR0cHM6Ly9naXRodWIuY29tL2NoYW5pbmQvaGFuemktd3JpdGVyL2lzc3Vlcy8xNjRcbiAgICAgIC8vIHRoaXMgaXMganVzdCBhIHBlcmYgaW1wcm92ZW1lbnQsIHNvIGRpc2FibGUgZm9yIE1TIGJyb3dzZXJzXG5cbiAgICAgIGlmICghaXNNc0Jyb3dzZXIpIHtcbiAgICAgICAgdmFyIF90aGlzJF9vbGRQcm9wczI7XG5cbiAgICAgICAgaWYgKG9wYWNpdHkgPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ncm91cC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9IGVsc2UgaWYgKCgoX3RoaXMkX29sZFByb3BzMiA9IHRoaXMuX29sZFByb3BzKSA9PT0gbnVsbCB8fCBfdGhpcyRfb2xkUHJvcHMyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRfb2xkUHJvcHMyLm9wYWNpdHkpID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZ3JvdXAuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2Rpc3BsYXknKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNvbG9yc0NoYW5nZWQgPSAhdGhpcy5fb2xkUHJvcHMgfHwgc3Ryb2tlQ29sb3IgIT09IHRoaXMuX29sZFByb3BzLnN0cm9rZUNvbG9yIHx8IHJhZGljYWxDb2xvciAhPT0gdGhpcy5fb2xkUHJvcHMucmFkaWNhbENvbG9yO1xuXG4gICAgaWYgKGNvbG9yc0NoYW5nZWQgfHwgc3Ryb2tlcyAhPT0gKChfdGhpcyRfb2xkUHJvcHMzID0gdGhpcy5fb2xkUHJvcHMpID09PSBudWxsIHx8IF90aGlzJF9vbGRQcm9wczMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJF9vbGRQcm9wczMuc3Ryb2tlcykpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fc3Ryb2tlUmVuZGVyZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBfdGhpcyRfb2xkUHJvcHM0O1xuXG4gICAgICAgIGlmICghY29sb3JzQ2hhbmdlZCAmJiAoX3RoaXMkX29sZFByb3BzNCA9IHRoaXMuX29sZFByb3BzKSAhPT0gbnVsbCAmJiBfdGhpcyRfb2xkUHJvcHM0ICE9PSB2b2lkIDAgJiYgX3RoaXMkX29sZFByb3BzNC5zdHJva2VzICYmIHN0cm9rZXNbaV0gPT09IHRoaXMuX29sZFByb3BzLnN0cm9rZXNbaV0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N0cm9rZVJlbmRlcmVyc1tpXS5yZW5kZXIoe1xuICAgICAgICAgIHN0cm9rZUNvbG9yLFxuICAgICAgICAgIHJhZGljYWxDb2xvcixcbiAgICAgICAgICBvcGFjaXR5OiBzdHJva2VzW2ldLm9wYWNpdHksXG4gICAgICAgICAgZGlzcGxheVBvcnRpb246IHN0cm9rZXNbaV0uZGlzcGxheVBvcnRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fb2xkUHJvcHMgPSBwcm9wcztcbiAgfVxuXG59XG5cbmNsYXNzIFVzZXJTdHJva2VSZW5kZXJlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX29sZFByb3BzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgbW91bnQodGFyZ2V0KSB7XG4gICAgdGhpcy5fcGF0aCA9IGNyZWF0ZUVsbSgncGF0aCcpO1xuICAgIHRhcmdldC5zdmcuYXBwZW5kQ2hpbGQodGhpcy5fcGF0aCk7XG4gIH1cblxuICByZW5kZXIocHJvcHMpIHtcbiAgICB2YXIgX3RoaXMkX29sZFByb3BzLCBfdGhpcyRfb2xkUHJvcHMyLCBfdGhpcyRfb2xkUHJvcHMzLCBfdGhpcyRfb2xkUHJvcHM0O1xuXG4gICAgaWYgKCF0aGlzLl9wYXRoIHx8IHByb3BzID09PSB0aGlzLl9vbGRQcm9wcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wcy5zdHJva2VDb2xvciAhPT0gKChfdGhpcyRfb2xkUHJvcHMgPSB0aGlzLl9vbGRQcm9wcykgPT09IG51bGwgfHwgX3RoaXMkX29sZFByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRfb2xkUHJvcHMuc3Ryb2tlQ29sb3IpIHx8IHByb3BzLnN0cm9rZVdpZHRoICE9PSAoKF90aGlzJF9vbGRQcm9wczIgPSB0aGlzLl9vbGRQcm9wcykgPT09IG51bGwgfHwgX3RoaXMkX29sZFByb3BzMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkX29sZFByb3BzMi5zdHJva2VXaWR0aCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcixcbiAgICAgICAgZyxcbiAgICAgICAgYixcbiAgICAgICAgYVxuICAgICAgfSA9IHByb3BzLnN0cm9rZUNvbG9yO1xuICAgICAgYXR0cnModGhpcy5fcGF0aCwge1xuICAgICAgICBmaWxsOiAnbm9uZScsXG4gICAgICAgIHN0cm9rZTogYHJnYmEoJHtyfSwke2d9LCR7Yn0sJHthfSlgLFxuICAgICAgICAnc3Ryb2tlLXdpZHRoJzogcHJvcHMuc3Ryb2tlV2lkdGgudG9TdHJpbmcoKSxcbiAgICAgICAgJ3N0cm9rZS1saW5lY2FwJzogJ3JvdW5kJyxcbiAgICAgICAgJ3N0cm9rZS1saW5lam9pbic6ICdyb3VuZCdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChwcm9wcy5vcGFjaXR5ICE9PSAoKF90aGlzJF9vbGRQcm9wczMgPSB0aGlzLl9vbGRQcm9wcykgPT09IG51bGwgfHwgX3RoaXMkX29sZFByb3BzMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkX29sZFByb3BzMy5vcGFjaXR5KSkge1xuICAgICAgYXR0cih0aGlzLl9wYXRoLCAnb3BhY2l0eScsIHByb3BzLm9wYWNpdHkudG9TdHJpbmcoKSk7XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLnBvaW50cyAhPT0gKChfdGhpcyRfb2xkUHJvcHM0ID0gdGhpcy5fb2xkUHJvcHMpID09PSBudWxsIHx8IF90aGlzJF9vbGRQcm9wczQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJF9vbGRQcm9wczQucG9pbnRzKSkge1xuICAgICAgYXR0cih0aGlzLl9wYXRoLCAnZCcsIGdldFBhdGhTdHJpbmcocHJvcHMucG9pbnRzKSk7XG4gICAgfVxuXG4gICAgdGhpcy5fb2xkUHJvcHMgPSBwcm9wcztcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgcmVtb3ZlRWxtKHRoaXMuX3BhdGgpO1xuICB9XG5cbn1cblxuY2xhc3MgSGFuemlXcml0ZXJSZW5kZXJlciB7XG4gIGNvbnN0cnVjdG9yKGNoYXJhY3RlciwgcG9zaXRpb25lcikge1xuICAgIHRoaXMuX2NoYXJhY3RlciA9IGNoYXJhY3RlcjtcbiAgICB0aGlzLl9wb3NpdGlvbmVyID0gcG9zaXRpb25lcjtcbiAgICB0aGlzLl9tYWluQ2hhclJlbmRlcmVyID0gbmV3IENoYXJhY3RlclJlbmRlcmVyKGNoYXJhY3Rlcik7XG4gICAgdGhpcy5fb3V0bGluZUNoYXJSZW5kZXJlciA9IG5ldyBDaGFyYWN0ZXJSZW5kZXJlcihjaGFyYWN0ZXIpO1xuICAgIHRoaXMuX2hpZ2hsaWdodENoYXJSZW5kZXJlciA9IG5ldyBDaGFyYWN0ZXJSZW5kZXJlcihjaGFyYWN0ZXIpO1xuICAgIHRoaXMuX3VzZXJTdHJva2VSZW5kZXJlcnMgPSB7fTtcbiAgfVxuXG4gIG1vdW50KHRhcmdldCkge1xuICAgIGNvbnN0IHBvc2l0aW9uZWRUYXJnZXQgPSB0YXJnZXQuY3JlYXRlU3ViUmVuZGVyVGFyZ2V0KCk7XG4gICAgY29uc3QgZ3JvdXAgPSBwb3NpdGlvbmVkVGFyZ2V0LnN2ZztcbiAgICBjb25zdCB7XG4gICAgICB4T2Zmc2V0LFxuICAgICAgeU9mZnNldCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHNjYWxlXG4gICAgfSA9IHRoaXMuX3Bvc2l0aW9uZXI7XG4gICAgYXR0cihncm91cCwgJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt4T2Zmc2V0fSwgJHtoZWlnaHQgLSB5T2Zmc2V0fSkgc2NhbGUoJHtzY2FsZX0sICR7LTEgKiBzY2FsZX0pYCk7XG5cbiAgICB0aGlzLl9vdXRsaW5lQ2hhclJlbmRlcmVyLm1vdW50KHBvc2l0aW9uZWRUYXJnZXQpO1xuXG4gICAgdGhpcy5fbWFpbkNoYXJSZW5kZXJlci5tb3VudChwb3NpdGlvbmVkVGFyZ2V0KTtcblxuICAgIHRoaXMuX2hpZ2hsaWdodENoYXJSZW5kZXJlci5tb3VudChwb3NpdGlvbmVkVGFyZ2V0KTtcblxuICAgIHRoaXMuX3Bvc2l0aW9uZWRUYXJnZXQgPSBwb3NpdGlvbmVkVGFyZ2V0O1xuICB9XG5cbiAgcmVuZGVyKHByb3BzKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWFpbixcbiAgICAgIG91dGxpbmUsXG4gICAgICBoaWdobGlnaHRcbiAgICB9ID0gcHJvcHMuY2hhcmFjdGVyO1xuICAgIGNvbnN0IHtcbiAgICAgIG91dGxpbmVDb2xvcixcbiAgICAgIHJhZGljYWxDb2xvcixcbiAgICAgIGhpZ2hsaWdodENvbG9yLFxuICAgICAgc3Ryb2tlQ29sb3IsXG4gICAgICBkcmF3aW5nV2lkdGgsXG4gICAgICBkcmF3aW5nQ29sb3JcbiAgICB9ID0gcHJvcHMub3B0aW9ucztcblxuICAgIHRoaXMuX291dGxpbmVDaGFyUmVuZGVyZXIucmVuZGVyKHtcbiAgICAgIG9wYWNpdHk6IG91dGxpbmUub3BhY2l0eSxcbiAgICAgIHN0cm9rZXM6IG91dGxpbmUuc3Ryb2tlcyxcbiAgICAgIHN0cm9rZUNvbG9yOiBvdXRsaW5lQ29sb3JcbiAgICB9KTtcblxuICAgIHRoaXMuX21haW5DaGFyUmVuZGVyZXIucmVuZGVyKHtcbiAgICAgIG9wYWNpdHk6IG1haW4ub3BhY2l0eSxcbiAgICAgIHN0cm9rZXM6IG1haW4uc3Ryb2tlcyxcbiAgICAgIHN0cm9rZUNvbG9yLFxuICAgICAgcmFkaWNhbENvbG9yOiByYWRpY2FsQ29sb3JcbiAgICB9KTtcblxuICAgIHRoaXMuX2hpZ2hsaWdodENoYXJSZW5kZXJlci5yZW5kZXIoe1xuICAgICAgb3BhY2l0eTogaGlnaGxpZ2h0Lm9wYWNpdHksXG4gICAgICBzdHJva2VzOiBoaWdobGlnaHQuc3Ryb2tlcyxcbiAgICAgIHN0cm9rZUNvbG9yOiBoaWdobGlnaHRDb2xvclxuICAgIH0pO1xuXG4gICAgY29uc3QgdXNlclN0cm9rZXMgPSBwcm9wcy51c2VyU3Ryb2tlcyB8fCB7fTtcblxuICAgIGZvciAoY29uc3QgdXNlclN0cm9rZUlkIGluIHRoaXMuX3VzZXJTdHJva2VSZW5kZXJlcnMpIHtcbiAgICAgIGlmICghdXNlclN0cm9rZXNbdXNlclN0cm9rZUlkXSkge1xuICAgICAgICB2YXIgX3RoaXMkX3VzZXJTdHJva2VSZW5kO1xuXG4gICAgICAgIChfdGhpcyRfdXNlclN0cm9rZVJlbmQgPSB0aGlzLl91c2VyU3Ryb2tlUmVuZGVyZXJzW3VzZXJTdHJva2VJZF0pID09PSBudWxsIHx8IF90aGlzJF91c2VyU3Ryb2tlUmVuZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkX3VzZXJTdHJva2VSZW5kLmRlc3Ryb3koKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3VzZXJTdHJva2VSZW5kZXJlcnNbdXNlclN0cm9rZUlkXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHVzZXJTdHJva2VJZCBpbiB1c2VyU3Ryb2tlcykge1xuICAgICAgY29uc3Qgc3Ryb2tlID0gdXNlclN0cm9rZXNbdXNlclN0cm9rZUlkXTtcblxuICAgICAgaWYgKCFzdHJva2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVzZXJTdHJva2VQcm9wcyA9IHtcbiAgICAgICAgc3Ryb2tlV2lkdGg6IGRyYXdpbmdXaWR0aCxcbiAgICAgICAgc3Ryb2tlQ29sb3I6IGRyYXdpbmdDb2xvcixcbiAgICAgICAgLi4uc3Ryb2tlXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzdHJva2VSZW5kZXJlciA9ICgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl91c2VyU3Ryb2tlUmVuZGVyZXJzW3VzZXJTdHJva2VJZF0pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdXNlclN0cm9rZVJlbmRlcmVyc1t1c2VyU3Ryb2tlSWRdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbmV3U3Ryb2tlUmVuZGVyZXIgPSBuZXcgVXNlclN0cm9rZVJlbmRlcmVyKCk7XG4gICAgICAgIG5ld1N0cm9rZVJlbmRlcmVyLm1vdW50KHRoaXMuX3Bvc2l0aW9uZWRUYXJnZXQpO1xuICAgICAgICB0aGlzLl91c2VyU3Ryb2tlUmVuZGVyZXJzW3VzZXJTdHJva2VJZF0gPSBuZXdTdHJva2VSZW5kZXJlcjtcbiAgICAgICAgcmV0dXJuIG5ld1N0cm9rZVJlbmRlcmVyO1xuICAgICAgfSkoKTtcblxuICAgICAgc3Ryb2tlUmVuZGVyZXIucmVuZGVyKHVzZXJTdHJva2VQcm9wcyk7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICByZW1vdmVFbG0odGhpcy5fcG9zaXRpb25lZFRhcmdldC5zdmcpO1xuICAgIHRoaXMuX3Bvc2l0aW9uZWRUYXJnZXQuZGVmcy5pbm5lckhUTUwgPSAnJztcbiAgfVxuXG59XG5cbi8qKiBHZW5lcmljIHJlbmRlciB0YXJnZXQgKi9cbmNsYXNzIFJlbmRlclRhcmdldEJhc2Uge1xuICBjb25zdHJ1Y3Rvcihub2RlKSB7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgfVxuXG4gIGFkZFBvaW50ZXJTdGFydExpc3RlbmVyKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGV2dCA9PiB7XG4gICAgICBjYWxsYmFjayh0aGlzLl9ldmVudGlmeShldnQsIHRoaXMuX2dldE1vdXNlUG9pbnQpKTtcbiAgICB9KTtcbiAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGV2dCA9PiB7XG4gICAgICBjYWxsYmFjayh0aGlzLl9ldmVudGlmeShldnQsIHRoaXMuX2dldFRvdWNoUG9pbnQpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGFkZFBvaW50ZXJNb3ZlTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZXZ0ID0+IHtcbiAgICAgIGNhbGxiYWNrKHRoaXMuX2V2ZW50aWZ5KGV2dCwgdGhpcy5fZ2V0TW91c2VQb2ludCkpO1xuICAgIH0pO1xuICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBldnQgPT4ge1xuICAgICAgY2FsbGJhY2sodGhpcy5fZXZlbnRpZnkoZXZ0LCB0aGlzLl9nZXRUb3VjaFBvaW50KSk7XG4gICAgfSk7XG4gIH1cblxuICBhZGRQb2ludGVyRW5kTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPOiBmaW5kIGEgd2F5IHRvIG5vdCBuZWVkIGdsb2JhbCBsaXN0ZW5lcnNcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgY2FsbGJhY2spO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgY2FsbGJhY2spO1xuICB9XG5cbiAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cblxuICB1cGRhdGVEaW1lbnNpb25zKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGAke3dpZHRofWApO1xuICAgIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGAke2hlaWdodH1gKTtcbiAgfVxuXG4gIF9ldmVudGlmeShldnQsIHBvaW50RnVuYykge1xuICAgIHJldHVybiB7XG4gICAgICBnZXRQb2ludDogKCkgPT4gcG9pbnRGdW5jLmNhbGwodGhpcywgZXZ0KSxcbiAgICAgIHByZXZlbnREZWZhdWx0OiAoKSA9PiBldnQucHJldmVudERlZmF1bHQoKVxuICAgIH07XG4gIH1cblxuICBfZ2V0TW91c2VQb2ludChldnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBsZWZ0LFxuICAgICAgdG9wXG4gICAgfSA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgeCA9IGV2dC5jbGllbnRYIC0gbGVmdDtcbiAgICBjb25zdCB5ID0gZXZ0LmNsaWVudFkgLSB0b3A7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgfVxuXG4gIF9nZXRUb3VjaFBvaW50KGV2dCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxlZnQsXG4gICAgICB0b3BcbiAgICB9ID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB4ID0gZXZ0LnRvdWNoZXNbMF0uY2xpZW50WCAtIGxlZnQ7XG4gICAgY29uc3QgeSA9IGV2dC50b3VjaGVzWzBdLmNsaWVudFkgLSB0b3A7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgfVxuXG59XG5cbmNsYXNzIFJlbmRlclRhcmdldCBleHRlbmRzIFJlbmRlclRhcmdldEJhc2Uge1xuICBjb25zdHJ1Y3RvcihzdmcsIGRlZnMpIHtcbiAgICBzdXBlcihzdmcpO1xuICAgIHRoaXMuc3ZnID0gc3ZnO1xuICAgIHRoaXMuZGVmcyA9IGRlZnM7XG5cbiAgICBpZiAoJ2NyZWF0ZVNWR1BvaW50JyBpbiBzdmcpIHtcbiAgICAgIHRoaXMuX3B0ID0gc3ZnLmNyZWF0ZVNWR1BvaW50KCk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGluaXQoZWxtT3JJZCwgd2lkdGggPSAnMTAwJScsIGhlaWdodCA9ICcxMDAlJykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSAoKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBlbG1PcklkID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxtT3JJZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbG1PcklkO1xuICAgIH0pKCk7XG5cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSGFuemlXcml0ZXIgdGFyZ2V0IGVsZW1lbnQgbm90IGZvdW5kOiAke2VsbU9ySWR9YCk7XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZVR5cGUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG5cbiAgICBjb25zdCBzdmcgPSAoKCkgPT4ge1xuICAgICAgaWYgKG5vZGVUeXBlID09PSAnU1ZHJyB8fCBub2RlVHlwZSA9PT0gJ0cnKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3ZnID0gY3JlYXRlRWxtKCdzdmcnKTtcbiAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChzdmcpO1xuICAgICAgICByZXR1cm4gc3ZnO1xuICAgICAgfVxuICAgIH0pKCk7XG5cbiAgICBhdHRycyhzdmcsIHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSk7XG4gICAgY29uc3QgZGVmcyA9IGNyZWF0ZUVsbSgnZGVmcycpO1xuICAgIHN2Zy5hcHBlbmRDaGlsZChkZWZzKTtcbiAgICByZXR1cm4gbmV3IFJlbmRlclRhcmdldChzdmcsIGRlZnMpO1xuICB9XG5cbiAgY3JlYXRlU3ViUmVuZGVyVGFyZ2V0KCkge1xuICAgIGNvbnN0IGdyb3VwID0gY3JlYXRlRWxtKCdnJyk7XG4gICAgdGhpcy5zdmcuYXBwZW5kQ2hpbGQoZ3JvdXApO1xuICAgIHJldHVybiBuZXcgUmVuZGVyVGFyZ2V0KGdyb3VwLCB0aGlzLmRlZnMpO1xuICB9XG5cbiAgX2dldE1vdXNlUG9pbnQoZXZ0KSB7XG4gICAgaWYgKHRoaXMuX3B0KSB7XG4gICAgICB0aGlzLl9wdC54ID0gZXZ0LmNsaWVudFg7XG4gICAgICB0aGlzLl9wdC55ID0gZXZ0LmNsaWVudFk7XG5cbiAgICAgIGlmICgnZ2V0U2NyZWVuQ1RNJyBpbiB0aGlzLm5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzJG5vZGUkZ2V0U2NyZWVuQztcblxuICAgICAgICBjb25zdCBsb2NhbFB0ID0gdGhpcy5fcHQubWF0cml4VHJhbnNmb3JtKChfdGhpcyRub2RlJGdldFNjcmVlbkMgPSB0aGlzLm5vZGUuZ2V0U2NyZWVuQ1RNKCkpID09PSBudWxsIHx8IF90aGlzJG5vZGUkZ2V0U2NyZWVuQyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkbm9kZSRnZXRTY3JlZW5DLmludmVyc2UoKSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBsb2NhbFB0LngsXG4gICAgICAgICAgeTogbG9jYWxQdC55XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLl9nZXRNb3VzZVBvaW50LmNhbGwodGhpcywgZXZ0KTtcbiAgfVxuXG4gIF9nZXRUb3VjaFBvaW50KGV2dCkge1xuICAgIGlmICh0aGlzLl9wdCkge1xuICAgICAgdGhpcy5fcHQueCA9IGV2dC50b3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICB0aGlzLl9wdC55ID0gZXZ0LnRvdWNoZXNbMF0uY2xpZW50WTtcblxuICAgICAgaWYgKCdnZXRTY3JlZW5DVE0nIGluIHRoaXMubm9kZSkge1xuICAgICAgICB2YXIgX3RoaXMkbm9kZSRnZXRTY3JlZW5DMjtcblxuICAgICAgICBjb25zdCBsb2NhbFB0ID0gdGhpcy5fcHQubWF0cml4VHJhbnNmb3JtKChfdGhpcyRub2RlJGdldFNjcmVlbkMyID0gdGhpcy5ub2RlLmdldFNjcmVlbkNUTSgpKSA9PT0gbnVsbCB8fCBfdGhpcyRub2RlJGdldFNjcmVlbkMyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRub2RlJGdldFNjcmVlbkMyLmludmVyc2UoKSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBsb2NhbFB0LngsXG4gICAgICAgICAgeTogbG9jYWxQdC55XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLl9nZXRUb3VjaFBvaW50KGV2dCk7XG4gIH1cblxufVxuXG52YXIgc3ZnUmVuZGVyZXIgPSB7XG4gIEhhbnppV3JpdGVyUmVuZGVyZXIsXG4gIGNyZWF0ZVJlbmRlclRhcmdldDogUmVuZGVyVGFyZ2V0LmluaXRcbn07XG5cbmNvbnN0IGRyYXdQYXRoID0gKGN0eCwgcG9pbnRzKSA9PiB7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY29uc3Qgc3RhcnQgPSBwb2ludHNbMF07XG4gIGNvbnN0IHJlbWFpbmluZ1BvaW50cyA9IHBvaW50cy5zbGljZSgxKTtcbiAgY3R4Lm1vdmVUbyhzdGFydC54LCBzdGFydC55KTtcblxuICBmb3IgKGNvbnN0IHBvaW50IG9mIHJlbWFpbmluZ1BvaW50cykge1xuICAgIGN0eC5saW5lVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gIH1cblxuICBjdHguc3Ryb2tlKCk7XG59O1xuLyoqXG4gKiBCcmVhayBhIHBhdGggc3RyaW5nIGludG8gYSBzZXJpZXMgb2YgY2FudmFzIHBhdGggY29tbWFuZHNcbiAqXG4gKiBOb3RlOiBvbmx5IHdvcmtzIHdpdGggdGhlIHN1YnNldCBvZiBTVkcgcGF0aHMgdXNlZCBieSBNYWtlTWVBSGFuemkgZGF0YVxuICogQHBhcmFtIHBhdGhTdHJpbmdcbiAqL1xuXG5jb25zdCBwYXRoU3RyaW5nVG9DYW52YXMgPSBwYXRoU3RyaW5nID0+IHtcbiAgY29uc3QgcGF0aFBhcnRzID0gcGF0aFN0cmluZy5zcGxpdCgvKF58XFxzKykoPz1bQS1aXSkvKS5maWx0ZXIocGFydCA9PiBwYXJ0ICE9PSAnICcpO1xuICBjb25zdCBjb21tYW5kcyA9IFtjdHggPT4gY3R4LmJlZ2luUGF0aCgpXTtcblxuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGF0aFBhcnRzKSB7XG4gICAgY29uc3QgW2NtZCwgLi4ucmF3UGFyYW1zXSA9IHBhcnQuc3BsaXQoL1xccysvKTtcbiAgICBjb25zdCBwYXJhbXMgPSByYXdQYXJhbXMubWFwKHBhcmFtID0+IHBhcnNlRmxvYXQocGFyYW0pKTtcblxuICAgIGlmIChjbWQgPT09ICdNJykge1xuICAgICAgY29tbWFuZHMucHVzaChjdHggPT4gY3R4Lm1vdmVUbyguLi5wYXJhbXMpKTtcbiAgICB9IGVsc2UgaWYgKGNtZCA9PT0gJ0wnKSB7XG4gICAgICBjb21tYW5kcy5wdXNoKGN0eCA9PiBjdHgubGluZVRvKC4uLnBhcmFtcykpO1xuICAgIH0gZWxzZSBpZiAoY21kID09PSAnQycpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goY3R4ID0+IGN0eC5iZXppZXJDdXJ2ZVRvKC4uLnBhcmFtcykpO1xuICAgIH0gZWxzZSBpZiAoY21kID09PSAnUScpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goY3R4ID0+IGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKC4uLnBhcmFtcykpO1xuICAgIH0gZWxzZSA7XG4gIH1cblxuICByZXR1cm4gY3R4ID0+IGNvbW1hbmRzLmZvckVhY2goY21kID0+IGNtZChjdHgpKTtcbn07XG5cbi8qKiB0aGlzIGlzIGEgc3Ryb2tlIGNvbXBvc2VkIG9mIHNldmVyYWwgc3Ryb2tlIHBhcnRzICovXG5cbmNsYXNzIFN0cm9rZVJlbmRlcmVyJDEgZXh0ZW5kcyBTdHJva2VSZW5kZXJlckJhc2Uge1xuICBjb25zdHJ1Y3RvcihzdHJva2UsIHVzZVBhdGgyRCA9IHRydWUpIHtcbiAgICBzdXBlcihzdHJva2UpO1xuXG4gICAgaWYgKHVzZVBhdGgyRCAmJiBQYXRoMkQpIHtcbiAgICAgIHRoaXMuX3BhdGgyRCA9IG5ldyBQYXRoMkQodGhpcy5zdHJva2UucGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3BhdGhDbWQgPSBwYXRoU3RyaW5nVG9DYW52YXModGhpcy5zdHJva2UucGF0aCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZXh0ZW5kZWRNYXNrUG9pbnRzID0gZXh0ZW5kU3RhcnQodGhpcy5zdHJva2UucG9pbnRzLCBTdHJva2VSZW5kZXJlckJhc2UuU1RST0tFX1dJRFRIIC8gMik7XG4gIH1cblxuICByZW5kZXIoY3R4LCBwcm9wcykge1xuICAgIGlmIChwcm9wcy5vcGFjaXR5IDwgMC4wNSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN0eC5zYXZlKCk7XG5cbiAgICBpZiAodGhpcy5fcGF0aDJEKSB7XG4gICAgICBjdHguY2xpcCh0aGlzLl9wYXRoMkQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3RoaXMkX3BhdGhDbWQ7XG5cbiAgICAgIChfdGhpcyRfcGF0aENtZCA9IHRoaXMuX3BhdGhDbWQpID09PSBudWxsIHx8IF90aGlzJF9wYXRoQ21kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRfcGF0aENtZC5jYWxsKHRoaXMsIGN0eCk7IC8vIHdlY2hhdCBidWdzIG91dCBpZiB0aGUgY2xpcCBwYXRoIGlzbid0IHN0cm9rZWQgb3IgZmlsbGVkXG5cbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDA7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHguY2xpcCgpO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIHIsXG4gICAgICBnLFxuICAgICAgYixcbiAgICAgIGFcbiAgICB9ID0gdGhpcy5fZ2V0Q29sb3IocHJvcHMpO1xuXG4gICAgY29uc3QgY29sb3IgPSBhID09PSAxID8gYHJnYigke3J9LCR7Z30sJHtifSlgIDogYHJnYigke3J9LCR7Z30sJHtifSwke2F9KWA7XG5cbiAgICBjb25zdCBkYXNoT2Zmc2V0ID0gdGhpcy5fZ2V0U3Ryb2tlRGFzaG9mZnNldChwcm9wcy5kaXNwbGF5UG9ydGlvbik7XG5cbiAgICBjdHguZ2xvYmFsQWxwaGEgPSBwcm9wcy5vcGFjaXR5O1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICBjdHgubGluZVdpZHRoID0gU3Ryb2tlUmVuZGVyZXJCYXNlLlNUUk9LRV9XSURUSDtcbiAgICBjdHgubGluZUNhcCA9ICdyb3VuZCc7XG4gICAgY3R4LmxpbmVKb2luID0gJ3JvdW5kJzsgLy8gd2VjaGF0IHNldHMgZGFzaE9mZnNldCBhcyBhIHNlY29uZCBwYXJhbSBoZXJlLiBTaG91bGQgYmUgaGFybWxlc3MgZm9yIGJyb3dzZXJzIHRvIGFkZCBoZXJlIHRvb1xuICAgIC8vIEB0cy1pZ25vcmVcblxuICAgIGN0eC5zZXRMaW5lRGFzaChbdGhpcy5fcGF0aExlbmd0aCwgdGhpcy5fcGF0aExlbmd0aF0sIGRhc2hPZmZzZXQpO1xuICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGRhc2hPZmZzZXQ7XG4gICAgZHJhd1BhdGgoY3R4LCB0aGlzLl9leHRlbmRlZE1hc2tQb2ludHMpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cblxufVxuXG5jbGFzcyBDaGFyYWN0ZXJSZW5kZXJlciQxIHtcbiAgY29uc3RydWN0b3IoY2hhcmFjdGVyKSB7XG4gICAgdGhpcy5fc3Ryb2tlUmVuZGVyZXJzID0gY2hhcmFjdGVyLnN0cm9rZXMubWFwKHN0cm9rZSA9PiBuZXcgU3Ryb2tlUmVuZGVyZXIkMShzdHJva2UpKTtcbiAgfVxuXG4gIHJlbmRlcihjdHgsIHByb3BzKSB7XG4gICAgaWYgKHByb3BzLm9wYWNpdHkgPCAwLjA1KSByZXR1cm47XG4gICAgY29uc3Qge1xuICAgICAgb3BhY2l0eSxcbiAgICAgIHN0cm9rZUNvbG9yLFxuICAgICAgcmFkaWNhbENvbG9yLFxuICAgICAgc3Ryb2tlc1xuICAgIH0gPSBwcm9wcztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fc3Ryb2tlUmVuZGVyZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9zdHJva2VSZW5kZXJlcnNbaV0ucmVuZGVyKGN0eCwge1xuICAgICAgICBzdHJva2VDb2xvcixcbiAgICAgICAgcmFkaWNhbENvbG9yLFxuICAgICAgICBvcGFjaXR5OiBzdHJva2VzW2ldLm9wYWNpdHkgKiBvcGFjaXR5LFxuICAgICAgICBkaXNwbGF5UG9ydGlvbjogc3Ryb2tlc1tpXS5kaXNwbGF5UG9ydGlvbiB8fCAwXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxufVxuXG5mdW5jdGlvbiByZW5kZXJVc2VyU3Ryb2tlKGN0eCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzLm9wYWNpdHkgPCAwLjA1KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIG9wYWNpdHksXG4gICAgc3Ryb2tlV2lkdGgsXG4gICAgc3Ryb2tlQ29sb3IsXG4gICAgcG9pbnRzXG4gIH0gPSBwcm9wcztcbiAgY29uc3Qge1xuICAgIHIsXG4gICAgZyxcbiAgICBiLFxuICAgIGFcbiAgfSA9IHN0cm9rZUNvbG9yO1xuICBjdHguc2F2ZSgpO1xuICBjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuICBjdHgubGluZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG4gIGN0eC5zdHJva2VTdHlsZSA9IGByZ2JhKCR7cn0sJHtnfSwke2J9LCR7YX0pYDtcbiAgY3R4LmxpbmVDYXAgPSAncm91bmQnO1xuICBjdHgubGluZUpvaW4gPSAncm91bmQnO1xuICBkcmF3UGF0aChjdHgsIHBvaW50cyk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5cbmNsYXNzIEhhbnppV3JpdGVyUmVuZGVyZXIkMSB7XG4gIGNvbnN0cnVjdG9yKGNoYXJhY3RlciwgcG9zaXRpb25lcikge1xuICAgIHRoaXMuZGVzdHJveSA9IG5vb3A7XG4gICAgdGhpcy5fY2hhcmFjdGVyID0gY2hhcmFjdGVyO1xuICAgIHRoaXMuX3Bvc2l0aW9uZXIgPSBwb3NpdGlvbmVyO1xuICAgIHRoaXMuX21haW5DaGFyUmVuZGVyZXIgPSBuZXcgQ2hhcmFjdGVyUmVuZGVyZXIkMShjaGFyYWN0ZXIpO1xuICAgIHRoaXMuX291dGxpbmVDaGFyUmVuZGVyZXIgPSBuZXcgQ2hhcmFjdGVyUmVuZGVyZXIkMShjaGFyYWN0ZXIpO1xuICAgIHRoaXMuX2hpZ2hsaWdodENoYXJSZW5kZXJlciA9IG5ldyBDaGFyYWN0ZXJSZW5kZXJlciQxKGNoYXJhY3Rlcik7XG4gIH1cblxuICBtb3VudCh0YXJnZXQpIHtcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gIH1cblxuICBfYW5pbWF0aW9uRnJhbWUoY2IpIHtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHNjYWxlLFxuICAgICAgeE9mZnNldCxcbiAgICAgIHlPZmZzZXRcbiAgICB9ID0gdGhpcy5fcG9zaXRpb25lcjtcblxuICAgIGNvbnN0IGN0eCA9IHRoaXMuX3RhcmdldC5nZXRDb250ZXh0KCk7XG5cbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zbGF0ZSh4T2Zmc2V0LCBoZWlnaHQgLSB5T2Zmc2V0KTtcbiAgICBjdHgudHJhbnNmb3JtKDEsIDAsIDAsIC0xLCAwLCAwKTtcbiAgICBjdHguc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgICBjYihjdHgpO1xuICAgIGN0eC5yZXN0b3JlKCk7IC8vIEB0cy1leHBlY3QtZXJyb3IgVmVyaWZ5IGlmIHRoaXMgaXMgc3RpbGwgbmVlZGVkIGZvciB0aGUgXCJ3ZWNoYXQgbWluaXByb2dyYW1cIi5cblxuICAgIGlmIChjdHguZHJhdykge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgY3R4LmRyYXcoKTtcbiAgICB9XG4gIH1cblxuICByZW5kZXIocHJvcHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBvdXRsaW5lLFxuICAgICAgbWFpbixcbiAgICAgIGhpZ2hsaWdodFxuICAgIH0gPSBwcm9wcy5jaGFyYWN0ZXI7XG4gICAgY29uc3Qge1xuICAgICAgb3V0bGluZUNvbG9yLFxuICAgICAgc3Ryb2tlQ29sb3IsXG4gICAgICByYWRpY2FsQ29sb3IsXG4gICAgICBoaWdobGlnaHRDb2xvcixcbiAgICAgIGRyYXdpbmdDb2xvcixcbiAgICAgIGRyYXdpbmdXaWR0aFxuICAgIH0gPSBwcm9wcy5vcHRpb25zO1xuXG4gICAgdGhpcy5fYW5pbWF0aW9uRnJhbWUoY3R4ID0+IHtcbiAgICAgIHRoaXMuX291dGxpbmVDaGFyUmVuZGVyZXIucmVuZGVyKGN0eCwge1xuICAgICAgICBvcGFjaXR5OiBvdXRsaW5lLm9wYWNpdHksXG4gICAgICAgIHN0cm9rZXM6IG91dGxpbmUuc3Ryb2tlcyxcbiAgICAgICAgc3Ryb2tlQ29sb3I6IG91dGxpbmVDb2xvclxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX21haW5DaGFyUmVuZGVyZXIucmVuZGVyKGN0eCwge1xuICAgICAgICBvcGFjaXR5OiBtYWluLm9wYWNpdHksXG4gICAgICAgIHN0cm9rZXM6IG1haW4uc3Ryb2tlcyxcbiAgICAgICAgc3Ryb2tlQ29sb3I6IHN0cm9rZUNvbG9yLFxuICAgICAgICByYWRpY2FsQ29sb3I6IHJhZGljYWxDb2xvclxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2hpZ2hsaWdodENoYXJSZW5kZXJlci5yZW5kZXIoY3R4LCB7XG4gICAgICAgIG9wYWNpdHk6IGhpZ2hsaWdodC5vcGFjaXR5LFxuICAgICAgICBzdHJva2VzOiBoaWdobGlnaHQuc3Ryb2tlcyxcbiAgICAgICAgc3Ryb2tlQ29sb3I6IGhpZ2hsaWdodENvbG9yXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdXNlclN0cm9rZXMgPSBwcm9wcy51c2VyU3Ryb2tlcyB8fCB7fTtcblxuICAgICAgZm9yIChjb25zdCB1c2VyU3Ryb2tlSWQgaW4gdXNlclN0cm9rZXMpIHtcbiAgICAgICAgY29uc3QgdXNlclN0cm9rZSA9IHVzZXJTdHJva2VzW3VzZXJTdHJva2VJZF07XG5cbiAgICAgICAgaWYgKHVzZXJTdHJva2UpIHtcbiAgICAgICAgICBjb25zdCB1c2VyU3Ryb2tlUHJvcHMgPSB7XG4gICAgICAgICAgICBzdHJva2VXaWR0aDogZHJhd2luZ1dpZHRoLFxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IGRyYXdpbmdDb2xvcixcbiAgICAgICAgICAgIC4uLnVzZXJTdHJva2VcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJlbmRlclVzZXJTdHJva2UoY3R4LCB1c2VyU3Ryb2tlUHJvcHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxufVxuXG5jbGFzcyBSZW5kZXJUYXJnZXQkMSBleHRlbmRzIFJlbmRlclRhcmdldEJhc2Uge1xuICBjb25zdHJ1Y3RvcihjYW52YXMpIHtcbiAgICBzdXBlcihjYW52YXMpO1xuICB9XG5cbiAgc3RhdGljIGluaXQoZWxtT3JJZCwgd2lkdGggPSAnMTAwJScsIGhlaWdodCA9ICcxMDAlJykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSAoKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBlbG1PcklkID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxtT3JJZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbG1PcklkO1xuICAgIH0pKCk7XG5cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSGFuemlXcml0ZXIgdGFyZ2V0IGVsZW1lbnQgbm90IGZvdW5kOiAke2VsbU9ySWR9YCk7XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZVR5cGUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG5cbiAgICBjb25zdCBjYW52YXMgPSAoKCkgPT4ge1xuICAgICAgaWYgKG5vZGVUeXBlID09PSAnQ0FOVkFTJykge1xuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICByZXR1cm4gY2FudmFzO1xuICAgIH0pKCk7XG5cbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHdpZHRoKTtcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBoZWlnaHQpO1xuICAgIHJldHVybiBuZXcgUmVuZGVyVGFyZ2V0JDEoY2FudmFzKTtcbiAgfVxuXG4gIGdldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZS5nZXRDb250ZXh0KCcyZCcpO1xuICB9XG5cbn1cblxudmFyIGNhbnZhc1JlbmRlcmVyID0ge1xuICBIYW56aVdyaXRlclJlbmRlcmVyOiBIYW56aVdyaXRlclJlbmRlcmVyJDEsXG4gIGNyZWF0ZVJlbmRlclRhcmdldDogUmVuZGVyVGFyZ2V0JDEuaW5pdFxufTtcblxuY29uc3QgVkVSU0lPTiA9ICcyLjAuMSc7XG5cbmNvbnN0IGdldENoYXJEYXRhVXJsID0gY2hhciA9PiBgaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9oYW56aS13cml0ZXItZGF0YUAke1ZFUlNJT059LyR7Y2hhcn0uanNvbmA7XG5cbmNvbnN0IGRlZmF1bHRDaGFyRGF0YUxvYWRlciA9IChjaGFyLCBvbkxvYWQsIG9uRXJyb3IpID0+IHtcbiAgLy8gbG9hZCBjaGFyIGRhdGEgZnJvbSBoYW56aXdyaXRlciBjZG4gKGN1cnJlbnRseSBob3N0ZWQgb24ganNkZWxpdnIpXG4gIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gIGlmICh4aHIub3ZlcnJpZGVNaW1lVHlwZSkge1xuICAgIC8vIElFIDkgYW5kIDEwIGRvbid0IHNlZW0gdG8gc3VwcG9ydCB0aGlzLi4uXG4gICAgeGhyLm92ZXJyaWRlTWltZVR5cGUoJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgfVxuXG4gIHhoci5vcGVuKCdHRVQnLCBnZXRDaGFyRGF0YVVybChjaGFyKSwgdHJ1ZSk7XG5cbiAgeGhyLm9uZXJyb3IgPSBldmVudCA9PiB7XG4gICAgb25FcnJvcih4aHIsIGV2ZW50KTtcbiAgfTtcblxuICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgIC8vIFRPRE86IGVycm9yIGhhbmRsaW5nXG4gICAgaWYgKHhoci5yZWFkeVN0YXRlICE9PSA0KSByZXR1cm47XG5cbiAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICBvbkxvYWQoSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KSk7XG4gICAgfSBlbHNlIGlmICh4aHIuc3RhdHVzICE9PSAwICYmIG9uRXJyb3IpIHtcbiAgICAgIG9uRXJyb3IoeGhyKTtcbiAgICB9XG4gIH07XG5cbiAgeGhyLnNlbmQobnVsbCk7XG59O1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgY2hhckRhdGFMb2FkZXI6IGRlZmF1bHRDaGFyRGF0YUxvYWRlcixcbiAgb25Mb2FkQ2hhckRhdGFFcnJvcjogbnVsbCxcbiAgb25Mb2FkQ2hhckRhdGFTdWNjZXNzOiBudWxsLFxuICBzaG93T3V0bGluZTogdHJ1ZSxcbiAgc2hvd0NoYXJhY3RlcjogdHJ1ZSxcbiAgcmVuZGVyZXI6ICdzdmcnLFxuICAvLyBwb3NpdGlvbmluZyBvcHRpb25zXG4gIHdpZHRoOiAwLFxuICBoZWlnaHQ6IDAsXG4gIHBhZGRpbmc6IDIwLFxuICAvLyBhbmltYXRpb24gb3B0aW9uc1xuICBzdHJva2VBbmltYXRpb25TcGVlZDogMSxcbiAgc3Ryb2tlRmFkZUR1cmF0aW9uOiA0MDAsXG4gIHN0cm9rZUhpZ2hsaWdodER1cmF0aW9uOiAyMDAsXG4gIHN0cm9rZUhpZ2hsaWdodFNwZWVkOiAyLFxuICBkZWxheUJldHdlZW5TdHJva2VzOiAxMDAwLFxuICBkZWxheUJldHdlZW5Mb29wczogMjAwMCxcbiAgLy8gY29sb3JzXG4gIHN0cm9rZUNvbG9yOiAnIzU1NScsXG4gIHJhZGljYWxDb2xvcjogbnVsbCxcbiAgaGlnaGxpZ2h0Q29sb3I6ICcjQUFGJyxcbiAgb3V0bGluZUNvbG9yOiAnI0RERCcsXG4gIGRyYXdpbmdDb2xvcjogJyMzMzMnLFxuICAvLyBxdWl6IG9wdGlvbnNcbiAgbGVuaWVuY3k6IDEsXG4gIHNob3dIaW50QWZ0ZXJNaXNzZXM6IDMsXG4gIGhpZ2hsaWdodE9uQ29tcGxldGU6IHRydWUsXG4gIGhpZ2hsaWdodENvbXBsZXRlQ29sb3I6IG51bGwsXG4gIG1hcmtTdHJva2VDb3JyZWN0QWZ0ZXJNaXNzZXM6IGZhbHNlLFxuICBhY2NlcHRCYWNrd2FyZHNTdHJva2VzOiBmYWxzZSxcbiAgcXVpelN0YXJ0U3Ryb2tlTnVtOiAwLFxuICBhdmVyYWdlRGlzdGFuY2VUaHJlc2hvbGQ6IDM1MCxcbiAgLy8gdW5kb2N1bWVudGVkIG9ic2N1cmUgb3B0aW9uc1xuICBkcmF3aW5nRmFkZUR1cmF0aW9uOiAzMDAsXG4gIGRyYXdpbmdXaWR0aDogNCxcbiAgc3Ryb2tlV2lkdGg6IDIsXG4gIG91dGxpbmVXaWR0aDogMixcbiAgcmVuZGVyZXJPdmVycmlkZToge31cbn07XG5cbmNsYXNzIExvYWRpbmdNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuX2xvYWRDb3VudGVyID0gMDtcbiAgICB0aGlzLl9pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAvKiogdXNlIHRoaXMgdG8gYXR0cmlidXRlIHRvIGRldGVybWluZSBpZiB0aGVyZSB3YXMgYSBwcm9ibGVtIHdpdGggbG9hZGluZyAqL1xuXG4gICAgdGhpcy5sb2FkaW5nRmFpbGVkID0gZmFsc2U7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICBfZGVib3VuY2VkTG9hZChjaGFyLCBjb3VudCkge1xuICAgIC8vIHRoZXNlIHdyYXBwZXJzIGlnbm9yZSBhbGwgcmVzcG9uc2VzIGV4Y2VwdCB0aGUgbW9zdCByZWNlbnQuXG4gICAgY29uc3Qgd3JhcHBlZFJlc29sdmUgPSBkYXRhID0+IHtcbiAgICAgIGlmIChjb3VudCA9PT0gdGhpcy5fbG9hZENvdW50ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzJF9yZXNvbHZlO1xuXG4gICAgICAgIChfdGhpcyRfcmVzb2x2ZSA9IHRoaXMuX3Jlc29sdmUpID09PSBudWxsIHx8IF90aGlzJF9yZXNvbHZlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRfcmVzb2x2ZS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCB3cmFwcGVkUmVqZWN0ID0gcmVhc29uID0+IHtcbiAgICAgIGlmIChjb3VudCA9PT0gdGhpcy5fbG9hZENvdW50ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzJF9yZWplY3Q7XG5cbiAgICAgICAgKF90aGlzJF9yZWplY3QgPSB0aGlzLl9yZWplY3QpID09PSBudWxsIHx8IF90aGlzJF9yZWplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJF9yZWplY3QuY2FsbCh0aGlzLCByZWFzb24pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCByZXR1cm5lZERhdGEgPSB0aGlzLl9vcHRpb25zLmNoYXJEYXRhTG9hZGVyKGNoYXIsIHdyYXBwZWRSZXNvbHZlLCB3cmFwcGVkUmVqZWN0KTtcblxuICAgIGlmIChyZXR1cm5lZERhdGEpIHtcbiAgICAgIGlmICgndGhlbicgaW4gcmV0dXJuZWREYXRhKSB7XG4gICAgICAgIHJldHVybmVkRGF0YS50aGVuKHdyYXBwZWRSZXNvbHZlKS5jYXRjaCh3cmFwcGVkUmVqZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyYXBwZWRSZXNvbHZlKHJldHVybmVkRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3NldHVwTG9hZGluZ1Byb21pc2UoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pLnRoZW4oZGF0YSA9PiB7XG4gICAgICB2YXIgX3RoaXMkX29wdGlvbnMkb25Mb2FkLCBfdGhpcyRfb3B0aW9ucztcblxuICAgICAgdGhpcy5faXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICAoX3RoaXMkX29wdGlvbnMkb25Mb2FkID0gKF90aGlzJF9vcHRpb25zID0gdGhpcy5fb3B0aW9ucykub25Mb2FkQ2hhckRhdGFTdWNjZXNzKSA9PT0gbnVsbCB8fCBfdGhpcyRfb3B0aW9ucyRvbkxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJF9vcHRpb25zJG9uTG9hZC5jYWxsKF90aGlzJF9vcHRpb25zLCBkYXRhKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLl9pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMubG9hZGluZ0ZhaWxlZCA9IHRydWU7IC8vIElmIHRoZSB1c2VyIGhhcyBwcm92aWRlZCBhbiBcIm9uTG9hZENoYXJEYXRhRXJyb3JcIiwgY2FsbCB0aGlzIGZ1bmN0aW9uXG4gICAgICAvLyBPdGhlcndpc2UsIHRocm93IHRoZSBwcm9taXNlXG5cbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLm9uTG9hZENoYXJEYXRhRXJyb3IpIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkxvYWRDaGFyRGF0YUVycm9yKHJlYXNvbik7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBJZiBlcnJvciBjYWxsYmFjayB3YXNuJ3QgcHJvdmlkZWQsIHRocm93IGFuIGVycm9yIHNvIHRoZSBkZXZlbG9wZXIgd2lsbCBiZSBhd2FyZSBzb21ldGhpbmcgd2VudCB3cm9uZ1xuXG5cbiAgICAgIGlmIChyZWFzb24gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgY2hhciBkYXRhIGZvciAke3RoaXMuX2xvYWRpbmdDaGFyfWApO1xuICAgICAgZXJyLnJlYXNvbiA9IHJlYXNvbjtcbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbiAgfVxuXG4gIGxvYWRDaGFyRGF0YShjaGFyKSB7XG4gICAgdGhpcy5fbG9hZGluZ0NoYXIgPSBjaGFyO1xuXG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuX3NldHVwTG9hZGluZ1Byb21pc2UoKTtcblxuICAgIHRoaXMubG9hZGluZ0ZhaWxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2lzTG9hZGluZyA9IHRydWU7XG4gICAgdGhpcy5fbG9hZENvdW50ZXIrKztcblxuICAgIHRoaXMuX2RlYm91bmNlZExvYWQoY2hhciwgdGhpcy5fbG9hZENvdW50ZXIpO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxufVxuXG5jbGFzcyBIYW56aVdyaXRlciB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIEhhbnppV3JpdGVyUmVuZGVyZXIsXG4gICAgICBjcmVhdGVSZW5kZXJUYXJnZXRcbiAgICB9ID0gb3B0aW9ucy5yZW5kZXJlciA9PT0gJ2NhbnZhcycgPyBjYW52YXNSZW5kZXJlciA6IHN2Z1JlbmRlcmVyO1xuICAgIGNvbnN0IHJlbmRlcmVyT3ZlcnJpZGUgPSBvcHRpb25zLnJlbmRlcmVyT3ZlcnJpZGUgfHwge307XG4gICAgdGhpcy5fcmVuZGVyZXIgPSB7XG4gICAgICBIYW56aVdyaXRlclJlbmRlcmVyOiByZW5kZXJlck92ZXJyaWRlLkhhbnppV3JpdGVyUmVuZGVyZXIgfHwgSGFuemlXcml0ZXJSZW5kZXJlcixcbiAgICAgIGNyZWF0ZVJlbmRlclRhcmdldDogcmVuZGVyZXJPdmVycmlkZS5jcmVhdGVSZW5kZXJUYXJnZXQgfHwgY3JlYXRlUmVuZGVyVGFyZ2V0XG4gICAgfTsgLy8gd2VjaGF0IG1pbmlwcm9ncmFtIGNvbXBvbmVudCBuZWVkcyBkaXJlY3QgYWNjZXNzIHRvIHRoZSByZW5kZXIgdGFyZ2V0LCBzbyB0aGlzIGlzIHB1YmxpY1xuXG4gICAgdGhpcy50YXJnZXQgPSB0aGlzLl9yZW5kZXJlci5jcmVhdGVSZW5kZXJUYXJnZXQoZWxlbWVudCwgb3B0aW9ucy53aWR0aCwgb3B0aW9ucy5oZWlnaHQpO1xuICAgIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9hc3NpZ25PcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuX2xvYWRpbmdNYW5hZ2VyID0gbmV3IExvYWRpbmdNYW5hZ2VyKHRoaXMuX29wdGlvbnMpO1xuXG4gICAgdGhpcy5fc2V0dXBMaXN0ZW5lcnMoKTtcbiAgfVxuICAvKiogTWFpbiBlbnRyeSBwb2ludCAqL1xuXG5cbiAgc3RhdGljIGNyZWF0ZShlbGVtZW50LCBjaGFyYWN0ZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB3cml0ZXIgPSBuZXcgSGFuemlXcml0ZXIoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgd3JpdGVyLnNldENoYXJhY3RlcihjaGFyYWN0ZXIpO1xuICAgIHJldHVybiB3cml0ZXI7XG4gIH1cblxuICBzdGF0aWMgbG9hZENoYXJhY3RlckRhdGEoY2hhcmFjdGVyLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBsb2FkaW5nTWFuYWdlciA9ICgoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIF9sb2FkaW5nTWFuYWdlcixcbiAgICAgICAgX2xvYWRpbmdPcHRpb25zXG4gICAgICB9ID0gSGFuemlXcml0ZXI7XG5cbiAgICAgIGlmICgoX2xvYWRpbmdNYW5hZ2VyID09PSBudWxsIHx8IF9sb2FkaW5nTWFuYWdlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2xvYWRpbmdNYW5hZ2VyLl9sb2FkaW5nQ2hhcikgPT09IGNoYXJhY3RlciAmJiBfbG9hZGluZ09wdGlvbnMgPT09IG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9sb2FkaW5nTWFuYWdlcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBMb2FkaW5nTWFuYWdlcih7IC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KTtcbiAgICB9KSgpO1xuXG4gICAgSGFuemlXcml0ZXIuX2xvYWRpbmdNYW5hZ2VyID0gbG9hZGluZ01hbmFnZXI7XG4gICAgSGFuemlXcml0ZXIuX2xvYWRpbmdPcHRpb25zID0gb3B0aW9ucztcbiAgICByZXR1cm4gbG9hZGluZ01hbmFnZXIubG9hZENoYXJEYXRhKGNoYXJhY3Rlcik7XG4gIH1cblxuICBzdGF0aWMgZ2V0U2NhbGluZ1RyYW5zZm9ybSh3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nID0gMCkge1xuICAgIGNvbnN0IHBvc2l0aW9uZXIgPSBuZXcgUG9zaXRpb25lcih7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHBhZGRpbmdcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcG9zaXRpb25lci54T2Zmc2V0LFxuICAgICAgeTogcG9zaXRpb25lci55T2Zmc2V0LFxuICAgICAgc2NhbGU6IHBvc2l0aW9uZXIuc2NhbGUsXG4gICAgICB0cmFuc2Zvcm06IHRyaW0oYFxuICAgICAgICB0cmFuc2xhdGUoJHtwb3NpdGlvbmVyLnhPZmZzZXR9LCAke3Bvc2l0aW9uZXIuaGVpZ2h0IC0gcG9zaXRpb25lci55T2Zmc2V0fSlcbiAgICAgICAgc2NhbGUoJHtwb3NpdGlvbmVyLnNjYWxlfSwgJHstMSAqIHBvc2l0aW9uZXIuc2NhbGV9KVxuICAgICAgYCkucmVwbGFjZSgvXFxzKy9nLCAnICcpXG4gICAgfTtcbiAgfVxuXG4gIHNob3dDaGFyYWN0ZXIob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fb3B0aW9ucy5zaG93Q2hhcmFjdGVyID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGEoKCkgPT4ge1xuICAgICAgdmFyIF90aGlzJF9yZW5kZXJTdGF0ZTtcblxuICAgICAgcmV0dXJuIChfdGhpcyRfcmVuZGVyU3RhdGUgPSB0aGlzLl9yZW5kZXJTdGF0ZSkgPT09IG51bGwgfHwgX3RoaXMkX3JlbmRlclN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRfcmVuZGVyU3RhdGUucnVuKHNob3dDaGFyYWN0ZXIoJ21haW4nLCB0aGlzLl9jaGFyYWN0ZXIsIHR5cGVvZiBvcHRpb25zLmR1cmF0aW9uID09PSAnbnVtYmVyJyA/IG9wdGlvbnMuZHVyYXRpb24gOiB0aGlzLl9vcHRpb25zLnN0cm9rZUZhZGVEdXJhdGlvbikpLnRoZW4ocmVzID0+IHtcbiAgICAgICAgdmFyIF9vcHRpb25zJG9uQ29tcGxldGU7XG5cbiAgICAgICAgKF9vcHRpb25zJG9uQ29tcGxldGUgPSBvcHRpb25zLm9uQ29tcGxldGUpID09PSBudWxsIHx8IF9vcHRpb25zJG9uQ29tcGxldGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb25zJG9uQ29tcGxldGUuY2FsbChvcHRpb25zLCByZXMpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBoaWRlQ2hhcmFjdGVyKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX29wdGlvbnMuc2hvd0NoYXJhY3RlciA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0YSgoKSA9PiB7XG4gICAgICB2YXIgX3RoaXMkX3JlbmRlclN0YXRlMjtcblxuICAgICAgcmV0dXJuIChfdGhpcyRfcmVuZGVyU3RhdGUyID0gdGhpcy5fcmVuZGVyU3RhdGUpID09PSBudWxsIHx8IF90aGlzJF9yZW5kZXJTdGF0ZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJF9yZW5kZXJTdGF0ZTIucnVuKGhpZGVDaGFyYWN0ZXIoJ21haW4nLCB0aGlzLl9jaGFyYWN0ZXIsIHR5cGVvZiBvcHRpb25zLmR1cmF0aW9uID09PSAnbnVtYmVyJyA/IG9wdGlvbnMuZHVyYXRpb24gOiB0aGlzLl9vcHRpb25zLnN0cm9rZUZhZGVEdXJhdGlvbikpLnRoZW4ocmVzID0+IHtcbiAgICAgICAgdmFyIF9vcHRpb25zJG9uQ29tcGxldGUyO1xuXG4gICAgICAgIChfb3B0aW9ucyRvbkNvbXBsZXRlMiA9IG9wdGlvbnMub25Db21wbGV0ZSkgPT09IG51bGwgfHwgX29wdGlvbnMkb25Db21wbGV0ZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb25zJG9uQ29tcGxldGUyLmNhbGwob3B0aW9ucywgcmVzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgYW5pbWF0ZUNoYXJhY3RlcihvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmNhbmNlbFF1aXooKTtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGEoKCkgPT4ge1xuICAgICAgdmFyIF90aGlzJF9yZW5kZXJTdGF0ZTM7XG5cbiAgICAgIHJldHVybiAoX3RoaXMkX3JlbmRlclN0YXRlMyA9IHRoaXMuX3JlbmRlclN0YXRlKSA9PT0gbnVsbCB8fCBfdGhpcyRfcmVuZGVyU3RhdGUzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRfcmVuZGVyU3RhdGUzLnJ1bihhbmltYXRlQ2hhcmFjdGVyKCdtYWluJywgdGhpcy5fY2hhcmFjdGVyLCB0aGlzLl9vcHRpb25zLnN0cm9rZUZhZGVEdXJhdGlvbiwgdGhpcy5fb3B0aW9ucy5zdHJva2VBbmltYXRpb25TcGVlZCwgdGhpcy5fb3B0aW9ucy5kZWxheUJldHdlZW5TdHJva2VzKSkudGhlbihyZXMgPT4ge1xuICAgICAgICB2YXIgX29wdGlvbnMkb25Db21wbGV0ZTM7XG5cbiAgICAgICAgKF9vcHRpb25zJG9uQ29tcGxldGUzID0gb3B0aW9ucy5vbkNvbXBsZXRlKSA9PT0gbnVsbCB8fCBfb3B0aW9ucyRvbkNvbXBsZXRlMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdGlvbnMkb25Db21wbGV0ZTMuY2FsbChvcHRpb25zLCByZXMpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBhbmltYXRlU3Ryb2tlKHN0cm9rZU51bSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5jYW5jZWxRdWl6KCk7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRhKCgpID0+IHtcbiAgICAgIHZhciBfdGhpcyRfcmVuZGVyU3RhdGU0O1xuXG4gICAgICByZXR1cm4gKF90aGlzJF9yZW5kZXJTdGF0ZTQgPSB0aGlzLl9yZW5kZXJTdGF0ZSkgPT09IG51bGwgfHwgX3RoaXMkX3JlbmRlclN0YXRlNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkX3JlbmRlclN0YXRlNC5ydW4oYW5pbWF0ZVNpbmdsZVN0cm9rZSgnbWFpbicsIHRoaXMuX2NoYXJhY3RlciwgZml4SW5kZXgoc3Ryb2tlTnVtLCB0aGlzLl9jaGFyYWN0ZXIuc3Ryb2tlcy5sZW5ndGgpLCB0aGlzLl9vcHRpb25zLnN0cm9rZUFuaW1hdGlvblNwZWVkKSkudGhlbihyZXMgPT4ge1xuICAgICAgICB2YXIgX29wdGlvbnMkb25Db21wbGV0ZTQ7XG5cbiAgICAgICAgKF9vcHRpb25zJG9uQ29tcGxldGU0ID0gb3B0aW9ucy5vbkNvbXBsZXRlKSA9PT0gbnVsbCB8fCBfb3B0aW9ucyRvbkNvbXBsZXRlNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdGlvbnMkb25Db21wbGV0ZTQuY2FsbChvcHRpb25zLCByZXMpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBoaWdobGlnaHRTdHJva2Uoc3Ryb2tlTnVtLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBwcm9taXNlID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9jaGFyYWN0ZXIgfHwgIXRoaXMuX3JlbmRlclN0YXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclN0YXRlLnJ1bihoaWdobGlnaHRTdHJva2Uoc2VsZWN0SW5kZXgodGhpcy5fY2hhcmFjdGVyLnN0cm9rZXMsIHN0cm9rZU51bSksIGNvbG9yU3RyaW5nVG9WYWxzKHRoaXMuX29wdGlvbnMuaGlnaGxpZ2h0Q29sb3IpLCB0aGlzLl9vcHRpb25zLnN0cm9rZUhpZ2hsaWdodFNwZWVkKSkudGhlbihyZXMgPT4ge1xuICAgICAgICB2YXIgX29wdGlvbnMkb25Db21wbGV0ZTU7XG5cbiAgICAgICAgKF9vcHRpb25zJG9uQ29tcGxldGU1ID0gb3B0aW9ucy5vbkNvbXBsZXRlKSA9PT0gbnVsbCB8fCBfb3B0aW9ucyRvbkNvbXBsZXRlNSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdGlvbnMkb25Db21wbGV0ZTUuY2FsbChvcHRpb25zLCByZXMpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLl93aXRoRGF0YShwcm9taXNlKTtcbiAgfVxuXG4gIGFzeW5jIGxvb3BDaGFyYWN0ZXJBbmltYXRpb24oKSB7XG4gICAgdGhpcy5jYW5jZWxRdWl6KCk7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRhKCgpID0+IHRoaXMuX3JlbmRlclN0YXRlLnJ1bihhbmltYXRlQ2hhcmFjdGVyTG9vcCgnbWFpbicsIHRoaXMuX2NoYXJhY3RlciwgdGhpcy5fb3B0aW9ucy5zdHJva2VGYWRlRHVyYXRpb24sIHRoaXMuX29wdGlvbnMuc3Ryb2tlQW5pbWF0aW9uU3BlZWQsIHRoaXMuX29wdGlvbnMuZGVsYXlCZXR3ZWVuU3Ryb2tlcywgdGhpcy5fb3B0aW9ucy5kZWxheUJldHdlZW5Mb29wcyksIHtcbiAgICAgIGxvb3A6IHRydWVcbiAgICB9KSk7XG4gIH1cblxuICBwYXVzZUFuaW1hdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGEoKCkgPT4ge1xuICAgICAgdmFyIF90aGlzJF9yZW5kZXJTdGF0ZTU7XG5cbiAgICAgIHJldHVybiAoX3RoaXMkX3JlbmRlclN0YXRlNSA9IHRoaXMuX3JlbmRlclN0YXRlKSA9PT0gbnVsbCB8fCBfdGhpcyRfcmVuZGVyU3RhdGU1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRfcmVuZGVyU3RhdGU1LnBhdXNlQWxsKCk7XG4gICAgfSk7XG4gIH1cblxuICByZXN1bWVBbmltYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRhKCgpID0+IHtcbiAgICAgIHZhciBfdGhpcyRfcmVuZGVyU3RhdGU2O1xuXG4gICAgICByZXR1cm4gKF90aGlzJF9yZW5kZXJTdGF0ZTYgPSB0aGlzLl9yZW5kZXJTdGF0ZSkgPT09IG51bGwgfHwgX3RoaXMkX3JlbmRlclN0YXRlNiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkX3JlbmRlclN0YXRlNi5yZXN1bWVBbGwoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHNob3dPdXRsaW5lKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX29wdGlvbnMuc2hvd091dGxpbmUgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0YSgoKSA9PiB7XG4gICAgICB2YXIgX3RoaXMkX3JlbmRlclN0YXRlNztcblxuICAgICAgcmV0dXJuIChfdGhpcyRfcmVuZGVyU3RhdGU3ID0gdGhpcy5fcmVuZGVyU3RhdGUpID09PSBudWxsIHx8IF90aGlzJF9yZW5kZXJTdGF0ZTcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJF9yZW5kZXJTdGF0ZTcucnVuKHNob3dDaGFyYWN0ZXIoJ291dGxpbmUnLCB0aGlzLl9jaGFyYWN0ZXIsIHR5cGVvZiBvcHRpb25zLmR1cmF0aW9uID09PSAnbnVtYmVyJyA/IG9wdGlvbnMuZHVyYXRpb24gOiB0aGlzLl9vcHRpb25zLnN0cm9rZUZhZGVEdXJhdGlvbikpLnRoZW4ocmVzID0+IHtcbiAgICAgICAgdmFyIF9vcHRpb25zJG9uQ29tcGxldGU2O1xuXG4gICAgICAgIChfb3B0aW9ucyRvbkNvbXBsZXRlNiA9IG9wdGlvbnMub25Db21wbGV0ZSkgPT09IG51bGwgfHwgX29wdGlvbnMkb25Db21wbGV0ZTYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb25zJG9uQ29tcGxldGU2LmNhbGwob3B0aW9ucywgcmVzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgaGlkZU91dGxpbmUob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fb3B0aW9ucy5zaG93T3V0bGluZSA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0YSgoKSA9PiB7XG4gICAgICB2YXIgX3RoaXMkX3JlbmRlclN0YXRlODtcblxuICAgICAgcmV0dXJuIChfdGhpcyRfcmVuZGVyU3RhdGU4ID0gdGhpcy5fcmVuZGVyU3RhdGUpID09PSBudWxsIHx8IF90aGlzJF9yZW5kZXJTdGF0ZTggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJF9yZW5kZXJTdGF0ZTgucnVuKGhpZGVDaGFyYWN0ZXIoJ291dGxpbmUnLCB0aGlzLl9jaGFyYWN0ZXIsIHR5cGVvZiBvcHRpb25zLmR1cmF0aW9uID09PSAnbnVtYmVyJyA/IG9wdGlvbnMuZHVyYXRpb24gOiB0aGlzLl9vcHRpb25zLnN0cm9rZUZhZGVEdXJhdGlvbikpLnRoZW4ocmVzID0+IHtcbiAgICAgICAgdmFyIF9vcHRpb25zJG9uQ29tcGxldGU3O1xuXG4gICAgICAgIChfb3B0aW9ucyRvbkNvbXBsZXRlNyA9IG9wdGlvbnMub25Db21wbGV0ZSkgPT09IG51bGwgfHwgX29wdGlvbnMkb25Db21wbGV0ZTcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb25zJG9uQ29tcGxldGU3LmNhbGwob3B0aW9ucywgcmVzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKiBVcGRhdGVzIHRoZSBzaXplIG9mIHRoZSB3cml0ZXIgaW5zdGFuY2Ugd2l0aG91dCByZXNldHRpbmcgcmVuZGVyIHN0YXRlICovXG5cblxuICB1cGRhdGVEaW1lbnNpb25zKHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgcGFkZGluZ1xuICB9KSB7XG4gICAgaWYgKHdpZHRoICE9PSB1bmRlZmluZWQpIHRoaXMuX29wdGlvbnMud2lkdGggPSB3aWR0aDtcbiAgICBpZiAoaGVpZ2h0ICE9PSB1bmRlZmluZWQpIHRoaXMuX29wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGlmIChwYWRkaW5nICE9PSB1bmRlZmluZWQpIHRoaXMuX29wdGlvbnMucGFkZGluZyA9IHBhZGRpbmc7XG4gICAgdGhpcy50YXJnZXQudXBkYXRlRGltZW5zaW9ucyh0aGlzLl9vcHRpb25zLndpZHRoLCB0aGlzLl9vcHRpb25zLmhlaWdodCk7IC8vIGlmIHRoZXJlJ3MgYWxyZWFkeSBhIGNoYXJhY3RlciBkcmF3biwgZGVzdHJveSBhbmQgcmVjcmVhdGUgdGhlIHJlbmRlcmVyIGluIHRoZSBzYW1lIHN0YXRlXG5cbiAgICBpZiAodGhpcy5fY2hhcmFjdGVyICYmIHRoaXMuX3JlbmRlclN0YXRlICYmIHRoaXMuX2hhbnppV3JpdGVyUmVuZGVyZXIgJiYgdGhpcy5fcG9zaXRpb25lcikge1xuICAgICAgdGhpcy5faGFuemlXcml0ZXJSZW5kZXJlci5kZXN0cm95KCk7XG5cbiAgICAgIGNvbnN0IGhhbnppV3JpdGVyUmVuZGVyZXIgPSB0aGlzLl9pbml0QW5kTW91bnRIYW56aVdyaXRlclJlbmRlcmVyKHRoaXMuX2NoYXJhY3Rlcik7IC8vIFRPRE86IHRoaXMgc2hvdWxkIHByb2JhYmx5IGltcGxlbWVudCBFdmVudEVtaXR0ZXIgaW5zdGVhZCBvZiBtYW51YWxseSB0cmFja2luZyB1cGRhdGVzIGxpa2UgdGhpc1xuXG5cbiAgICAgIHRoaXMuX3JlbmRlclN0YXRlLm92ZXJ3cml0ZU9uU3RhdGVDaGFuZ2UobmV4dFN0YXRlID0+IGhhbnppV3JpdGVyUmVuZGVyZXIucmVuZGVyKG5leHRTdGF0ZSkpO1xuXG4gICAgICBoYW56aVdyaXRlclJlbmRlcmVyLnJlbmRlcih0aGlzLl9yZW5kZXJTdGF0ZS5zdGF0ZSk7IC8vIHVwZGF0ZSB0aGUgY3VycmVudCBxdWl6IGFzIHdlbGwsIGlmIG9uZSBpcyBhY3RpdmVcblxuICAgICAgaWYgKHRoaXMuX3F1aXopIHtcbiAgICAgICAgdGhpcy5fcXVpei5zZXRQb3NpdGlvbmVyKHRoaXMuX3Bvc2l0aW9uZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUNvbG9yKGNvbG9yTmFtZSwgY29sb3JWYWwsIG9wdGlvbnMgPSB7fSkge1xuICAgIHZhciBfb3B0aW9ucyRkdXJhdGlvbjtcblxuICAgIGxldCBtdXRhdGlvbnMgPSBbXTtcblxuICAgIGNvbnN0IGZpeGVkQ29sb3JWYWwgPSAoKCkgPT4ge1xuICAgICAgLy8gSWYgd2UncmUgcmVtb3ZpbmcgcmFkaWNhbCBjb2xvciwgdHdlZW4gaXQgdG8gdGhlIHN0cm9rZSBjb2xvclxuICAgICAgaWYgKGNvbG9yTmFtZSA9PT0gJ3JhZGljYWxDb2xvcicgJiYgIWNvbG9yVmFsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zLnN0cm9rZUNvbG9yO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29sb3JWYWw7XG4gICAgfSkoKTtcblxuICAgIGNvbnN0IG1hcHBlZENvbG9yID0gY29sb3JTdHJpbmdUb1ZhbHMoZml4ZWRDb2xvclZhbCk7XG4gICAgdGhpcy5fb3B0aW9uc1tjb2xvck5hbWVdID0gY29sb3JWYWw7XG4gICAgY29uc3QgZHVyYXRpb24gPSAoX29wdGlvbnMkZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uKSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRkdXJhdGlvbiAhPT0gdm9pZCAwID8gX29wdGlvbnMkZHVyYXRpb24gOiB0aGlzLl9vcHRpb25zLnN0cm9rZUZhZGVEdXJhdGlvbjtcbiAgICBtdXRhdGlvbnMgPSBtdXRhdGlvbnMuY29uY2F0KHVwZGF0ZUNvbG9yKGNvbG9yTmFtZSwgbWFwcGVkQ29sb3IsIGR1cmF0aW9uKSk7IC8vIG1ha2Ugc3VyZSB0byBzZXQgcmFkaWNhbENvbG9yIGJhY2sgdG8gbnVsbCBhZnRlciB0aGUgdHJhbnNpdGlvbiBmaW5pc2hlcyBpZiB2YWwgPT0gbnVsbFxuXG4gICAgaWYgKGNvbG9yTmFtZSA9PT0gJ3JhZGljYWxDb2xvcicgJiYgIWNvbG9yVmFsKSB7XG4gICAgICBtdXRhdGlvbnMgPSBtdXRhdGlvbnMuY29uY2F0KHVwZGF0ZUNvbG9yKGNvbG9yTmFtZSwgbnVsbCwgMCkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl93aXRoRGF0YSgoKSA9PiB7XG4gICAgICB2YXIgX3RoaXMkX3JlbmRlclN0YXRlOTtcblxuICAgICAgcmV0dXJuIChfdGhpcyRfcmVuZGVyU3RhdGU5ID0gdGhpcy5fcmVuZGVyU3RhdGUpID09PSBudWxsIHx8IF90aGlzJF9yZW5kZXJTdGF0ZTkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJF9yZW5kZXJTdGF0ZTkucnVuKG11dGF0aW9ucykudGhlbihyZXMgPT4ge1xuICAgICAgICB2YXIgX29wdGlvbnMkb25Db21wbGV0ZTg7XG5cbiAgICAgICAgKF9vcHRpb25zJG9uQ29tcGxldGU4ID0gb3B0aW9ucy5vbkNvbXBsZXRlKSA9PT0gbnVsbCB8fCBfb3B0aW9ucyRvbkNvbXBsZXRlOCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdGlvbnMkb25Db21wbGV0ZTguY2FsbChvcHRpb25zLCByZXMpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBxdWl6KHF1aXpPcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGEoYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2NoYXJhY3RlciAmJiB0aGlzLl9yZW5kZXJTdGF0ZSAmJiB0aGlzLl9wb3NpdGlvbmVyKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsUXVpeigpO1xuICAgICAgICB0aGlzLl9xdWl6ID0gbmV3IFF1aXoodGhpcy5fY2hhcmFjdGVyLCB0aGlzLl9yZW5kZXJTdGF0ZSwgdGhpcy5fcG9zaXRpb25lcik7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSB7IC4uLnRoaXMuX29wdGlvbnMsXG4gICAgICAgICAgLi4ucXVpek9wdGlvbnNcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9xdWl6LnN0YXJ0UXVpeih0aGlzLl9vcHRpb25zKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHNraXBRdWl6U3Ryb2tlKCkge1xuICAgIGlmICh0aGlzLl9xdWl6KSB7XG4gICAgICB0aGlzLl9xdWl6Lm5leHRTdHJva2UoKTtcbiAgICB9XG4gIH1cblxuICBjYW5jZWxRdWl6KCkge1xuICAgIGlmICh0aGlzLl9xdWl6KSB7XG4gICAgICB0aGlzLl9xdWl6LmNhbmNlbCgpO1xuXG4gICAgICB0aGlzLl9xdWl6ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHNldENoYXJhY3RlcihjaGFyKSB7XG4gICAgdGhpcy5jYW5jZWxRdWl6KCk7XG4gICAgdGhpcy5fY2hhciA9IGNoYXI7XG5cbiAgICBpZiAodGhpcy5faGFuemlXcml0ZXJSZW5kZXJlcikge1xuICAgICAgdGhpcy5faGFuemlXcml0ZXJSZW5kZXJlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlbmRlclN0YXRlKSB7XG4gICAgICB0aGlzLl9yZW5kZXJTdGF0ZS5jYW5jZWxBbGwoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9oYW56aVdyaXRlclJlbmRlcmVyID0gbnVsbDtcbiAgICB0aGlzLl93aXRoRGF0YVByb21pc2UgPSB0aGlzLl9sb2FkaW5nTWFuYWdlci5sb2FkQ2hhckRhdGEoY2hhcikudGhlbihwYXRoU3RyaW5ncyA9PiB7XG4gICAgICAvLyBpZiBcInBhdGhTdHJpbmdzXCIgaXNuJ3Qgc2V0LCBcIi5jYXRjaCgpXCJcIiB3YXMgcHJvYmFibHkgY2FsbGVkIGFuZCBsb2FkaW5nIGxpa2VseSBmYWlsZWRcbiAgICAgIGlmICghcGF0aFN0cmluZ3MgfHwgdGhpcy5fbG9hZGluZ01hbmFnZXIubG9hZGluZ0ZhaWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NoYXJhY3RlciA9IHBhcnNlQ2hhckRhdGEoY2hhciwgcGF0aFN0cmluZ3MpO1xuICAgICAgdGhpcy5fcmVuZGVyU3RhdGUgPSBuZXcgUmVuZGVyU3RhdGUodGhpcy5fY2hhcmFjdGVyLCB0aGlzLl9vcHRpb25zLCBuZXh0U3RhdGUgPT4gaGFuemlXcml0ZXJSZW5kZXJlci5yZW5kZXIobmV4dFN0YXRlKSk7XG5cbiAgICAgIGNvbnN0IGhhbnppV3JpdGVyUmVuZGVyZXIgPSB0aGlzLl9pbml0QW5kTW91bnRIYW56aVdyaXRlclJlbmRlcmVyKHRoaXMuX2NoYXJhY3Rlcik7XG5cbiAgICAgIGhhbnppV3JpdGVyUmVuZGVyZXIucmVuZGVyKHRoaXMuX3JlbmRlclN0YXRlLnN0YXRlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGFQcm9taXNlO1xuICB9XG5cbiAgX2luaXRBbmRNb3VudEhhbnppV3JpdGVyUmVuZGVyZXIoY2hhcmFjdGVyKSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBwYWRkaW5nXG4gICAgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgdGhpcy5fcG9zaXRpb25lciA9IG5ldyBQb3NpdGlvbmVyKHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcGFkZGluZ1xuICAgIH0pO1xuICAgIGNvbnN0IGhhbnppV3JpdGVyUmVuZGVyZXIgPSBuZXcgdGhpcy5fcmVuZGVyZXIuSGFuemlXcml0ZXJSZW5kZXJlcihjaGFyYWN0ZXIsIHRoaXMuX3Bvc2l0aW9uZXIpO1xuICAgIGhhbnppV3JpdGVyUmVuZGVyZXIubW91bnQodGhpcy50YXJnZXQpO1xuICAgIHRoaXMuX2hhbnppV3JpdGVyUmVuZGVyZXIgPSBoYW56aVdyaXRlclJlbmRlcmVyO1xuICAgIHJldHVybiBoYW56aVdyaXRlclJlbmRlcmVyO1xuICB9XG5cbiAgYXN5bmMgZ2V0Q2hhcmFjdGVyRGF0YSgpIHtcbiAgICBpZiAoIXRoaXMuX2NoYXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2V0Q2hhcmFjdGVyKCkgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgZ2V0Q2hhcmFjdGVyRGF0YSgpJyk7XG4gICAgfVxuXG4gICAgY29uc3QgY2hhcmFjdGVyID0gYXdhaXQgdGhpcy5fd2l0aERhdGEoKCkgPT4gdGhpcy5fY2hhcmFjdGVyKTtcbiAgICByZXR1cm4gY2hhcmFjdGVyO1xuICB9XG5cbiAgX2Fzc2lnbk9wdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSB7IC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07IC8vIGJhY2tmaWxsIHN0cm9rZUFuaW1hdGlvblNwZWVkIGlmIGRlcHJlY2F0ZWQgc3Ryb2tlQW5pbWF0aW9uRHVyYXRpb24gaXMgcHJvdmlkZWQgaW5zdGVhZFxuXG4gICAgaWYgKG9wdGlvbnMuc3Ryb2tlQW5pbWF0aW9uRHVyYXRpb24gJiYgIW9wdGlvbnMuc3Ryb2tlQW5pbWF0aW9uU3BlZWQpIHtcbiAgICAgIG1lcmdlZE9wdGlvbnMuc3Ryb2tlQW5pbWF0aW9uU3BlZWQgPSA1MDAgLyBvcHRpb25zLnN0cm9rZUFuaW1hdGlvbkR1cmF0aW9uO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnN0cm9rZUhpZ2hsaWdodER1cmF0aW9uICYmICFvcHRpb25zLnN0cm9rZUhpZ2hsaWdodFNwZWVkKSB7XG4gICAgICBtZXJnZWRPcHRpb25zLnN0cm9rZUhpZ2hsaWdodFNwZWVkID0gNTAwIC8gbWVyZ2VkT3B0aW9ucy5zdHJva2VIaWdobGlnaHREdXJhdGlvbjtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMuaGlnaGxpZ2h0Q29tcGxldGVDb2xvcikge1xuICAgICAgbWVyZ2VkT3B0aW9ucy5oaWdobGlnaHRDb21wbGV0ZUNvbG9yID0gbWVyZ2VkT3B0aW9ucy5oaWdobGlnaHRDb2xvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZmlsbFdpZHRoQW5kSGVpZ2h0KG1lcmdlZE9wdGlvbnMpO1xuICB9XG4gIC8qKiByZXR1cm5zIGEgbmV3IG9wdGlvbnMgb2JqZWN0IHdpdGggd2lkdGggYW5kIGhlaWdodCBmaWxsZWQgaW4gaWYgbWlzc2luZyAqL1xuXG5cbiAgX2ZpbGxXaWR0aEFuZEhlaWdodChvcHRpb25zKSB7XG4gICAgY29uc3QgZmlsbGVkT3B0cyA9IHsgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICBpZiAoZmlsbGVkT3B0cy53aWR0aCAmJiAhZmlsbGVkT3B0cy5oZWlnaHQpIHtcbiAgICAgIGZpbGxlZE9wdHMuaGVpZ2h0ID0gZmlsbGVkT3B0cy53aWR0aDtcbiAgICB9IGVsc2UgaWYgKGZpbGxlZE9wdHMuaGVpZ2h0ICYmICFmaWxsZWRPcHRzLndpZHRoKSB7XG4gICAgICBmaWxsZWRPcHRzLndpZHRoID0gZmlsbGVkT3B0cy5oZWlnaHQ7XG4gICAgfSBlbHNlIGlmICghZmlsbGVkT3B0cy53aWR0aCAmJiAhZmlsbGVkT3B0cy5oZWlnaHQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IHRoaXMudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgbWluRGltID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG4gICAgICBmaWxsZWRPcHRzLndpZHRoID0gbWluRGltO1xuICAgICAgZmlsbGVkT3B0cy5oZWlnaHQgPSBtaW5EaW07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbGxlZE9wdHM7XG4gIH1cblxuICBfd2l0aERhdGEoZnVuYykge1xuICAgIC8vIGlmIHRoaXMuX2xvYWRpbmdNYW5hZ2VyLmxvYWRpbmdGYWlsZWQsIHRoZW4gbG9hZGluZyBmYWlsZWQgYmVmb3JlIHRoaXMgbWV0aG9kIHdhcyBjYWxsZWRcbiAgICBpZiAodGhpcy5fbG9hZGluZ01hbmFnZXIubG9hZGluZ0ZhaWxlZCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGNoYXJhY3RlciBkYXRhLiBDYWxsIHNldENoYXJhY3RlciBhbmQgdHJ5IGFnYWluLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl93aXRoRGF0YVByb21pc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl93aXRoRGF0YVByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5fbG9hZGluZ01hbmFnZXIubG9hZGluZ0ZhaWxlZCkge1xuICAgICAgICAgIHJldHVybiBmdW5jKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmMpO1xuICB9XG5cbiAgX3NldHVwTGlzdGVuZXJzKCkge1xuICAgIHRoaXMudGFyZ2V0LmFkZFBvaW50ZXJTdGFydExpc3RlbmVyKGV2dCA9PiB7XG4gICAgICBpZiAodGhpcy5fcXVpeikge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICB0aGlzLl9xdWl6LnN0YXJ0VXNlclN0cm9rZShldnQuZ2V0UG9pbnQoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy50YXJnZXQuYWRkUG9pbnRlck1vdmVMaXN0ZW5lcihldnQgPT4ge1xuICAgICAgaWYgKHRoaXMuX3F1aXopIHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgdGhpcy5fcXVpei5jb250aW51ZVVzZXJTdHJva2UoZXZ0LmdldFBvaW50KCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMudGFyZ2V0LmFkZFBvaW50ZXJFbmRMaXN0ZW5lcigoKSA9PiB7XG4gICAgICB2YXIgX3RoaXMkX3F1aXo7XG5cbiAgICAgIChfdGhpcyRfcXVpeiA9IHRoaXMuX3F1aXopID09PSBudWxsIHx8IF90aGlzJF9xdWl6ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRfcXVpei5lbmRVc2VyU3Ryb2tlKCk7XG4gICAgfSk7XG4gIH1cblxufVxuLyoqIFNpbmdsZXRvbiBpbnN0YW5jZSBvZiBMb2FkaW5nTWFuYWdlci4gT25seSBzZXQgaW4gYGxvYWRDaGFyYWN0ZXJEYXRhYCAqL1xuXG5IYW56aVdyaXRlci5fbG9hZGluZ01hbmFnZXIgPSBudWxsO1xuLyoqIFNpbmdsZXRvbiBsb2FkaW5nIG9wdGlvbnMuIE9ubHkgc2V0IGluIGBsb2FkQ2hhcmFjdGVyRGF0YWAgKi9cblxuSGFuemlXcml0ZXIuX2xvYWRpbmdPcHRpb25zID0gbnVsbDtcblxuZXhwb3J0IGRlZmF1bHQgSGFuemlXcml0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20uanMubWFwXG4iXSwibmFtZXMiOlsiX2dsb2JhbE9iaiRyZXF1ZXN0QW5pIiwiX2dsb2JhbE9iaiRjYW5jZWxBbmltIiwiX2dsb2JhbE9iaiRuYXZpZ2F0b3IiLCJnbG9iYWxPYmoiLCJnbG9iYWwiLCJ3aW5kb3ciLCJwZXJmb3JtYW5jZU5vdyIsInBlcmZvcm1hbmNlIiwibm93IiwiRGF0ZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImJpbmQiLCJjYWxsYmFjayIsInNldFRpbWVvdXQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImNsZWFyVGltZW91dCIsImFyckxhc3QiLCJhcnIiLCJsZW5ndGgiLCJmaXhJbmRleCIsImluZGV4Iiwic2VsZWN0SW5kZXgiLCJjb3B5QW5kTWVyZ2VEZWVwIiwiYmFzZSIsIm92ZXJyaWRlIiwib3V0cHV0Iiwia2V5IiwiYmFzZVZhbCIsIm92ZXJyaWRlVmFsIiwiQXJyYXkiLCJpc0FycmF5IiwiaW5mbGF0ZSIsInNjb3BlIiwib2JqIiwicGFydHMiLCJzcGxpdCIsImZpbmFsIiwiY3VycmVudCIsImkiLCJjYXAiLCJjb3VudCIsImNvdW50ZXIiLCJhdmVyYWdlIiwic3VtIiwicmVkdWNlIiwiYWNjIiwidmFsIiwiY29sb3JTdHJpbmdUb1ZhbHMiLCJjb2xvclN0cmluZyIsIm5vcm1hbGl6ZWRDb2xvciIsInRvVXBwZXJDYXNlIiwidHJpbSIsInRlc3QiLCJoZXhQYXJ0cyIsInN1YnN0cmluZyIsImhleFN0ciIsImpvaW4iLCJyIiwicGFyc2VJbnQiLCJzbGljZSIsImciLCJiIiwiYSIsInJnYk1hdGNoIiwibWF0Y2giLCJwYXJzZUZsb2F0IiwiRXJyb3IiLCJzdHJpbmciLCJyZXBsYWNlIiwib2JqUmVwZWF0IiwiaXRlbSIsInRpbWVzIiwib2JqUmVwZWF0Q2IiLCJjYiIsInVhIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaXNNc0Jyb3dzZXIiLCJpbmRleE9mIiwibm9vcCIsIlJlbmRlclN0YXRlIiwib3ZlcndyaXRlT25TdGF0ZUNoYW5nZSIsIm9uU3RhdGVDaGFuZ2UiLCJfb25TdGF0ZUNoYW5nZSIsInVwZGF0ZVN0YXRlIiwic3RhdGVDaGFuZ2VzIiwibmV4dFN0YXRlIiwic3RhdGUiLCJydW4iLCJtdXRhdGlvbnMiLCJvcHRpb25zIiwic2NvcGVzIiwibWFwIiwibXV0IiwiY2FuY2VsTXV0YXRpb25zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJtdXRhdGlvbkNoYWluIiwiX2lzQWN0aXZlIiwiX2luZGV4IiwiX3Jlc29sdmUiLCJfbXV0YXRpb25zIiwiX2xvb3AiLCJsb29wIiwiX3Njb3BlcyIsIl9tdXRhdGlvbkNoYWlucyIsInB1c2giLCJfcnVuIiwiZmlsdGVyIiwiY2hhaW4iLCJjYW5jZWxlZCIsImFjdGl2ZU11dGF0aW9uIiwidGhlbiIsIl9nZXRBY3RpdmVNdXRhdGlvbnMiLCJwYXVzZUFsbCIsImZvckVhY2giLCJtdXRhdGlvbiIsInBhdXNlIiwicmVzdW1lQWxsIiwicmVzdW1lIiwic2NvcGVzVG9DYW5jZWwiLCJjaGFpbklkIiwic2NvcGVUb0NhbmNlbCIsInN0YXJ0c1dpdGgiLCJfY2FuY2VsTXV0YXRpb25DaGFpbiIsImNhbmNlbEFsbCIsIl9tdXRhdGlvbkNoYWluJF9yZXNvbCIsImNhbmNlbCIsImNhbGwiLCJjb25zdHJ1Y3RvciIsImNoYXJhY3RlciIsImRyYXdpbmdGYWRlRHVyYXRpb24iLCJkcmF3aW5nV2lkdGgiLCJkcmF3aW5nQ29sb3IiLCJzdHJva2VDb2xvciIsIm91dGxpbmVDb2xvciIsInJhZGljYWxDb2xvciIsImhpZ2hsaWdodENvbG9yIiwibWFpbiIsIm9wYWNpdHkiLCJzaG93Q2hhcmFjdGVyIiwic3Ryb2tlcyIsIm91dGxpbmUiLCJzaG93T3V0bGluZSIsImhpZ2hsaWdodCIsInVzZXJTdHJva2VzIiwiZGlzcGxheVBvcnRpb24iLCJzdWJ0cmFjdCIsInAxIiwicDIiLCJ4IiwieSIsIm1hZ25pdHVkZSIsInBvaW50IiwiTWF0aCIsInNxcnQiLCJwb3ciLCJkaXN0YW5jZSIsInBvaW50MSIsInBvaW50MiIsImVxdWFscyIsInJvdW5kIiwicHJlY2lzaW9uIiwibXVsdGlwbGllciIsInBvaW50cyIsImxhc3RQb2ludCIsInBvaW50c1NhbnNGaXJzdCIsImRpc3QiLCJjb3NpbmVTaW1pbGFyaXR5IiwicmF3RG90UHJvZHVjdCIsIl9leHRlbmRQb2ludE9uTGluZSIsInZlY3QiLCJub3JtIiwiZnJlY2hldERpc3QiLCJjdXJ2ZTEiLCJjdXJ2ZTIiLCJsb25nQ3VydmUiLCJzaG9ydEN1cnZlIiwiY2FsY1ZhbCIsImoiLCJwcmV2UmVzdWx0c0NvbCIsImN1clJlc3VsdHNDb2wiLCJtYXgiLCJsYXN0UmVzdWx0IiwibWluIiwic3ViZGl2aWRlQ3VydmUiLCJjdXJ2ZSIsIm1heExlbiIsIm5ld0N1cnZlIiwicHJldlBvaW50Iiwic2VnTGVuIiwibnVtTmV3UG9pbnRzIiwiY2VpbCIsIm5ld1NlZ0xlbiIsIm91dGxpbmVDdXJ2ZSIsIm51bVBvaW50cyIsImN1cnZlTGVuIiwic2VnbWVudExlbiIsIm91dGxpbmVQb2ludHMiLCJlbmRQb2ludCIsInJlbWFpbmluZ0N1cnZlUG9pbnRzIiwicmVtYWluaW5nRGlzdCIsIm91dGxpbmVQb2ludEZvdW5kIiwibmV4dFBvaW50RGlzdCIsInNoaWZ0IiwibmV4dFBvaW50Iiwibm9ybWFsaXplQ3VydmUiLCJvdXRsaW5lZEN1cnZlIiwibWVhblgiLCJtZWFuWSIsIm1lYW4iLCJ0cmFuc2xhdGVkQ3VydmUiLCJzY2FsZSIsInNjYWxlZEN1cnZlIiwicm90YXRlIiwidGhldGEiLCJjb3MiLCJzaW4iLCJfZmlsdGVyUGFyYWxsZWxQb2ludHMiLCJmaWx0ZXJlZFBvaW50cyIsIm51bUZpbHRlcmVkUG9pbnRzIiwiY3VyVmVjdCIsInByZXZWZWN0IiwiaXNQYXJhbGxlbCIsInBvcCIsImdldFBhdGhTdHJpbmciLCJjbG9zZSIsInN0YXJ0IiwicmVtYWluaW5nUG9pbnRzIiwicGF0aFN0cmluZyIsInJvdW5kZWRQb2ludCIsImV4dGVuZFN0YXJ0IiwibmV3U3RhcnQiLCJleHRlbmRlZFBvaW50cyIsInVuc2hpZnQiLCJTdHJva2UiLCJnZXRTdGFydGluZ1BvaW50IiwiZ2V0RW5kaW5nUG9pbnQiLCJnZXRMZW5ndGgiLCJnZXRWZWN0b3JzIiwidmVjdG9yIiwiZ2V0RGlzdGFuY2UiLCJkaXN0YW5jZXMiLCJzdHJva2VQb2ludCIsImdldEF2ZXJhZ2VEaXN0YW5jZSIsInRvdGFsRGlzdCIsInBhdGgiLCJzdHJva2VOdW0iLCJpc0luUmFkaWNhbCIsIkNoYXJhY3RlciIsInN5bWJvbCIsImdlbmVyYXRlU3Ryb2tlcyIsInJhZFN0cm9rZXMiLCJtZWRpYW5zIiwiX3JhZFN0cm9rZXMkaW5kZXhPZiIsInBvaW50RGF0YSIsInBhcnNlQ2hhckRhdGEiLCJjaGFySnNvbiIsIkNIQVJBQ1RFUl9CT1VORFMiLCJmcm9tIiwidG8iLCJwcmVTY2FsZWRXaWR0aCIsInByZVNjYWxlZEhlaWdodCIsIlBvc2l0aW9uZXIiLCJjb252ZXJ0RXh0ZXJuYWxQb2ludCIsInhPZmZzZXQiLCJoZWlnaHQiLCJ5T2Zmc2V0IiwicGFkZGluZyIsIndpZHRoIiwiZWZmZWN0aXZlV2lkdGgiLCJlZmZlY3RpdmVIZWlnaHQiLCJzY2FsZVgiLCJzY2FsZVkiLCJ4Q2VudGVyaW5nQnVmZmVyIiwieUNlbnRlcmluZ0J1ZmZlciIsIkNPU0lORV9TSU1JTEFSSVRZX1RIUkVTSE9MRCIsIlNUQVJUX0FORF9FTkRfRElTVF9USFJFU0hPTEQiLCJGUkVDSEVUX1RIUkVTSE9MRCIsIk1JTl9MRU5fVEhSRVNIT0xEIiwic3Ryb2tlTWF0Y2hlcyIsInVzZXJTdHJva2UiLCJzdHJpcER1cGxpY2F0ZXMiLCJpc01hdGNoIiwibWV0YSIsImlzU3Ryb2tlQmFja3dhcmRzIiwiYXZnRGlzdCIsImdldE1hdGNoRGF0YSIsImxhdGVyU3Ryb2tlcyIsImNsb3Nlc3RNYXRjaERpc3QiLCJjaGVja0JhY2t3YXJkcyIsImxlbmllbmN5QWRqdXN0bWVudCIsImxlbmllbmN5Iiwic3RhcnRBbmRFbmRNYXRjaGVzIiwiY2xvc2VzdFN0cm9rZSIsInN0YXJ0aW5nRGlzdCIsImVuZGluZ0Rpc3QiLCJnZXRFZGdlVmVjdG9ycyIsInZlY3RvcnMiLCJkaXJlY3Rpb25NYXRjaGVzIiwic3Ryb2tlIiwiZWRnZVZlY3RvcnMiLCJzdHJva2VWZWN0b3JzIiwic2ltaWxhcml0aWVzIiwiZWRnZVZlY3RvciIsInN0cm9rZVNpbWlsYXJpdGllcyIsInN0cm9rZVZlY3RvciIsImF2Z1NpbWlsYXJpdHkiLCJsZW5ndGhNYXRjaGVzIiwiZmlyc3RQb2ludCIsInJlc3QiLCJkZWR1cGVkUG9pbnRzIiwiU0hBUEVfRklUX1JPVEFUSU9OUyIsIlBJIiwic2hhcGVGaXQiLCJub3JtQ3VydmUxIiwibm9ybUN1cnZlMiIsIm1pbkRpc3QiLCJJbmZpbml0eSIsImlzT3V0bGluZVZpc2libGUiLCJhdmVyYWdlRGlzdGFuY2VUaHJlc2hvbGQiLCJkaXN0TW9kIiwid2l0aGluRGlzdFRocmVzaCIsInN0YXJ0QW5kRW5kTWF0Y2giLCJkaXJlY3Rpb25NYXRjaCIsInNoYXBlTWF0Y2giLCJsZW5ndGhNYXRjaCIsImJhY2t3YXJkc01hdGNoRGF0YSIsInJldmVyc2UiLCJVc2VyU3Ryb2tlIiwiYXBwZW5kUG9pbnQiLCJleHRlcm5hbFBvaW50IiwiZXh0ZXJuYWxQb2ludHMiLCJpZCIsInN0YXJ0aW5nUG9pbnQiLCJzdGFydGluZ0V4dGVybmFsUG9pbnQiLCJEZWxheSIsIl9zdGFydFRpbWUiLCJfcnVubmluZ1Byb21pc2UiLCJfdGltZW91dCIsIl9kdXJhdGlvbiIsIl9wYXVzZWQiLCJlbGFwc2VkRGVsYXkiLCJ1bmRlZmluZWQiLCJkdXJhdGlvbiIsIk11dGF0aW9uIiwicmVuZGVyU3RhdGUiLCJfdmFsdWVzIiwiX2luZmxhdGVWYWx1ZXMiLCJpc0FscmVhZHlBdEVuZCIsIl9yZW5kZXJTdGF0ZSIsIl9zdGFydFN0YXRlIiwiX2ZyYW1lSGFuZGxlIiwiX3RpY2siLCJ2YWx1ZXMiLCJfdmFsdWVzT3JDYWxsYWJsZSIsIl9zdGFydFBhdXNlVGltZSIsIl9wYXVzZWREdXJhdGlvbiIsIl90aGlzJF9yZXNvbHZlIiwiX2ZvcmNlIiwidmFsdWVzT3JDYWxsYWJsZSIsInRpbWluZyIsInByb2dyZXNzIiwiZWFzZWRQcm9ncmVzcyIsImVhc2UiLCJnZXRQYXJ0aWFsVmFsdWVzIiwiZm9yY2UiLCJzdGFydFZhbHVlcyIsImVuZFZhbHVlcyIsInRhcmdldCIsImVuZFZhbHVlIiwic3RhcnRWYWx1ZSIsInNob3dTdHJva2VzIiwiY2hhck5hbWUiLCJoaWRlQ2hhcmFjdGVyIiwidXBkYXRlQ29sb3IiLCJjb2xvck5hbWUiLCJjb2xvclZhbCIsImhpZ2hsaWdodFN0cm9rZSIsImNvbG9yIiwic3BlZWQiLCJhbmltYXRlU3Ryb2tlIiwiYW5pbWF0ZVNpbmdsZVN0cm9rZSIsIm11dGF0aW9uU3RhdGVGdW5jIiwiY3VyQ2hhclN0YXRlIiwibXV0YXRpb25TdGF0ZSIsInNob3dTdHJva2UiLCJhbmltYXRlQ2hhcmFjdGVyIiwiZmFkZUR1cmF0aW9uIiwiZGVsYXlCZXR3ZWVuU3Ryb2tlcyIsImNvbmNhdCIsImFuaW1hdGVDaGFyYWN0ZXJMb29wIiwiZGVsYXlCZXR3ZWVuTG9vcHMiLCJzdGFydFF1aXoiLCJzdGFydFN0cm9rZU51bSIsInN0YXJ0VXNlclN0cm9rZSIsInVwZGF0ZVVzZXJTdHJva2UiLCJ1c2VyU3Ryb2tlSWQiLCJoaWRlVXNlclN0cm9rZSIsInJlbW92ZUFsbFVzZXJTdHJva2VzIiwidXNlclN0cm9rZUlkcyIsImhpZ2hsaWdodENvbXBsZXRlQ2hhciIsImdldERyYXduUGF0aCIsIlF1aXoiLCJfdXNlclN0cm9rZXNJZHMiLCJfb3B0aW9ucyIsInN0YXJ0SW5kZXgiLCJxdWl6U3RhcnRTdHJva2VOdW0iLCJfY2hhcmFjdGVyIiwiX2N1cnJlbnRTdHJva2VJbmRleCIsIl9taXN0YWtlc09uU3Ryb2tlIiwiX3RvdGFsTWlzdGFrZXMiLCJzdHJva2VGYWRlRHVyYXRpb24iLCJfdGhpcyRfdXNlclN0cm9rZXNJZHMiLCJfdXNlclN0cm9rZSIsImVuZFVzZXJTdHJva2UiLCJfcG9zaXRpb25lciIsInN0cm9rZUlkIiwiY29udGludWVVc2VyU3Ryb2tlIiwibmV4dFBvaW50cyIsInNldFBvc2l0aW9uZXIiLCJwb3NpdGlvbmVyIiwiX3RoaXMkX29wdGlvbnMkZHJhd2luIiwiYWNjZXB0QmFja3dhcmRzU3Ryb2tlcyIsIm1hcmtTdHJva2VDb3JyZWN0QWZ0ZXJNaXNzZXMiLCJjdXJyZW50U3Ryb2tlIiwiX2dldEN1cnJlbnRTdHJva2UiLCJpc0ZvcmNlQWNjZXB0ZWQiLCJpc0FjY2VwdGVkIiwiX2hhbmRsZVN1Y2Nlc3MiLCJfaGFuZGxlRmFpbHVyZSIsInNob3dIaW50QWZ0ZXJNaXNzZXMiLCJzdHJva2VIaWdobGlnaHRTcGVlZCIsIl9nZXRTdHJva2VEYXRhIiwiaXNDb3JyZWN0IiwibWlzdGFrZXNPblN0cm9rZSIsInRvdGFsTWlzdGFrZXMiLCJzdHJva2VzUmVtYWluaW5nIiwiZHJhd25QYXRoIiwiaXNCYWNrd2FyZHMiLCJuZXh0U3Ryb2tlIiwib25Db21wbGV0ZSIsImhpZ2hsaWdodE9uQ29tcGxldGUiLCJoaWdobGlnaHRDb21wbGV0ZUNvbG9yIiwic3Ryb2tlSGlnaGxpZ2h0RHVyYXRpb24iLCJhbmltYXRpb24iLCJpc0NvbXBsZXRlIiwib25Db3JyZWN0U3Ryb2tlIiwiX3RoaXMkX29wdGlvbnMkb25NaXN0IiwiX3RoaXMkX29wdGlvbnMiLCJvbk1pc3Rha2UiLCJjcmVhdGVFbG0iLCJlbG1UeXBlIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50TlMiLCJhdHRyIiwiZWxtIiwibmFtZSIsInZhbHVlIiwic2V0QXR0cmlidXRlTlMiLCJhdHRycyIsImF0dHJzTWFwIiwiT2JqZWN0Iiwia2V5cyIsImF0dHJOYW1lIiwidXJsSWRSZWYiLCJwcmVmaXgiLCJsb2NhdGlvbiIsImhyZWYiLCJyZW1vdmVFbG0iLCJfZWxtJHBhcmVudE5vZGUiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJTdHJva2VSZW5kZXJlckJhc2UiLCJfZ2V0U3Ryb2tlRGFzaG9mZnNldCIsIl9wYXRoTGVuZ3RoIiwiX2dldENvbG9yIiwiU1RST0tFX1dJRFRIIiwiU3Ryb2tlUmVuZGVyZXIiLCJtb3VudCIsIl9hbmltYXRpb25QYXRoIiwiX2NsaXAiLCJfc3Ryb2tlUGF0aCIsIm1hc2tJZCIsInN0eWxlIiwiZXh0ZW5kZWRNYXNrUG9pbnRzIiwidG9TdHJpbmciLCJmaWxsIiwiYXBwZW5kQ2hpbGQiLCJkZWZzIiwic3ZnIiwicmVuZGVyIiwicHJvcHMiLCJfdGhpcyRfb2xkUHJvcHMiLCJfdGhpcyRfb2xkUHJvcHMyIiwiX29sZFByb3BzIiwic3Ryb2tlRGFzaG9mZnNldCIsIkNoYXJhY3RlclJlbmRlcmVyIiwic3ViVGFyZ2V0IiwiY3JlYXRlU3ViUmVuZGVyVGFyZ2V0IiwiX2dyb3VwIiwiX3N0cm9rZVJlbmRlcmVycyIsInN0cm9rZVJlbmRlcmVyIiwiX3RoaXMkX29sZFByb3BzMyIsImRpc3BsYXkiLCJyZW1vdmVQcm9wZXJ0eSIsImNvbG9yc0NoYW5nZWQiLCJfdGhpcyRfb2xkUHJvcHM0IiwiVXNlclN0cm9rZVJlbmRlcmVyIiwiX3BhdGgiLCJzdHJva2VXaWR0aCIsImRlc3Ryb3kiLCJIYW56aVdyaXRlclJlbmRlcmVyIiwicG9zaXRpb25lZFRhcmdldCIsImdyb3VwIiwiX291dGxpbmVDaGFyUmVuZGVyZXIiLCJfbWFpbkNoYXJSZW5kZXJlciIsIl9oaWdobGlnaHRDaGFyUmVuZGVyZXIiLCJfcG9zaXRpb25lZFRhcmdldCIsIl91c2VyU3Ryb2tlUmVuZGVyZXJzIiwiX3RoaXMkX3VzZXJTdHJva2VSZW5kIiwidXNlclN0cm9rZVByb3BzIiwibmV3U3Ryb2tlUmVuZGVyZXIiLCJpbm5lckhUTUwiLCJSZW5kZXJUYXJnZXRCYXNlIiwiYWRkUG9pbnRlclN0YXJ0TGlzdGVuZXIiLCJub2RlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2dCIsIl9ldmVudGlmeSIsIl9nZXRNb3VzZVBvaW50IiwiX2dldFRvdWNoUG9pbnQiLCJhZGRQb2ludGVyTW92ZUxpc3RlbmVyIiwiYWRkUG9pbnRlckVuZExpc3RlbmVyIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidXBkYXRlRGltZW5zaW9ucyIsInNldEF0dHJpYnV0ZSIsInBvaW50RnVuYyIsImdldFBvaW50IiwicHJldmVudERlZmF1bHQiLCJsZWZ0IiwidG9wIiwiY2xpZW50WCIsImNsaWVudFkiLCJ0b3VjaGVzIiwiUmVuZGVyVGFyZ2V0IiwiaW5pdCIsImVsbU9ySWQiLCJlbGVtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJub2RlVHlwZSIsIm5vZGVOYW1lIiwiX3B0IiwiX3RoaXMkbm9kZSRnZXRTY3JlZW5DIiwibG9jYWxQdCIsIm1hdHJpeFRyYW5zZm9ybSIsImdldFNjcmVlbkNUTSIsImludmVyc2UiLCJfdGhpcyRub2RlJGdldFNjcmVlbkMyIiwiY3JlYXRlU1ZHUG9pbnQiLCJzdmdSZW5kZXJlciIsImNyZWF0ZVJlbmRlclRhcmdldCIsImRyYXdQYXRoIiwiY3R4IiwiYmVnaW5QYXRoIiwibW92ZVRvIiwibGluZVRvIiwicGF0aFN0cmluZ1RvQ2FudmFzIiwicGF0aFBhcnRzIiwicGFydCIsImNvbW1hbmRzIiwiY21kIiwicmF3UGFyYW1zIiwicGFyYW1zIiwicGFyYW0iLCJiZXppZXJDdXJ2ZVRvIiwicXVhZHJhdGljQ3VydmVUbyIsIlN0cm9rZVJlbmRlcmVyJDEiLCJzYXZlIiwiX3BhdGgyRCIsImNsaXAiLCJfdGhpcyRfcGF0aENtZCIsIl9wYXRoQ21kIiwiZ2xvYmFsQWxwaGEiLCJkYXNoT2Zmc2V0Iiwic3Ryb2tlU3R5bGUiLCJmaWxsU3R5bGUiLCJsaW5lV2lkdGgiLCJsaW5lQ2FwIiwibGluZUpvaW4iLCJzZXRMaW5lRGFzaCIsImxpbmVEYXNoT2Zmc2V0IiwiX2V4dGVuZGVkTWFza1BvaW50cyIsInJlc3RvcmUiLCJ1c2VQYXRoMkQiLCJQYXRoMkQiLCJDaGFyYWN0ZXJSZW5kZXJlciQxIiwicmVuZGVyVXNlclN0cm9rZSIsIkhhbnppV3JpdGVyUmVuZGVyZXIkMSIsIl90YXJnZXQiLCJfYW5pbWF0aW9uRnJhbWUiLCJnZXRDb250ZXh0IiwiY2xlYXJSZWN0IiwidHJhbnNsYXRlIiwidHJhbnNmb3JtIiwiZHJhdyIsIlJlbmRlclRhcmdldCQxIiwiY2FudmFzIiwiY3JlYXRlRWxlbWVudCIsImNhbnZhc1JlbmRlcmVyIiwiVkVSU0lPTiIsImdldENoYXJEYXRhVXJsIiwiY2hhciIsImRlZmF1bHRDaGFyRGF0YUxvYWRlciIsIm9uTG9hZCIsIm9uRXJyb3IiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsIm92ZXJyaWRlTWltZVR5cGUiLCJvcGVuIiwib25lcnJvciIsImV2ZW50Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVhZHlTdGF0ZSIsInN0YXR1cyIsIkpTT04iLCJwYXJzZSIsInJlc3BvbnNlVGV4dCIsInNlbmQiLCJkZWZhdWx0T3B0aW9ucyIsImNoYXJEYXRhTG9hZGVyIiwib25Mb2FkQ2hhckRhdGFFcnJvciIsIm9uTG9hZENoYXJEYXRhU3VjY2VzcyIsInJlbmRlcmVyIiwic3Ryb2tlQW5pbWF0aW9uU3BlZWQiLCJvdXRsaW5lV2lkdGgiLCJyZW5kZXJlck92ZXJyaWRlIiwiTG9hZGluZ01hbmFnZXIiLCJfZGVib3VuY2VkTG9hZCIsIndyYXBwZWRSZXNvbHZlIiwiZGF0YSIsIl9sb2FkQ291bnRlciIsIndyYXBwZWRSZWplY3QiLCJyZWFzb24iLCJfdGhpcyRfcmVqZWN0IiwiX3JlamVjdCIsInJldHVybmVkRGF0YSIsImNhdGNoIiwiX3NldHVwTG9hZGluZ1Byb21pc2UiLCJyZWplY3QiLCJfdGhpcyRfb3B0aW9ucyRvbkxvYWQiLCJfaXNMb2FkaW5nIiwibG9hZGluZ0ZhaWxlZCIsImVyciIsIl9sb2FkaW5nQ2hhciIsImxvYWRDaGFyRGF0YSIsInByb21pc2UiLCJIYW56aVdyaXRlciIsImNyZWF0ZSIsIndyaXRlciIsInNldENoYXJhY3RlciIsImxvYWRDaGFyYWN0ZXJEYXRhIiwibG9hZGluZ01hbmFnZXIiLCJfbG9hZGluZ01hbmFnZXIiLCJfbG9hZGluZ09wdGlvbnMiLCJnZXRTY2FsaW5nVHJhbnNmb3JtIiwiX3dpdGhEYXRhIiwiX3RoaXMkX3JlbmRlclN0YXRlIiwicmVzIiwiX29wdGlvbnMkb25Db21wbGV0ZSIsIl90aGlzJF9yZW5kZXJTdGF0ZTIiLCJfb3B0aW9ucyRvbkNvbXBsZXRlMiIsImNhbmNlbFF1aXoiLCJfdGhpcyRfcmVuZGVyU3RhdGUzIiwiX29wdGlvbnMkb25Db21wbGV0ZTMiLCJfdGhpcyRfcmVuZGVyU3RhdGU0IiwiX29wdGlvbnMkb25Db21wbGV0ZTQiLCJfb3B0aW9ucyRvbkNvbXBsZXRlNSIsImxvb3BDaGFyYWN0ZXJBbmltYXRpb24iLCJwYXVzZUFuaW1hdGlvbiIsIl90aGlzJF9yZW5kZXJTdGF0ZTUiLCJyZXN1bWVBbmltYXRpb24iLCJfdGhpcyRfcmVuZGVyU3RhdGU2IiwiX3RoaXMkX3JlbmRlclN0YXRlNyIsIl9vcHRpb25zJG9uQ29tcGxldGU2IiwiaGlkZU91dGxpbmUiLCJfdGhpcyRfcmVuZGVyU3RhdGU4IiwiX29wdGlvbnMkb25Db21wbGV0ZTciLCJfaGFuemlXcml0ZXJSZW5kZXJlciIsImhhbnppV3JpdGVyUmVuZGVyZXIiLCJfaW5pdEFuZE1vdW50SGFuemlXcml0ZXJSZW5kZXJlciIsIl9xdWl6IiwiX29wdGlvbnMkZHVyYXRpb24iLCJmaXhlZENvbG9yVmFsIiwibWFwcGVkQ29sb3IiLCJfdGhpcyRfcmVuZGVyU3RhdGU5IiwiX29wdGlvbnMkb25Db21wbGV0ZTgiLCJxdWl6IiwicXVpek9wdGlvbnMiLCJza2lwUXVpelN0cm9rZSIsIl9jaGFyIiwiX3dpdGhEYXRhUHJvbWlzZSIsInBhdGhTdHJpbmdzIiwiX3JlbmRlcmVyIiwiZ2V0Q2hhcmFjdGVyRGF0YSIsIl9hc3NpZ25PcHRpb25zIiwibWVyZ2VkT3B0aW9ucyIsInN0cm9rZUFuaW1hdGlvbkR1cmF0aW9uIiwiX2ZpbGxXaWR0aEFuZEhlaWdodCIsImZpbGxlZE9wdHMiLCJtaW5EaW0iLCJmdW5jIiwiX3NldHVwTGlzdGVuZXJzIiwiX3RoaXMkX3F1aXoiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/hanzi-writer/dist/index.esm.js\n"));

/***/ })

}]);