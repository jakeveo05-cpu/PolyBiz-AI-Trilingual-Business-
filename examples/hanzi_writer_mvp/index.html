<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PolyBiz AI - Hanzi Writer MVP</title>
    <script src="https://cdn.jsdelivr.net/npm/hanzi-writer@3.5/dist/hanzi-writer.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh; color: #fff; padding: 20px;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        h1 { text-align: center; margin-bottom: 10px; font-size: 1.8em; }
        .subtitle { text-align: center; color: #888; margin-bottom: 20px; }
        
        /* Performance Monitor */
        #perf-monitor {
            position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.8);
            padding: 15px; border-radius: 10px; font-family: monospace; font-size: 12px;
            z-index: 1000; min-width: 200px;
        }
        .perf-row { display: flex; justify-content: space-between; margin: 5px 0; }
        .perf-label { color: #888; }
        .perf-value { color: #4ade80; font-weight: bold; }
        .perf-warning { color: #fbbf24; }
        .perf-danger { color: #ef4444; }
</style>
</head>
<body>
    <div class="container">
        <h1>üÄÑ PolyBiz AI - Hanzi Writer MVP</h1>
        <p class="subtitle">Test hi·ªáu nƒÉng Air Writing + Character Animation</p>
        
        <!-- Performance Monitor -->
        <div id="perf-monitor">
            <div style="font-weight:bold; margin-bottom:10px; color:#60a5fa;">üìä Performance</div>
            <div class="perf-row"><span class="perf-label">FPS:</span><span id="fps" class="perf-value">--</span></div>
            <div class="perf-row"><span class="perf-label">Memory:</span><span id="memory" class="perf-value">--</span></div>
            <div class="perf-row"><span class="perf-label">CPU Load:</span><span id="cpu" class="perf-value">--</span></div>
            <div class="perf-row"><span class="perf-label">Hand Track:</span><span id="hand-status" class="perf-value">OFF</span></div>
            <hr style="border-color:#333; margin:10px 0;">
            <div class="perf-row"><span class="perf-label">Browser:</span><span id="browser" class="perf-value">--</span></div>
            <div class="perf-row"><span class="perf-label">Screen:</span><span id="screen" class="perf-value">--</span></div>
        </div>
</body>
</html>

        <!-- Word List Manager -->
        <div class="card wordlist-card">
            <div class="card-header">
                <span>üìñ Qu·∫£n l√Ω t·ª´ v·ª±ng</span>
                <span id="wordlist-count" class="status-badge status-on">10 ch·ªØ</span>
            </div>
            
            <div class="wordlist-tabs">
                <button class="tab-btn active" data-tab="preset">üìö C√≥ s·∫µn</button>
                <button class="tab-btn" data-tab="custom">‚úèÔ∏è Nh·∫≠p t√πy ch·ªçn</button>
                <button class="tab-btn" data-tab="import">üì• Import</button>
            </div>
            
            <!-- Tab: Preset Lists -->
            <div id="tab-preset" class="tab-content active">
                <div class="preset-grid">
                    <div class="preset-category">
                        <label>Tr√¨nh ƒë·ªô HSK:</label>
                        <select id="hsk-level">
                            <option value="">-- Ch·ªçn --</option>
                            <option value="hsk1">HSK 1 (150 ch·ªØ)</option>
                            <option value="hsk2">HSK 2 (150 ch·ªØ)</option>
                            <option value="hsk3">HSK 3 (300 ch·ªØ)</option>
                            <option value="hsk4">HSK 4 (600 ch·ªØ)</option>
                        </select>
                    </div>
                    <div class="preset-category">
                        <label>B·ªô th·ªß:</label>
                        <select id="radical-select">
                            <option value="">-- Ch·ªçn --</option>
                            <option value="‰∫∫">‰∫∫ (ng∆∞·ªùi)</option>
                            <option value="Âè£">Âè£ (mi·ªáng)</option>
                            <option value="Â•≥">Â•≥ (n·ªØ)</option>
                            <option value="ÂøÉ">ÂøÉ (tim)</option>
                            <option value="Êâã">Êâã (tay)</option>
                            <option value="Ê∞¥">Ê∞¥ (n∆∞·ªõc)</option>
                            <option value="ÁÅ´">ÁÅ´ (l·ª≠a)</option>
                            <option value="Êú®">Êú® (c√¢y)</option>
                            <option value="Èáë">Èáë (kim lo·∫°i)</option>
                            <option value="Âúü">Âúü (ƒë·∫•t)</option>
                        </select>
                    </div>
                    <div class="preset-category">
                        <label>Chuy√™n ng√†nh:</label>
                        <select id="topic-select">
                            <option value="">-- Ch·ªçn --</option>
                            <option value="business">Kinh doanh</option>
                            <option value="it">C√¥ng ngh·ªá IT</option>
                            <option value="medical">Y t·∫ø</option>
                            <option value="legal">Ph√°p lu·∫≠t</option>
                            <option value="finance">T√†i ch√≠nh</option>
                        </select>
                    </div>
                    <div class="preset-category">
                        <label>ƒê·∫∑c bi·ªát:</label>
                        <select id="special-select">
                            <option value="">-- Ch·ªçn --</option>
                            <option value="confusing">D·ªÖ nh·∫ßm l·∫´n</option>
                            <option value="numbers">S·ªë ƒë·∫øm</option>
                            <option value="time">Th·ªùi gian</option>
                            <option value="colors">M√†u s·∫Øc</option>
                            <option value="family">Gia ƒë√¨nh</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <!-- Tab: Custom Input -->
            <div id="tab-custom" class="tab-content">
                <div class="custom-input-area">
                    <label>Nh·∫≠p ch·ªØ mu·ªën luy·ªán (m·ªói ch·ªØ c√°ch nhau b·ªüi d·∫•u c√°ch ho·∫∑c xu·ªëng d√≤ng):</label>
                    <textarea id="custom-chars" placeholder="Â•Ω ‰Ω† Êàë ‰ªñ ÊòØ&#10;‰∏≠ ÂõΩ ‰∫∫ Â§ß Â≠¶&#10;&#10;Ho·∫∑c d√°n ƒëo·∫°n vƒÉn ti·∫øng Trung v√†o ƒë√¢y..."></textarea>
                    <div class="btn-group" style="margin-top:10px;">
                        <button id="btn-parse-custom" class="btn btn-primary">üìù Tr√≠ch xu·∫•t ch·ªØ</button>
                        <button id="btn-add-favorite" class="btn btn-warning">‚≠ê Th√™m v√†o y√™u th√≠ch</button>
                    </div>
                </div>
            </div>
            
            <!-- Tab: Import -->
            <div id="tab-import" class="tab-content">
                <div class="import-options">
                    <div class="import-option">
                        <label>üìÑ Import t·ª´ CSV/Google Sheet:</label>
                        <input type="file" id="csv-import" accept=".csv,.txt">
                        <small>Format: m·ªói d√≤ng 1 ch·ªØ, ho·∫∑c c·ªôt ƒë·∫ßu ti√™n ch·ª©a ch·ªØ H√°n</small>
                    </div>
                    <div class="import-option">
                        <label>üÉè Import t·ª´ Anki Deck (export .txt):</label>
                        <input type="file" id="anki-import" accept=".txt,.csv">
                        <small>Export deck t·ª´ Anki ‚Üí File ‚Üí Export ‚Üí Notes in Plain Text</small>
                    </div>
                    <div class="import-option">
                        <label>‚≠ê Danh s√°ch y√™u th√≠ch:</label>
                        <button id="btn-load-favorites" class="btn btn-warning btn-sm">T·∫£i y√™u th√≠ch</button>
                        <span id="favorites-count" style="margin-left:10px;color:#888;">0 ch·ªØ</span>
                    </div>
                </div>
            </div>
            
            <!-- Current Word List Preview -->
            <div class="wordlist-preview">
                <div class="preview-header">
                    <span>Danh s√°ch hi·ªán t·∫°i:</span>
                    <div>
                        <button id="btn-shuffle" class="btn btn-sm btn-secondary">üîÄ X√°o tr·ªôn</button>
                        <button id="btn-clear-list" class="btn btn-sm btn-secondary">üóëÔ∏è X√≥a</button>
                    </div>
                </div>
                <div id="wordlist-preview-chars" class="preview-chars">
                    <!-- Chars will be rendered here -->
                </div>
            </div>
            
            <!-- Practice Controls -->
            <div class="practice-controls">
                <label>S·ªë ch·ªØ luy·ªán: <input type="number" id="practice-count" value="10" min="1" max="100"></label>
                <button id="btn-start-session" class="btn btn-success">üöÄ B·∫Øt ƒë·∫ßu luy·ªán</button>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-grid">
            <!-- Character Display -->
            <div class="card">
                <div class="card-header">
                    <span>üìö H·ªçc ch·ªØ</span>
                    <div style="display:flex;align-items:center;gap:10px;">
                        <span id="session-progress" style="font-size:12px;color:#888;">--</span>
                        <select id="char-select">
                            <option value="Â•Ω">Â•Ω (h«éo) - T·ªët</option>
                            <option value="‰Ω†">‰Ω† (n«ê) - B·∫°n</option>
                            <option value="Êàë">Êàë (w«í) - T√¥i</option>
                            <option value="‰ªñ">‰ªñ (tƒÅ) - Anh ·∫•y</option>
                            <option value="ÊòØ">ÊòØ (sh√¨) - L√†</option>
                            <option value="‰∏≠">‰∏≠ (zh≈çng) - Gi·ªØa</option>
                            <option value="ÂõΩ">ÂõΩ (gu√≥) - N∆∞·ªõc</option>
                            <option value="‰∫∫">‰∫∫ (r√©n) - Ng∆∞·ªùi</option>
                            <option value="Â§ß">Â§ß (d√†) - L·ªõn</option>
                            <option value="Â≠¶">Â≠¶ (xu√©) - H·ªçc</option>
                        </select>
                    </div>
                </div>
                <div class="char-display">
                    <div id="character-target" class="hanzi-box"></div>
                    <div class="char-info">
                        <div id="char-pinyin" class="pinyin">h«éo</div>
                        <div id="char-meaning" class="meaning">T·ªët, Th√≠ch</div>
                        <div id="char-radical" class="radical">B·ªô: Â•≥ (n·ªØ) + Â≠ê (con)</div>
                    </div>
                </div>
                <div class="btn-group">
                    <button id="btn-prev-char" class="btn btn-secondary">‚¨ÖÔ∏è Tr∆∞·ªõc</button>
                    <button id="btn-animate" class="btn btn-primary">‚ñ∂Ô∏è Animation</button>
                    <button id="btn-quiz" class="btn btn-success">‚úçÔ∏è Quiz Mode</button>
                    <button id="btn-next-char" class="btn btn-secondary">Sau ‚û°Ô∏è</button>
                </div>
            </div>

            <!-- Air Writing -->
            <div class="card">
                <div class="card-header">
                    <span>üéØ Air Writing <span style="background:#f59e0b;color:#000;padding:2px 6px;border-radius:4px;font-size:10px;margin-left:5px;">BETA</span></span>
                    <span id="air-status" class="status-badge status-off">Camera OFF</span>
                </div>
                <div class="air-writing-area">
                    <video id="webcam" autoplay playsinline></video>
                    <canvas id="draw-canvas"></canvas>
                    <div id="webcam-placeholder">
                        <div>üìπ</div>
                        <div>Click "B·∫≠t Camera" ƒë·ªÉ b·∫Øt ƒë·∫ßu</div>
                    </div>
                </div>
                <div class="btn-group">
                    <button id="btn-camera" class="btn btn-primary">üìπ B·∫≠t Camera</button>
                    <button id="btn-draw-toggle" class="btn btn-success" style="display:none;">‚úèÔ∏è Gi·ªØ ƒë·ªÉ v·∫Ω (Space)</button>
                    <button id="btn-undo" class="btn btn-secondary">‚Ü©Ô∏è Undo</button>
                    <button id="btn-clear" class="btn btn-secondary">üóëÔ∏è X√≥a</button>
                </div>
                <p style="font-size:11px;color:#888;margin-top:10px;text-align:center;">
                    Gi·ªØ ph√≠m <kbd style="background:#333;padding:2px 6px;border-radius:3px;">Space</kbd> ho·∫∑c n√∫t "Gi·ªØ ƒë·ªÉ v·∫Ω" khi mu·ªën v·∫Ω
                </p>
            </div>

            <!-- Practice Canvas -->
            <div class="card">
                <div class="card-header">
                    <span>‚úèÔ∏è Luy·ªán vi·∫øt (Chu·ªôt/Touch)</span>
                </div>
                <div id="practice-target" class="hanzi-box practice-box"></div>
                <div class="score-display">
                    <span>ƒêi·ªÉm: </span><span id="score">--</span>
                </div>
            </div>
        </div>

        <!-- Mnemonic & Illustration -->
        <div class="card mnemonic-card">
            <div class="card-header">
                <span>üß† Ghi nh·ªõ ch·ªØ</span>
                <span id="mnemonic-char" style="font-size:1.5em;font-family:'Noto Sans SC',serif;color:#f5576c;">Â•Ω</span>
            </div>
            
            <!-- Illustration - Dynamic per character -->
            <div class="mnemonic-illustration">
                <div id="illust-container" class="illust-container">
                    <!-- Will be populated by JavaScript -->
                </div>
            </div>
            
            <!-- Mnemonic text -->
            <div class="mnemonic-text">
                <div id="mnemonic-quote" class="mnemonic-quote">
                    "C√≥ <span style="color:#f5576c;">M·∫∏</span> √¥m <span style="color:#4facfe;">CON</span> = ƒêi·ªÅu <span style="color:#feca57;">T·ªêT ƒê·∫∏P</span> nh·∫•t!"
                </div>
            </div>
            
            <!-- Quick examples -->
            <div id="mnemonic-examples" class="mnemonic-examples">
                <div class="example-chip">‰Ω†Â•Ω = Xin ch√†o</div>
                <div class="example-chip">Â•ΩÂêÉ = Ngon</div>
                <div class="example-chip">Â•ΩÁúã = ƒê·∫πp</div>
            </div>
        </div>

        <!-- Results (collapsed) -->
        <div class="card results-card" style="margin-top:15px;">
            <div class="card-header" style="cursor:pointer;" onclick="toggleResults()">
                üìà K·∫øt qu·∫£ Test <span id="results-toggle" style="float:right;">‚ñº</span>
            </div>
            <div id="test-results" style="display:none;">
                <p>Nh·∫•n c√°c n√∫t ƒë·ªÉ test t·ª´ng t√≠nh nƒÉng. K·∫øt qu·∫£ s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y.</p>
            </div>
            <button id="btn-full-test" class="btn btn-warning" style="margin-top:15px;">
                üß™ Ch·∫°y Full Test (30 gi√¢y)
            </button>
        </div>
        
        <!-- SRS - Spaced Repetition System -->
        <div class="card srs-card">
            <div class="card-header">
                <span>üìä Th·ªëng k√™ & ƒê·ªÅ xu·∫•t √¥n t·∫≠p</span>
                <label style="font-size:12px;font-weight:normal;display:flex;align-items:center;gap:5px;">
                    <input type="checkbox" id="tts-toggle" checked> üîä Ph√°t √¢m
                </label>
            </div>
            <div class="srs-stats">
                <div class="srs-stat-item">
                    <span class="srs-stat-value" id="total-practice">0</span>
                    <span class="srs-stat-label">T·ªïng l∆∞·ª£t</span>
                </div>
                <div class="srs-stat-item">
                    <span class="srs-stat-value" id="avg-score">--%</span>
                    <span class="srs-stat-label">ƒêi·ªÉm TB</span>
                </div>
                <div class="srs-stat-item">
                    <span class="srs-stat-value" id="streak-count">0</span>
                    <span class="srs-stat-label">Streak üî•</span>
                </div>
            </div>
            
            <div class="srs-section">
                <div class="srs-section-title">üî¥ C·∫ßn √¥n t·∫≠p (sai nhi·ªÅu)</div>
                <div id="srs-weak" class="srs-char-list">
                    <span class="srs-empty">Ch∆∞a c√≥ d·ªØ li·ªáu</span>
                </div>
            </div>
            
            <div class="srs-section">
                <div class="srs-section-title">üü° ƒêang h·ªçc</div>
                <div id="srs-learning" class="srs-char-list">
                    <span class="srs-empty">Ch∆∞a c√≥ d·ªØ li·ªáu</span>
                </div>
            </div>
            
            <div class="srs-section">
                <div class="srs-section-title">üü¢ ƒê√£ thu·ªôc</div>
                <div id="srs-mastered" class="srs-char-list">
                    <span class="srs-empty">Ch∆∞a c√≥ d·ªØ li·ªáu</span>
                </div>
            </div>
            
            <div class="btn-group" style="margin-top:15px;">
                <button id="btn-suggest" class="btn btn-primary">üí° ƒê·ªÅ xu·∫•t √¥n t·∫≠p</button>
                <button id="btn-reset-srs" class="btn btn-secondary">üóëÔ∏è Reset d·ªØ li·ªáu</button>
            </div>
        </div>
    </div>

    <style>
        .main-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 20px; margin-bottom: 20px;
        }
        .card {
            background: rgba(255,255,255,0.05); border-radius: 15px;
            padding: 20px; backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .card-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 15px; font-weight: bold; font-size: 1.1em;
        }
        .hanzi-box {
            width: 200px; height: 200px; margin: 0 auto;
            background: rgba(255,255,255,0.1); border-radius: 10px;
        }
        .practice-box { background: #fff; }
        .char-display { text-align: center; margin-bottom: 15px; }
        .char-info { margin-top: 15px; }
        .pinyin { font-size: 1.5em; color: #60a5fa; }
        .meaning { font-size: 1.2em; margin: 5px 0; }
        .radical { color: #888; font-size: 0.9em; }
        
        .btn-group { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
        .btn {
            padding: 10px 20px; border: none; border-radius: 8px;
            cursor: pointer; font-size: 14px; transition: all 0.2s;
        }
        .btn-primary { background: #3b82f6; color: #fff; }
        .btn-success { background: #22c55e; color: #fff; }
        .btn-secondary { background: #6b7280; color: #fff; }
        .btn-warning { background: #f59e0b; color: #000; }
        .btn:hover { transform: scale(1.05); filter: brightness(1.1); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .btn-active { background: #16a34a !important; transform: scale(0.95); box-shadow: inset 0 2px 4px rgba(0,0,0,0.3); }
        
        .status-badge {
            padding: 4px 10px; border-radius: 20px; font-size: 12px;
        }
        .status-off { background: #ef4444; }
        .status-on { background: #22c55e; }
        
        .air-writing-area {
            position: relative; width: 100%; aspect-ratio: 4/3;
            background: #000; border-radius: 10px; overflow: hidden; margin-bottom: 15px;
        }
        #webcam {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            opacity: 0.15;
            filter: grayscale(100%);
            transform: scaleX(-1); /* Mirror camera */
        }
        #draw-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        }
        #webcam-placeholder {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center;
            align-items: center; color: #666; font-size: 14px;
        }
        #webcam-placeholder div:first-child { font-size: 48px; margin-bottom: 10px; }
        
        .score-display { text-align: center; margin-top: 15px; font-size: 1.2em; }
        #score { color: #4ade80; font-weight: bold; }
        
        .results-card { margin-top: 20px; }
        
        /* Mnemonic Card Styles */
        .mnemonic-card { margin-top: 20px; background: linear-gradient(135deg, rgba(245,87,108,0.1) 0%, rgba(79,172,254,0.1) 100%); }
        .mnemonic-illustration { padding: 20px 0; }
        .illust-container {
            display: flex; align-items: center; justify-content: center;
            gap: 20px; flex-wrap: wrap;
        }
        .illust-item { 
            text-align: center; 
            padding: 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 12px;
            min-width: 80px;
            transition: transform 0.2s;
        }
        .illust-item:hover { transform: scale(1.05); }
        .illust-item.result { 
            background: rgba(254,202,87,0.15);
            border: 2px solid rgba(254,202,87,0.3);
        }
        .illust-emoji { margin-bottom: 5px; }
        .illust-char { margin-bottom: 3px; }
        .illust-label { font-size: 0.9em; color: #aaa; }
        .illust-meaning { font-size: 0.85em; color: #888; margin-top: 3px; }
        .illust-plus, .illust-equals { font-size: 2em; color: #666; font-weight: bold; }
        .mnemonic-text {
            text-align: center; padding: 15px;
            background: rgba(0,0,0,0.2); border-radius: 10px; margin: 15px 0;
        }
        .mnemonic-quote { font-size: 1.2em; line-height: 1.6; }
        .mnemonic-examples {
            display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;
        }
        .example-chip {
            padding: 8px 15px; background: rgba(255,255,255,0.1);
            border-radius: 20px; font-size: 0.9em;
            transition: background 0.2s;
        }
        .example-chip:hover { background: rgba(255,255,255,0.2); }
        
        /* Word List Manager Styles */
        .wordlist-card { margin-bottom: 20px; }
        .wordlist-tabs { display: flex; gap: 5px; margin-bottom: 15px; }
        .tab-btn {
            padding: 8px 16px; border: none; background: rgba(255,255,255,0.1);
            color: #aaa; border-radius: 8px 8px 0 0; cursor: pointer; transition: all 0.2s;
        }
        .tab-btn.active { background: rgba(59,130,246,0.3); color: #fff; }
        .tab-btn:hover { background: rgba(255,255,255,0.2); }
        .tab-content { display: none; padding: 15px; background: rgba(0,0,0,0.2); border-radius: 0 10px 10px 10px; }
        .tab-content.active { display: block; }
        
        .preset-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }
        .preset-category label { display: block; font-size: 0.85em; color: #888; margin-bottom: 5px; }
        .preset-category select { width: 100%; padding: 8px; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid #444; border-radius: 5px; }
        
        .custom-input-area label { display: block; font-size: 0.85em; color: #888; margin-bottom: 8px; }
        .custom-input-area textarea {
            width: 100%; height: 100px; padding: 10px; background: rgba(255,255,255,0.1);
            color: #fff; border: 1px solid #444; border-radius: 8px; resize: vertical;
        }
        
        .import-options { display: flex; flex-direction: column; gap: 15px; }
        .import-option label { display: block; font-size: 0.9em; margin-bottom: 5px; }
        .import-option input[type="file"] { color: #aaa; }
        .import-option small { display: block; color: #666; font-size: 0.8em; margin-top: 3px; }
        
        .wordlist-preview { margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.2); border-radius: 10px; }
        .preview-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .preview-chars { display: flex; flex-wrap: wrap; gap: 8px; max-height: 120px; overflow-y: auto; }
        .preview-char {
            padding: 5px 10px; background: rgba(255,255,255,0.1); border-radius: 5px;
            cursor: pointer; transition: all 0.2s; font-size: 1.2em;
        }
        .preview-char:hover { background: rgba(59,130,246,0.4); transform: scale(1.1); }
        .preview-char.current { background: rgba(34,197,94,0.4); border: 2px solid #22c55e; }
        
        .practice-controls {
            display: flex; justify-content: space-between; align-items: center;
            margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1);
        }
        .practice-controls label { display: flex; align-items: center; gap: 8px; }
        .practice-controls input[type="number"] {
            width: 60px; padding: 5px; background: rgba(255,255,255,0.1);
            color: #fff; border: 1px solid #444; border-radius: 5px; text-align: center;
        }
        
        .btn-sm { padding: 5px 10px; font-size: 12px; }
        
        /* SRS Styles */
        .srs-card { margin-top: 20px; }
        .srs-stats {
            display: flex; justify-content: space-around; margin-bottom: 20px;
            padding: 15px; background: rgba(0,0,0,0.2); border-radius: 10px;
        }
        .srs-stat-item { text-align: center; }
        .srs-stat-value { display: block; font-size: 1.8em; font-weight: bold; color: #60a5fa; }
        .srs-stat-label { font-size: 0.85em; color: #888; }
        .srs-section { margin-bottom: 15px; }
        .srs-section-title { font-size: 0.9em; color: #aaa; margin-bottom: 8px; }
        .srs-char-list { display: flex; flex-wrap: wrap; gap: 8px; min-height: 40px; }
        .srs-char {
            display: inline-flex; flex-direction: column; align-items: center;
            padding: 8px 12px; background: rgba(255,255,255,0.1); border-radius: 8px;
            cursor: pointer; transition: all 0.2s;
        }
        .srs-char:hover { transform: scale(1.1); background: rgba(255,255,255,0.2); }
        .srs-char-hanzi { font-size: 1.5em; }
        .srs-char-score { font-size: 0.7em; color: #888; }
        .srs-char.weak { border-left: 3px solid #ef4444; }
        .srs-char.learning { border-left: 3px solid #f59e0b; }
        .srs-char.mastered { border-left: 3px solid #22c55e; }
        .srs-empty { color: #666; font-style: italic; font-size: 0.9em; }
        #test-results { 
            background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px;
            font-family: monospace; font-size: 13px; line-height: 1.6;
            max-height: 300px; overflow-y: auto;
        }
        
        select {
            background: rgba(255,255,255,0.1); color: #fff; border: 1px solid #444;
            padding: 5px 10px; border-radius: 5px;
        }
    </style>

    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>

    <script>
        // ============ PERFORMANCE MONITOR ============
        const perfData = {
            fps: [], memory: [], cpuStart: 0, frameCount: 0, lastTime: performance.now()
        };

        function updatePerformance() {
            const now = performance.now();
            perfData.frameCount++;
            
            if (now - perfData.lastTime >= 1000) {
                const fps = Math.round(perfData.frameCount * 1000 / (now - perfData.lastTime));
                perfData.fps.push(fps);
                document.getElementById('fps').textContent = fps;
                document.getElementById('fps').className = 
                    fps >= 30 ? 'perf-value' : fps >= 15 ? 'perf-warning' : 'perf-danger';
                
                if (performance.memory) {
                    const memMB = Math.round(performance.memory.usedJSHeapSize / 1048576);
                    perfData.memory.push(memMB);
                    document.getElementById('memory').textContent = memMB + ' MB';
                    document.getElementById('memory').className = 
                        memMB < 100 ? 'perf-value' : memMB < 200 ? 'perf-warning' : 'perf-danger';
                }
                
                perfData.frameCount = 0;
                perfData.lastTime = now;
            }
            requestAnimationFrame(updatePerformance);
        }

        // Browser & Screen info
        function getDeviceInfo() {
            const ua = navigator.userAgent;
            let browser = 'Unknown';
            if (ua.includes('Chrome')) browser = 'Chrome';
            else if (ua.includes('Firefox')) browser = 'Firefox';
            else if (ua.includes('Safari')) browser = 'Safari';
            else if (ua.includes('Edge')) browser = 'Edge';
            
            document.getElementById('browser').textContent = browser;
            document.getElementById('screen').textContent = 
                `${window.screen.width}x${window.screen.height}`;
            
            if (!performance.memory) {
                document.getElementById('memory').textContent = 'N/A';
            }
        }
</script>

    <script>
        // ============ HANZI WRITER ============
        let writer = null;
        let quizWriter = null;
        // Character data with illustrations
        const charData = {
            'Â•Ω': { 
                pinyin: 'h«éo', meaning: 'T·ªët, Th√≠ch', radical: 'Â•≥ (n·ªØ) + Â≠ê (con)',
                mnemonic: 'C√≥ <span style="color:#f5576c;">M·∫∏</span> √¥m <span style="color:#4facfe;">CON</span> = ƒêi·ªÅu <span style="color:#feca57;">T·ªêT ƒê·∫∏P</span> nh·∫•t!',
                examples: ['‰Ω†Â•Ω = Xin ch√†o', 'Â•ΩÂêÉ = Ngon', 'Â•ΩÁúã = ƒê·∫πp'],
                illustration: {
                    parts: [
                        { emoji: 'üë©', char: 'Â•≥', pinyin: 'n«ö', meaning: 'M·∫π', color: '#f5576c' },
                        { emoji: 'üë∂', char: 'Â≠ê', pinyin: 'z«ê', meaning: 'Con', color: '#4facfe' }
                    ],
                    result: { emoji: 'üíï', char: 'Â•Ω', pinyin: 'h«éo', meaning: 'T·ªët ƒë·∫πp!', color: '#feca57' }
                }
            },
            '‰Ω†': { 
                pinyin: 'n«ê', meaning: 'B·∫°n', radical: '‰∫ª (ng∆∞·ªùi) + Â∞î',
                mnemonic: '<span style="color:#f5576c;">NG∆Ø·ªúI</span> (‰∫ª) ƒë·ª©ng b√™n c·∫°nh <span style="color:#4facfe;">B·∫†N</span> (Â∞î) = <span style="color:#feca57;">B·∫†N</span>',
                examples: ['‰Ω†Â•Ω = Xin ch√†o', '‰Ω†‰ª¨ = C√°c b·∫°n'],
                illustration: {
                    parts: [
                        { emoji: 'üßç', char: '‰∫ª', pinyin: 'r√©n', meaning: 'Ng∆∞·ªùi', color: '#f5576c' },
                        { emoji: 'üëã', char: 'Â∞î', pinyin: 'ƒõr', meaning: 'Ng∆∞∆°i', color: '#4facfe' }
                    ],
                    result: { emoji: 'ü§ù', char: '‰Ω†', pinyin: 'n«ê', meaning: 'B·∫°n', color: '#feca57' }
                }
            },
            'Êàë': { 
                pinyin: 'w«í', meaning: 'T√¥i', radical: 'Êâã (tay) + Êàà (gi√°o)',
                mnemonic: '<span style="color:#f5576c;">TAY</span> c·∫ßm <span style="color:#4facfe;">GI√ÅO</span> b·∫£o v·ªá b·∫£n th√¢n = <span style="color:#feca57;">T√îI</span>',
                examples: ['ÊàëÊòØ = T√¥i l√†', 'Êàë‰ª¨ = Ch√∫ng t√¥i'],
                illustration: {
                    parts: [
                        { emoji: '‚úã', char: 'Êâã', pinyin: 'sh«íu', meaning: 'Tay', color: '#f5576c' },
                        { emoji: 'üó°Ô∏è', char: 'Êàà', pinyin: 'gƒì', meaning: 'Gi√°o', color: '#4facfe' }
                    ],
                    result: { emoji: 'üôã', char: 'Êàë', pinyin: 'w«í', meaning: 'T√¥i', color: '#feca57' }
                }
            },
            '‰ªñ': { 
                pinyin: 'tƒÅ', meaning: 'Anh ·∫•y', radical: '‰∫ª (ng∆∞·ªùi) + ‰πü',
                mnemonic: '<span style="color:#f5576c;">NG∆Ø·ªúI</span> (‰∫ª) + <span style="color:#4facfe;">C≈®NG</span> (‰πü) = Ng∆∞·ªùi kh√°c = <span style="color:#feca57;">ANH ·∫§Y</span>',
                examples: ['‰ªñÊòØ = Anh ·∫•y l√†', '‰ªñ‰ª¨ = H·ªç'],
                illustration: {
                    parts: [
                        { emoji: 'üßç', char: '‰∫ª', pinyin: 'r√©n', meaning: 'Ng∆∞·ªùi', color: '#f5576c' },
                        { emoji: '‚ûï', char: '‰πü', pinyin: 'yƒõ', meaning: 'C≈©ng', color: '#4facfe' }
                    ],
                    result: { emoji: 'üë®', char: '‰ªñ', pinyin: 'tƒÅ', meaning: 'Anh ·∫•y', color: '#feca57' }
                }
            },
            'ÊòØ': { 
                pinyin: 'sh√¨', meaning: 'L√†', radical: 'Êó• (m·∫∑t tr·ªùi) + Ê≠£',
                mnemonic: '<span style="color:#f5576c;">M·∫∂T TR·ªúI</span> (Êó•) chi·∫øu <span style="color:#4facfe;">CH√çNH</span> (Ê≠£) x√°c = <span style="color:#feca57;">L√Ä</span>',
                examples: ['ÊòØÁöÑ = ƒê√∫ng v·∫≠y', '‰∏çÊòØ = Kh√¥ng ph·∫£i'],
                illustration: {
                    parts: [
                        { emoji: '‚òÄÔ∏è', char: 'Êó•', pinyin: 'r√¨', meaning: 'M·∫∑t tr·ªùi', color: '#f5576c' },
                        { emoji: '‚úÖ', char: 'Ê≠£', pinyin: 'zh√®ng', meaning: 'Ch√≠nh', color: '#4facfe' }
                    ],
                    result: { emoji: 'üëç', char: 'ÊòØ', pinyin: 'sh√¨', meaning: 'L√†/ƒê√∫ng', color: '#feca57' }
                }
            },
            '‰∏≠': { 
                pinyin: 'zh≈çng', meaning: 'Gi·ªØa, Trung', radical: '‰∏® (n√©t s·ªï) + Âè£',
                mnemonic: 'N√©t s·ªï <span style="color:#f5576c;">‚îÇ</span> xuy√™n qua <span style="color:#4facfe;">MI·ªÜNG</span> (Âè£) = <span style="color:#feca57;">GI·ªÆA</span>',
                examples: ['‰∏≠ÂõΩ = Trung Qu·ªëc', '‰∏≠Èó¥ = ·ªû gi·ªØa'],
                illustration: {
                    parts: [
                        { emoji: 'üìç', char: '‰∏®', pinyin: 'g«în', meaning: 'N√©t s·ªï', color: '#f5576c' },
                        { emoji: '‚¨ú', char: 'Âè£', pinyin: 'k«íu', meaning: 'Mi·ªáng/√î', color: '#4facfe' }
                    ],
                    result: { emoji: 'üéØ', char: '‰∏≠', pinyin: 'zh≈çng', meaning: 'Gi·ªØa', color: '#feca57' }
                }
            },
            'ÂõΩ': { 
                pinyin: 'gu√≥', meaning: 'N∆∞·ªõc, Qu·ªëc gia', radical: 'Âõó (bao v√¢y) + Áéâ',
                mnemonic: '<span style="color:#f5576c;">BI√äN GI·ªöI</span> (Âõó) b·∫£o v·ªá <span style="color:#4facfe;">NG·ªåC</span> (Áéâ) = <span style="color:#feca57;">QU·ªêC GIA</span>',
                examples: ['‰∏≠ÂõΩ = Trung Qu·ªëc', 'ÂõΩÂÆ∂ = Qu·ªëc gia'],
                illustration: {
                    parts: [
                        { emoji: 'üî≤', char: 'Âõó', pinyin: 'w√©i', meaning: 'Bi√™n gi·ªõi', color: '#f5576c' },
                        { emoji: 'üíé', char: 'Áéâ', pinyin: 'y√π', meaning: 'Ng·ªçc', color: '#4facfe' }
                    ],
                    result: { emoji: 'üèõÔ∏è', char: 'ÂõΩ', pinyin: 'gu√≥', meaning: 'Qu·ªëc gia', color: '#feca57' }
                }
            },
            '‰∫∫': { 
                pinyin: 'r√©n', meaning: 'Ng∆∞·ªùi', radical: '‰∫∫ (ng∆∞·ªùi)',
                mnemonic: 'H√¨nh <span style="color:#feca57;">NG∆Ø·ªúI</span> ƒëang ƒëi - hai ch√¢n b∆∞·ªõc',
                examples: ['‰∫∫‰ª¨ = M·ªçi ng∆∞·ªùi', 'Â§ß‰∫∫ = Ng∆∞·ªùi l·ªõn'],
                illustration: {
                    parts: [
                        { emoji: 'ü¶µ', char: '‰∏ø', pinyin: 'piƒõ', meaning: 'Ch√¢n tr√°i', color: '#f5576c' },
                        { emoji: 'ü¶µ', char: '„áè', pinyin: 'n√†', meaning: 'Ch√¢n ph·∫£i', color: '#4facfe' }
                    ],
                    result: { emoji: 'üö∂', char: '‰∫∫', pinyin: 'r√©n', meaning: 'Ng∆∞·ªùi', color: '#feca57' }
                }
            },
            'Â§ß': { 
                pinyin: 'd√†', meaning: 'L·ªõn, To', radical: 'Â§ß (l·ªõn)',
                mnemonic: '<span style="color:#feca57;">NG∆Ø·ªúI</span> dang tay ra = <span style="color:#feca57;">L·ªöN</span>',
                examples: ['Â§ßÂÆ∂ = M·ªçi ng∆∞·ªùi', 'Â§ßÂ≠¶ = ƒê·∫°i h·ªçc'],
                illustration: {
                    parts: [
                        { emoji: 'üßç', char: '‰∫∫', pinyin: 'r√©n', meaning: 'Ng∆∞·ªùi', color: '#f5576c' },
                        { emoji: 'üôÜ', char: '‰∏Ä', pinyin: 'yƒ´', meaning: 'Dang tay', color: '#4facfe' }
                    ],
                    result: { emoji: 'ü¶∏', char: 'Â§ß', pinyin: 'd√†', meaning: 'L·ªõn', color: '#feca57' }
                }
            },
            'Â≠¶': { 
                pinyin: 'xu√©', meaning: 'H·ªçc', radical: 'Â≠ê (con) + ÂÜñ',
                mnemonic: '<span style="color:#4facfe;">TR·∫∫ CON</span> (Â≠ê) d∆∞·ªõi <span style="color:#f5576c;">M√ÅI NH√Ä</span> (ÂÜñ) = <span style="color:#feca57;">H·ªåC</span>',
                examples: ['Â≠¶‰π† = H·ªçc t·∫≠p', 'Â≠¶Áîü = H·ªçc sinh'],
                illustration: {
                    parts: [
                        { emoji: 'üè†', char: 'ÂÜñ', pinyin: 'm√¨', meaning: 'M√°i nh√†', color: '#f5576c' },
                        { emoji: 'üë∂', char: 'Â≠ê', pinyin: 'z«ê', meaning: 'Tr·∫ª con', color: '#4facfe' }
                    ],
                    result: { emoji: 'üìö', char: 'Â≠¶', pinyin: 'xu√©', meaning: 'H·ªçc', color: '#feca57' }
                }
            }
        };
        
        // Update mnemonic display when character changes
        function updateMnemonicDisplay(char) {
            const data = charData[char];
            if (!data) return;
            
            // Update character display
            document.getElementById('mnemonic-char').textContent = char;
            
            // Update mnemonic quote
            const quoteEl = document.getElementById('mnemonic-quote');
            if (quoteEl) quoteEl.innerHTML = data.mnemonic || '';
            
            // Update examples
            const examplesContainer = document.getElementById('mnemonic-examples');
            if (examplesContainer) {
                examplesContainer.innerHTML = '';
                if (data.examples) {
                    data.examples.forEach(ex => {
                        const chip = document.createElement('div');
                        chip.className = 'example-chip';
                        chip.textContent = ex;
                        examplesContainer.appendChild(chip);
                    });
                }
            }
            
            // Update illustration
            const illustContainer = document.getElementById('illust-container');
            if (illustContainer && data.illustration) {
                const { parts, result } = data.illustration;
                let html = '';
                
                // Render parts
                parts.forEach((part, i) => {
                    html += `
                        <div class="illust-item">
                            <div class="illust-emoji" style="font-size:2.5em;">${part.emoji}</div>
                            <div class="illust-char" style="font-size:1.8em;color:${part.color};font-family:'Noto Sans SC',serif;">${part.char}</div>
                            <div class="illust-label">${part.pinyin}</div>
                            <div class="illust-meaning">${part.meaning}</div>
                        </div>
                    `;
                    if (i < parts.length - 1) {
                        html += '<div class="illust-plus">+</div>';
                    }
                });
                
                // Render result
                html += `
                    <div class="illust-equals">=</div>
                    <div class="illust-item result">
                        <div class="illust-emoji" style="font-size:3em;">${result.emoji}</div>
                        <div class="illust-char" style="font-size:2.2em;color:${result.color};font-family:'Noto Sans SC',serif;font-weight:bold;">${result.char}</div>
                        <div class="illust-label" style="color:${result.color};">${result.pinyin}</div>
                        <div class="illust-meaning" style="color:${result.color};font-weight:bold;">${result.meaning}</div>
                    </div>
                `;
                
                illustContainer.innerHTML = html;
            }
        }

        function initHanziWriter(char) {
            document.getElementById('character-target').innerHTML = '';
            updateMnemonicDisplay(char);
            writer = HanziWriter.create('character-target', char, {
                width: 200, height: 200,
                padding: 5,
                strokeAnimationSpeed: 1,
                delayBetweenStrokes: 200,
                strokeColor: '#3b82f6',
                radicalColor: '#ef4444',
                showOutline: true,
                showCharacter: true
            });
            
            const data = charData[char];
            document.getElementById('char-pinyin').textContent = data.pinyin;
            document.getElementById('char-meaning').textContent = data.meaning;
            document.getElementById('char-radical').textContent = 'B·ªô: ' + data.radical;
        }

        function initQuizWriter(char) {
            document.getElementById('practice-target').innerHTML = '';
            quizWriter = HanziWriter.create('practice-target', char, {
                width: 200, height: 200,
                padding: 5,
                showCharacter: false,
                showOutline: true,
                showHintAfterMisses: 3,
                highlightOnComplete: true,
                strokeColor: '#22c55e',
                drawingColor: '#3b82f6',
                outlineColor: '#ddd',
                highlightColor: '#4ade80'
            });
        }

        document.getElementById('btn-animate').addEventListener('click', () => {
            if (writer) writer.animateCharacter();
        });

        document.getElementById('btn-quiz').addEventListener('click', () => {
            const char = document.getElementById('char-select').value;
            initQuizWriter(char);
            quizWriter.quiz({
                onComplete: (data) => {
                    const score = Math.round((1 - data.totalMistakes / 10) * 100);
                    document.getElementById('score').textContent = Math.max(0, score) + '%';
                    logResult(`‚úÖ Quiz ho√†n th√†nh! ƒêi·ªÉm: ${Math.max(0, score)}%, L·ªói: ${data.totalMistakes}`);
                    
                    // SRS: L∆∞u k·∫øt qu·∫£
                    srsRecordPractice(char, Math.max(0, score));
                    
                    // TTS: Ph√°t √¢m ch·ªØ
                    if (document.getElementById('tts-toggle').checked) {
                        speakChinese(char);
                    }
                }
            });
        });

        document.getElementById('char-select').addEventListener('change', (e) => {
            initHanziWriter(e.target.value);
            currentChar = e.target.value;
            // X√≥a n√©t c≈© khi ƒë·ªïi ch·ªØ
            clearCanvas();
        });
    </script>
    
    <script>
        // ============ SRS - SPACED REPETITION SYSTEM ============
        const SRS_KEY = 'polybiz_srs_data';
        
        // Load SRS data t·ª´ localStorage
        function srsLoadData() {
            const saved = localStorage.getItem(SRS_KEY);
            if (saved) {
                return JSON.parse(saved);
            }
            return {
                chars: {}, // { 'Â•Ω': { attempts: 5, totalScore: 420, lastPractice: timestamp, streak: 2 } }
                totalPractice: 0,
                currentStreak: 0,
                lastPracticeDate: null
            };
        }
        
        // Save SRS data
        function srsSaveData(data) {
            localStorage.setItem(SRS_KEY, JSON.stringify(data));
        }
        
        // Ghi nh·∫≠n k·∫øt qu·∫£ luy·ªán t·∫≠p
        function srsRecordPractice(char, score) {
            const data = srsLoadData();
            const today = new Date().toDateString();
            
            // C·∫≠p nh·∫≠t streak
            if (data.lastPracticeDate !== today) {
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                if (data.lastPracticeDate === yesterday.toDateString()) {
                    data.currentStreak++;
                } else {
                    data.currentStreak = 1;
                }
                data.lastPracticeDate = today;
            }
            
            // C·∫≠p nh·∫≠t char data
            if (!data.chars[char]) {
                data.chars[char] = { attempts: 0, totalScore: 0, lastPractice: 0, streak: 0 };
            }
            
            const charData = data.chars[char];
            charData.attempts++;
            charData.totalScore += score;
            charData.lastPractice = Date.now();
            
            // Streak cho t·ª´ng ch·ªØ (li√™n ti·∫øp ƒë·∫°t >= 80%)
            if (score >= 80) {
                charData.streak++;
            } else {
                charData.streak = 0;
            }
            
            data.totalPractice++;
            srsSaveData(data);
            srsUpdateUI();
        }
        
        // C·∫≠p nh·∫≠t UI
        function srsUpdateUI() {
            const data = srsLoadData();
            
            // Stats
            document.getElementById('total-practice').textContent = data.totalPractice;
            document.getElementById('streak-count').textContent = data.currentStreak;
            
            // T√≠nh ƒëi·ªÉm trung b√¨nh
            let totalScore = 0, totalAttempts = 0;
            Object.values(data.chars).forEach(c => {
                totalScore += c.totalScore;
                totalAttempts += c.attempts;
            });
            const avgScore = totalAttempts > 0 ? Math.round(totalScore / totalAttempts) : 0;
            document.getElementById('avg-score').textContent = avgScore + '%';
            
            // Ph√¢n lo·∫°i ch·ªØ
            const weak = [], learning = [], mastered = [];
            
            Object.entries(data.chars).forEach(([char, info]) => {
                const avg = Math.round(info.totalScore / info.attempts);
                const item = { char, avg, attempts: info.attempts, streak: info.streak };
                
                if (avg < 60 || info.streak === 0) {
                    weak.push(item);
                } else if (avg < 85 || info.streak < 3) {
                    learning.push(item);
                } else {
                    mastered.push(item);
                }
            });
            
            // Render lists
            renderSRSList('srs-weak', weak, 'weak');
            renderSRSList('srs-learning', learning, 'learning');
            renderSRSList('srs-mastered', mastered, 'mastered');
        }
        
        function renderSRSList(elementId, items, className) {
            const container = document.getElementById(elementId);
            if (items.length === 0) {
                container.innerHTML = '<span class="srs-empty">Ch∆∞a c√≥ d·ªØ li·ªáu</span>';
                return;
            }
            
            // Sort: weak by lowest score, others by attempts
            items.sort((a, b) => className === 'weak' ? a.avg - b.avg : b.attempts - a.attempts);
            
            container.innerHTML = items.map(item => `
                <div class="srs-char ${className}" onclick="selectChar('${item.char}')" title="Luy·ªán ${item.attempts} l·∫ßn, streak: ${item.streak}">
                    <span class="srs-char-hanzi">${item.char}</span>
                    <span class="srs-char-score">${item.avg}%</span>
                </div>
            `).join('');
        }
        
        // Click v√†o ch·ªØ ƒë·ªÉ ch·ªçn luy·ªán
        function selectChar(char) {
            document.getElementById('char-select').value = char;
            initHanziWriter(char);
            currentChar = char;
            clearCanvas();
            // Scroll l√™n
            document.querySelector('.main-grid').scrollIntoView({ behavior: 'smooth' });
        }
        
        // ƒê·ªÅ xu·∫•t √¥n t·∫≠p (∆∞u ti√™n ch·ªØ y·∫øu + l√¢u kh√¥ng luy·ªán)
        document.getElementById('btn-suggest').addEventListener('click', () => {
            const data = srsLoadData();
            const chars = Object.entries(data.chars);
            
            if (chars.length === 0) {
                alert('Ch∆∞a c√≥ d·ªØ li·ªáu! H√£y luy·ªán vi·∫øt m·ªôt v√†i ch·ªØ tr∆∞·ªõc.');
                return;
            }
            
            // T√≠nh ƒëi·ªÉm ∆∞u ti√™n: ƒëi·ªÉm th·∫•p + l√¢u kh√¥ng luy·ªán = ∆∞u ti√™n cao
            const now = Date.now();
            const scored = chars.map(([char, info]) => {
                const avg = info.totalScore / info.attempts;
                const daysSince = (now - info.lastPractice) / (1000 * 60 * 60 * 24);
                const priority = (100 - avg) + daysSince * 10 - info.streak * 5;
                return { char, priority, avg: Math.round(avg) };
            });
            
            scored.sort((a, b) => b.priority - a.priority);
            const suggested = scored[0];
            
            selectChar(suggested.char);
            logResult(`üí° ƒê·ªÅ xu·∫•t √¥n: ${suggested.char} (ƒëi·ªÉm TB: ${suggested.avg}%)`);
        });
        
        // Reset SRS data
        document.getElementById('btn-reset-srs').addEventListener('click', () => {
            if (confirm('X√≥a to√†n b·ªô d·ªØ li·ªáu luy·ªán t·∫≠p?')) {
                localStorage.removeItem(SRS_KEY);
                srsUpdateUI();
                logResult('üóëÔ∏è ƒê√£ reset d·ªØ li·ªáu SRS');
            }
        });
        
        // ============ TTS - TEXT TO SPEECH ============
        function speakChinese(text) {
            if (!('speechSynthesis' in window)) {
                console.warn('TTS kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£');
                return;
            }
            
            // Cancel any ongoing speech
            speechSynthesis.cancel();
            
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'zh-CN';
            utterance.rate = 0.8; // Ch·∫≠m h∆°n ƒë·ªÉ nghe r√µ
            utterance.pitch = 1;
            
            // T√¨m voice ti·∫øng Trung
            const voices = speechSynthesis.getVoices();
            const chineseVoice = voices.find(v => v.lang.includes('zh'));
            if (chineseVoice) {
                utterance.voice = chineseVoice;
            }
            
            speechSynthesis.speak(utterance);
        }
        
        // Preload voices
        if ('speechSynthesis' in window) {
            speechSynthesis.getVoices();
            speechSynthesis.onvoiceschanged = () => speechSynthesis.getVoices();
        }
    </script>
    
    <script>
        // ============ WORD LIST MANAGER ============
        const FAVORITES_KEY = 'polybiz_favorites';
        const WORDLIST_KEY = 'polybiz_current_wordlist';
        
        let currentWordList = [];
        let currentWordIndex = 0;
        let sessionActive = false;
        
        // Preset data (sample - c√≥ th·ªÉ m·ªü r·ªông)
        const presetData = {
            hsk1: ['Êàë', '‰Ω†', '‰ªñ', 'Â•π', '‰ª¨', 'Ëøô', 'ÈÇ£', 'Âì™', '‰ªÄ', '‰πà', 'Ë∞Å', 'Âá†', 'Â§ö', 'Â∞ë', 'Âæà', 'Â§™', 'ÈÉΩ', '‰πü', '‰∏ç', 'Ê≤°', 'Êúâ', 'ÊòØ', 'Âú®', 'ÁöÑ', '‰∫Ü', 'Âêó', 'Âë¢', 'Âêß', 'Âíå', 'Ë∑ü'],
            hsk2: ['Âõ†', '‰∏∫', 'ÊâÄ', '‰ª•', '‰ΩÜ', 'ÊòØ', 'ËôΩ', 'ÁÑ∂', 'Â¶Ç', 'Êûú', 'Â∞±', 'Êâç', 'Âèà', 'ÂÜç', 'Ëøò', 'Â∑≤', 'Áªè', 'Ê≠£', 'Âú®', 'ÁùÄ', 'Ëøá', 'Ë¶Å', 'ÊÉ≥', 'ËÉΩ', 'ÂèØ', '‰ª•', '‰ºö', 'Â∫î', 'ËØ•', 'ÂøÖ', 'È°ª'],
            hsk3: ['ÂÖ≥', '‰∫é', 'ÂØπ', '‰∫é', 'Ê†π', 'ÊçÆ', 'Êåâ', 'ÁÖß', 'ÈÄö', 'Ëøá', 'Áªè', 'Ëøá', 'Èô§', '‰∫Ü', 'Èô§', 'Èùû', '‰∏ç', 'ÁÆ°', 'Êó†', 'ËÆ∫', 'Âè™', 'Ë¶Å', 'Âè™', 'Êúâ', 'Âç≥', '‰Ωø', 'Âì™', 'ÊÄï', 'ÂÆÅ', 'ÂèØ'],
            hsk4: ['‰πã', 'ÊâÄ', '‰ª•', 'Áî±', '‰∫é', 'Êó¢', 'ÁÑ∂', 'Â∞Ω', 'ÁÆ°', '‰Ωï', 'ÂÜµ', 'Âê¶', 'Âàô', 'Ë¶Å', '‰∏ç', 'ÁÑ∂', '‰∏é', 'ÂÖ∂', '‰∏ç', 'Â¶Ç', 'ÂÆÅ', 'ÊÑø', 'Âèç', 'ËÄå', 'Âèç', 'Ê≠£', 'ÊØï', 'Á´ü', 'Á©∂', 'Á´ü'],
            
            // B·ªô th·ªß
            '‰∫∫': ['‰∫∫', '‰∏™', '‰ª¨', '‰Ω†', '‰ªñ', 'Â•π', '‰Ωç', '‰Ωè', '‰Ωú', '‰ºë', '‰Ωì', '‰Ωï', '‰ΩÜ', '‰Ωé', '‰Ωè', '‰Ω≥', '‰Ωø', '‰æø', '‰ø°', '‰øÆ'],
            'Âè£': ['Âè£', 'ÂêÉ', 'Âêó', 'Âë¢', 'Âêß', 'Âê¨', 'Âëä', 'Âëò', 'Âëº', 'Âíå', 'ÂìÅ', 'Âì™', 'Âî±', 'Âñù', 'Âñú', 'Âò¥', 'Âô®', 'Âõû', 'Âõ†', 'ÂõΩ'],
            'Â•≥': ['Â•≥', 'Â•Ω', 'Â¶à', 'Âßê', 'Â¶π', 'Âßë', 'Â®ò', 'Â©Ü', 'Â™≥', 'Â´Å', 'Â®∂', 'Â¶ª', 'Â•∂', 'Â•π', 'Â¶Ç', 'Âßã', 'Âßî', 'Âßì', 'Â®Å', 'Â®É'],
            'ÂøÉ': ['ÂøÉ', 'ÊÉ≥', 'ÊÄù', 'Âøµ', 'Âøò', 'Âøô', 'Âø´', 'ÊÄï', 'ÊÄ™', 'ÊÅ®', 'ÊÅ©', 'ÊÇ≤', 'ÊÉÖ', 'ÊÉä', 'ÊÉú', 'ÊÑÅ', 'ÊÑø', 'ÊÑü', 'ÊÖ¢', 'ÊáÇ'],
            'Êâã': ['Êâã', 'Êâì', 'Êâæ', 'Êää', 'Êä•', 'Êãâ', 'Êãø', 'Êåá', 'Êåâ', 'ÊåÇ', 'Êç¢', 'Êé•', 'Êé®', 'Êèê', 'Êè°', 'Êëá', 'Êíë', 'Êìç', 'Êì¶', 'Êãç'],
            'Ê∞¥': ['Ê∞¥', 'ÂÜ∞', 'Ê∞∏', 'Ê±Å', 'Ê±ó', 'Ê±ü', 'Ê≤≥', 'Ê≤π', 'Ê≤ª', 'Ê≥ï', 'Ê≥™', 'Ê≥¢', 'Ê¥ó', 'Ê¥ª', 'ÊµÅ', 'ÊµÖ', 'Ê∑±', 'Ê∏Ö', 'Ê∏©', 'Ê∏∏'],
            'ÁÅ´': ['ÁÅ´', 'ÁÅØ', 'ÁÅ∞', 'ÁÇí', 'ÁÇ∏', 'ÁÇπ', 'ÁÉü', 'ÁÉ§', 'ÁÉ≠', 'ÁÖÆ', 'ÁÖß', 'ÁÜü', 'ÁáÉ', 'ÁÉß', 'ÁÑ¶', 'ÁÖé', 'ÁÜÑ', 'ÁÇâ', 'ÁÉ´', 'ÁÑ∞'],
            'Êú®': ['Êú®', 'Êú¨', 'ÊúØ', 'Êú∫', 'ÊùÄ', 'ÊùÇ', 'Êùé', 'Êùë', 'ÊùØ', 'Êùø', 'Êûó', 'Êûú', 'Êûù', 'Êüú', 'Ê†ë', 'Ê°å', 'Ê°•', 'Ê¢¶', 'Ê£µ', 'Ê£Æ'],
            'Èáë': ['Èáë', 'Èíà', 'Èíü', 'Èí¢', 'Èí±', 'ÈìÅ', 'Èì∂', 'Èìú', 'ÈîÅ', 'Èîô', 'Èïú', 'Èìæ', 'ÈìÉ', 'ÈìÖ', 'Èíª', 'ÈîÖ', 'Èîã', 'Èïá', 'Èì∫', 'Èî¶'],
            'Âúü': ['Âúü', 'Âú∞', 'Âú∫', 'Âùê', 'Âù°', 'Âüé', 'Âü∫', 'Â†Ç', 'Â†Ü', 'Â°î', 'Â°ë', 'Â¢É', 'Â¢ô', 'Â¢û', 'Â¢®', 'Â£Å', 'Âùö', 'Âùó', 'Âùè', 'Â°´'],
            
            // Chuy√™n ng√†nh
            business: ['ÂïÜ', '‰∏ö', 'Ë¥∏', 'Êòì', 'Â∏Ç', 'Âú∫', 'ÂÖ¨', 'Âè∏', '‰ºÅ', '‰∏ö', 'Áªè', 'Êµé', 'Êäï', 'ËµÑ', 'Âà©', 'Ê∂¶', 'Êàê', 'Êú¨', 'ÈîÄ', 'ÂîÆ', 'ÂÆ¢', 'Êà∑', 'Âêà', 'Âêå', 'Ë∞à', 'Âà§', 'Á´û', '‰∫â', 'ÂìÅ', 'Áâå'],
            it: ['Áîµ', 'ËÑë', 'ÁΩë', 'Áªú', 'ËΩØ', '‰ª∂', 'Á°¨', '‰ª∂', 'Á®ã', 'Â∫è', '‰ª£', 'Á†Å', 'Êï∞', 'ÊçÆ', 'Êúç', 'Âä°', 'Âô®', 'Á≥ª', 'Áªü', 'Â∫î', 'Áî®', 'ÂºÄ', 'Âèë', 'Êµã', 'ËØï', 'ÂÆâ', 'ÂÖ®', '‰∫ë', 'Á´Ø', 'Êô∫'],
            medical: ['Âåª', 'Èô¢', 'ÁóÖ', '‰∫∫', 'Ê≤ª', 'Áñó', 'ËçØ', 'Áâ©', 'Ê£Ä', 'Êü•', 'Êâã', 'ÊúØ', 'Êä§', 'Â£´', 'ËØä', 'Êñ≠', 'Áóá', 'Áä∂', 'ÂÅ•', 'Â∫∑', 'Áñæ', 'ÁóÖ', 'ÊÑü', 'Êüì', 'È¢Ñ', 'Èò≤', 'Áñ´', 'Ëãó', 'ÊÄ•', 'Êïë'],
            legal: ['Ê≥ï', 'Âæã', 'Ê≥ï', 'Èô¢', 'Âæã', 'Â∏à', 'Ê°à', '‰ª∂', 'Âà§', 'ÂÜ≥', 'Ëµ∑', 'ËØâ', 'Ë¢´', 'Âëä', 'Âéü', 'Âëä', 'ËØÅ', 'ÊçÆ', 'Âêà', 'Âêå', 'ÊùÉ', 'Âà©', '‰πâ', 'Âä°', 'Ëøù', 'Ê≥ï', 'ÁäØ', 'ÁΩ™', 'Âàë', '‰∫ã'],
            finance: ['Èì∂', 'Ë°å', 'Â≠ò', 'Ê¨æ', 'Ë¥∑', 'Ê¨æ', 'Âà©', 'ÊÅØ', 'ËÇ°', 'Á•®', 'Âü∫', 'Èáë', 'ÂÄ∫', 'Âà∏', '‰øù', 'Èô©', 'Á®é', 'Êî∂', 'Ë¥¢', 'Âä°', '‰ºö', 'ËÆ°', 'ÂÆ°', 'ËÆ°', 'È¢Ñ', 'ÁÆó', 'ËµÑ', '‰∫ß', 'Ë¥ü', 'ÂÄ∫'],
            
            // ƒê·∫∑c bi·ªát
            confusing: ['Â∑±', 'Â∑≤', 'Â∑≥', 'Êàä', 'Êàå', 'Êàç', 'Êú™', 'Êú´', 'Âúü', 'Â£´', 'Âπ≤', 'ÂçÉ', '‰∫∫', 'ÂÖ•', 'Â§ß', 'Â§™', 'Â§©', 'Â§´', 'Êó•', 'Êõ∞', 'Áî∞', 'Áî±', 'Áî≤', 'Áî≥', 'ÁõÆ', 'Ëá™', 'ÁôΩ', 'Áôæ'],
            numbers: ['Èõ∂', '‰∏Ä', '‰∫å', '‰∏â', 'Âõõ', '‰∫î', 'ÂÖ≠', '‰∏É', 'ÂÖ´', '‰πù', 'ÂçÅ', 'Áôæ', 'ÂçÉ', '‰∏á', '‰∫ø', '‰∏§', 'Âçä', 'Á¨¨', 'Âá†', 'Â§ö'],
            time: ['Âπ¥', 'Êúà', 'Êó•', 'Êó∂', 'ÂàÜ', 'Áßí', '‰ªä', 'Êòé', 'Êò®', 'Ââç', 'Âêé', 'Êó©', 'Êôö', '‰∏ä', '‰∏ã', 'Âçà', 'Âë®', 'Êòü', 'Êúü', 'Âè∑'],
            colors: ['Á∫¢', 'Ê©ô', 'ÈªÑ', 'Áªø', 'Èùí', 'Ëìù', 'Á¥´', 'Èªë', 'ÁôΩ', 'ÁÅ∞', 'Á≤â', 'Ê£ï', 'Èáë', 'Èì∂', 'ÂΩ©', 'Ëâ≤', 'Ê∑±', 'ÊµÖ', '‰∫Æ', 'Êöó'],
            family: ['Áà∏', 'Â¶à', 'Áà∑', 'Â•∂', 'Â§ñ', 'ÂÖ¨', 'Â©Ü', 'Âì•', 'Âßê', 'Âºü', 'Â¶π', 'Âèî', '‰ºØ', 'Âßë', 'ËàÖ', 'Âß®', 'ÂÑø', 'Â•≥', 'Â≠ô', '‰æÑ']
        };
        
        // Extended char data (pinyin + meaning)
        const extendedCharData = {
            // HSK1 basics
            'Êàë': { pinyin: 'w«í', meaning: 'T√¥i' },
            '‰Ω†': { pinyin: 'n«ê', meaning: 'B·∫°n' },
            '‰ªñ': { pinyin: 'tƒÅ', meaning: 'Anh ·∫•y' },
            'Â•π': { pinyin: 'tƒÅ', meaning: 'C√¥ ·∫•y' },
            '‰ª¨': { pinyin: 'men', meaning: 'C√°c (s·ªë nhi·ªÅu)' },
            'Â•Ω': { pinyin: 'h«éo', meaning: 'T·ªët' },
            'ÊòØ': { pinyin: 'sh√¨', meaning: 'L√†' },
            'ÁöÑ': { pinyin: 'de', meaning: 'C·ªßa' },
            'Âú®': { pinyin: 'z√†i', meaning: '·ªû, t·∫°i' },
            'Êúâ': { pinyin: 'y«íu', meaning: 'C√≥' },
            'Ëøô': { pinyin: 'zh√®', meaning: 'N√†y' },
            'ÈÇ£': { pinyin: 'n√†', meaning: 'Kia' },
            '‰∏≠': { pinyin: 'zh≈çng', meaning: 'Gi·ªØa, Trung' },
            'ÂõΩ': { pinyin: 'gu√≥', meaning: 'N∆∞·ªõc' },
            '‰∫∫': { pinyin: 'r√©n', meaning: 'Ng∆∞·ªùi' },
            'Â§ß': { pinyin: 'd√†', meaning: 'L·ªõn' },
            'Â≠¶': { pinyin: 'xu√©', meaning: 'H·ªçc' },
            // ... th√™m nhi·ªÅu ch·ªØ kh√°c
        };
        
        // Tab switching
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById('tab-' + btn.dataset.tab).classList.add('active');
            });
        });
        
        // Preset selects
        ['hsk-level', 'radical-select', 'topic-select', 'special-select'].forEach(id => {
            document.getElementById(id).addEventListener('change', (e) => {
                if (e.target.value) {
                    const chars = presetData[e.target.value] || [];
                    addToWordList(chars);
                    e.target.value = ''; // Reset select
                }
            });
        });
        
        // Add chars to word list
        function addToWordList(chars) {
            chars.forEach(char => {
                if (char && !currentWordList.includes(char) && /[\u4e00-\u9fff]/.test(char)) {
                    currentWordList.push(char);
                }
            });
            updateWordListUI();
        }
        
        // Update word list UI
        function updateWordListUI() {
            const container = document.getElementById('wordlist-preview-chars');
            const countBadge = document.getElementById('wordlist-count');
            
            countBadge.textContent = currentWordList.length + ' ch·ªØ';
            
            if (currentWordList.length === 0) {
                container.innerHTML = '<span style="color:#666;">Ch∆∞a c√≥ ch·ªØ n√†o</span>';
                return;
            }
            
            container.innerHTML = currentWordList.map((char, i) => `
                <span class="preview-char ${i === currentWordIndex ? 'current' : ''}" 
                      onclick="jumpToChar(${i})" title="Click ƒë·ªÉ ch·ªçn">${char}</span>
            `).join('');
            
            // Update char-select dropdown
            updateCharSelect();
        }
        
        // Update the char-select dropdown
        function updateCharSelect() {
            const select = document.getElementById('char-select');
            select.innerHTML = currentWordList.map(char => {
                const data = extendedCharData[char] || charData[char] || { pinyin: '?', meaning: '?' };
                return `<option value="${char}">${char} (${data.pinyin}) - ${data.meaning}</option>`;
            }).join('');
        }
        
        // Jump to specific char
        function jumpToChar(index) {
            currentWordIndex = index;
            const char = currentWordList[index];
            document.getElementById('char-select').value = char;
            initHanziWriter(char);
            currentChar = char;
            updateWordListUI();
            updateSessionProgress();
        }
        
        // Parse custom input
        document.getElementById('btn-parse-custom').addEventListener('click', () => {
            const text = document.getElementById('custom-chars').value;
            const chars = extractChineseChars(text);
            if (chars.length > 0) {
                addToWordList(chars);
                document.getElementById('custom-chars').value = '';
                logResult(`üìù ƒê√£ th√™m ${chars.length} ch·ªØ t·ª´ input`);
            } else {
                alert('Kh√¥ng t√¨m th·∫•y ch·ªØ H√°n n√†o!');
            }
        });
        
        // Extract Chinese characters from text
        function extractChineseChars(text) {
            const matches = text.match(/[\u4e00-\u9fff]/g) || [];
            return [...new Set(matches)]; // Remove duplicates
        }
        
        // CSV Import
        document.getElementById('csv-import').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                const text = event.target.result;
                const chars = extractChineseChars(text);
                addToWordList(chars);
                logResult(`üì• Import ${chars.length} ch·ªØ t·ª´ CSV`);
            };
            reader.readAsText(file);
        });
        
        // Anki Import
        document.getElementById('anki-import').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                const text = event.target.result;
                const chars = extractChineseChars(text);
                addToWordList(chars);
                logResult(`üÉè Import ${chars.length} ch·ªØ t·ª´ Anki`);
            };
            reader.readAsText(file);
        });
        
        // Favorites
        function loadFavorites() {
            const saved = localStorage.getItem(FAVORITES_KEY);
            return saved ? JSON.parse(saved) : [];
        }
        
        function saveFavorites(chars) {
            localStorage.setItem(FAVORITES_KEY, JSON.stringify(chars));
            document.getElementById('favorites-count').textContent = chars.length + ' ch·ªØ';
        }
        
        document.getElementById('btn-add-favorite').addEventListener('click', () => {
            const text = document.getElementById('custom-chars').value;
            const chars = extractChineseChars(text);
            if (chars.length > 0) {
                const favorites = loadFavorites();
                chars.forEach(c => {
                    if (!favorites.includes(c)) favorites.push(c);
                });
                saveFavorites(favorites);
                logResult(`‚≠ê ƒê√£ th√™m ${chars.length} ch·ªØ v√†o y√™u th√≠ch`);
            }
        });
        
        document.getElementById('btn-load-favorites').addEventListener('click', () => {
            const favorites = loadFavorites();
            if (favorites.length > 0) {
                addToWordList(favorites);
                logResult(`‚≠ê ƒê√£ t·∫£i ${favorites.length} ch·ªØ y√™u th√≠ch`);
            } else {
                alert('Ch∆∞a c√≥ ch·ªØ y√™u th√≠ch n√†o!');
            }
        });
        
        // Update favorites count on load
        document.getElementById('favorites-count').textContent = loadFavorites().length + ' ch·ªØ';
        
        // Shuffle
        document.getElementById('btn-shuffle').addEventListener('click', () => {
            for (let i = currentWordList.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [currentWordList[i], currentWordList[j]] = [currentWordList[j], currentWordList[i]];
            }
            currentWordIndex = 0;
            updateWordListUI();
            logResult('üîÄ ƒê√£ x√°o tr·ªôn danh s√°ch');
        });
        
        // Clear list
        document.getElementById('btn-clear-list').addEventListener('click', () => {
            currentWordList = [];
            currentWordIndex = 0;
            updateWordListUI();
        });
        
        // Start session
        document.getElementById('btn-start-session').addEventListener('click', () => {
            const count = parseInt(document.getElementById('practice-count').value) || 10;
            if (currentWordList.length === 0) {
                alert('H√£y th√™m ch·ªØ v√†o danh s√°ch tr∆∞·ªõc!');
                return;
            }
            
            // Limit to requested count
            if (currentWordList.length > count) {
                currentWordList = currentWordList.slice(0, count);
            }
            
            currentWordIndex = 0;
            sessionActive = true;
            updateWordListUI();
            jumpToChar(0);
            logResult(`üöÄ B·∫Øt ƒë·∫ßu luy·ªán ${currentWordList.length} ch·ªØ`);
            
            // Scroll to practice area
            document.querySelector('.main-grid').scrollIntoView({ behavior: 'smooth' });
        });
        
        // Prev/Next buttons
        document.getElementById('btn-prev-char').addEventListener('click', () => {
            if (currentWordList.length > 0 && currentWordIndex > 0) {
                jumpToChar(currentWordIndex - 1);
            }
        });
        
        document.getElementById('btn-next-char').addEventListener('click', () => {
            if (currentWordList.length > 0 && currentWordIndex < currentWordList.length - 1) {
                jumpToChar(currentWordIndex + 1);
            }
        });
        
        // Update session progress
        function updateSessionProgress() {
            const progress = document.getElementById('session-progress');
            if (currentWordList.length > 0) {
                progress.textContent = `${currentWordIndex + 1}/${currentWordList.length}`;
            } else {
                progress.textContent = '--';
            }
        }
        
        // Initialize with default chars
        currentWordList = ['Â•Ω', '‰Ω†', 'Êàë', '‰ªñ', 'ÊòØ', '‰∏≠', 'ÂõΩ', '‰∫∫', 'Â§ß', 'Â≠¶'];
        updateWordListUI();
    </script>

    <script>
        // ============ AIR WRITING (MediaPipe) - Synced with web-platform ============
        let camera = null;
        let hands = null;
        let persistentCanvas = null;
        let persistentCtx = null;
        let currentChar = 'Â•Ω';
        
        // Drawing state - using simple approach like web-platform
        let drawingEnabled = false;
        let lastPoint = null;
        let isDrawing = false;
        let lastDrawTime = 0;
        let currentStroke = [];
        let strokeHistory = [];
        let strokeCount = 0;
        
        // Smoothing - simple weighted average
        let positionHistory = [];
        const SMOOTH_FACTOR = 5;  // Gi·∫£m ƒë·ªÉ ph·∫£n h·ªìi nhanh h∆°n
        const MIN_MOVE_DISTANCE = 1;  // V·∫Ω m·ªçi di chuy·ªÉn nh·ªè
        const MAX_JUMP_DISTANCE = 200;  // TƒÉng l√™n ƒë·ªÉ kh√¥ng b·ªã ƒë·ª©t khi di chuy·ªÉn nhanh
        const DRAW_INTERVAL = 8;  // V·∫Ω nhanh h∆°n
        
        const drawCanvas = document.getElementById('draw-canvas');
        const drawCtx = drawCanvas.getContext('2d');
        const video = document.getElementById('webcam');

        // Simple smoothing - exactly like web-platform
        function smoothPosition(rawX, rawY) {
            positionHistory.push({ x: rawX, y: rawY });
            if (positionHistory.length > SMOOTH_FACTOR) {
                positionHistory.shift();
            }
            
            let totalWeight = 0;
            let avgX = 0, avgY = 0;
            
            positionHistory.forEach((p, i) => {
                const weight = i + 1;
                avgX += p.x * weight;
                avgY += p.y * weight;
                totalWeight += weight;
            });
            
            return { x: avgX / totalWeight, y: avgY / totalWeight };
        }

        // Check if hand is open (all fingers extended) for erase
        function isHandOpen(landmarks) {
            const indexTip = landmarks[8], indexMcp = landmarks[5];
            const middleTip = landmarks[12], middleMcp = landmarks[9];
            const ringTip = landmarks[16], ringMcp = landmarks[13];
            const pinkyTip = landmarks[20], pinkyMcp = landmarks[17];
            
            const indexUp = indexTip.y < indexMcp.y;
            const middleUp = middleTip.y < middleMcp.y;
            const ringUp = ringTip.y < ringMcp.y;
            const pinkyUp = pinkyTip.y < pinkyMcp.y;
            
            return indexUp && middleUp && ringUp && pinkyUp;
        }

        async function initCamera() {
            const placeholder = document.getElementById('webcam-placeholder');
            const statusBadge = document.getElementById('air-status');
            const handStatus = document.getElementById('hand-status');
            
            try {
                logResult('üìπ ƒêang kh·ªüi t·∫°o camera...');
                
                hands = new Hands({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
                });
                
                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.7,
                    minTrackingConfidence: 0.7
                });
                
                hands.onResults(onHandResults);
                
                camera = new Camera(video, {
                    onFrame: async () => {
                        await hands.send({ image: video });
                    },
                    width: 640,
                    height: 480
                });
                
                await camera.start();
                
                placeholder.style.display = 'none';
                statusBadge.textContent = 'Camera ON';
                statusBadge.className = 'status-badge status-on';
                handStatus.textContent = 'Tracking...';
                handStatus.className = 'perf-value';
                
                drawCanvas.width = 640;
                drawCanvas.height = 480;
                
                persistentCanvas = document.createElement('canvas');
                persistentCanvas.width = 640;
                persistentCanvas.height = 480;
                persistentCtx = persistentCanvas.getContext('2d');
                
                logResult('‚úÖ Camera ƒë√£ b·∫≠t!');
                logResult('üëÜ Gi·ªØ ph√≠m SPACE ƒë·ªÉ v·∫Ω, th·∫£ ra ƒë·ªÉ nh·∫•c b√∫t');
                logResult('üñêÔ∏è X√≤e tay ƒë·ªÉ x√≥a h·∫øt');
                
                document.getElementById('btn-draw-toggle').style.display = 'inline-block';
                
            } catch (err) {
                logResult('‚ùå L·ªói camera: ' + err.message);
                statusBadge.textContent = 'L·ªói';
                statusBadge.className = 'status-badge status-off';
            }
        }

        function onHandResults(results) {
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            
            // Draw grid
            const gridSize = 340;
            const gridX = (drawCanvas.width - gridSize) / 2;
            const gridY = (drawCanvas.height - gridSize) / 2 + 15;
            
            // Grid background
            drawCtx.fillStyle = 'rgba(255, 255, 255, 0.08)';
            drawCtx.fillRect(gridX, gridY, gridSize, gridSize);
            
            // Grid border
            drawCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            drawCtx.lineWidth = 3;
            drawCtx.strokeRect(gridX, gridY, gridSize, gridSize);
            
            // Grid lines (Á±≥Â≠óÊ†º)
            drawCtx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            drawCtx.lineWidth = 1;
            drawCtx.setLineDash([5, 5]);
            drawCtx.beginPath();
            drawCtx.moveTo(gridX, gridY + gridSize/2);
            drawCtx.lineTo(gridX + gridSize, gridY + gridSize/2);
            drawCtx.moveTo(gridX + gridSize/2, gridY);
            drawCtx.lineTo(gridX + gridSize/2, gridY + gridSize);
            drawCtx.moveTo(gridX, gridY);
            drawCtx.lineTo(gridX + gridSize, gridY + gridSize);
            drawCtx.moveTo(gridX + gridSize, gridY);
            drawCtx.lineTo(gridX, gridY + gridSize);
            drawCtx.stroke();
            drawCtx.setLineDash([]);
            
            // Target character
            if (currentChar) {
                drawCtx.font = `${gridSize * 0.8}px "Noto Sans SC", "Microsoft YaHei", sans-serif`;
                drawCtx.fillStyle = 'rgba(100, 150, 255, 0.15)';
                drawCtx.textAlign = 'center';
                drawCtx.textBaseline = 'middle';
                drawCtx.fillText(currentChar, gridX + gridSize/2, gridY + gridSize/2 + 10);
            }
            
            // Draw saved strokes
            if (persistentCtx) {
                drawCtx.drawImage(persistentCanvas, 0, 0);
            }
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const indexTip = landmarks[8];
                
                const rawX = (1 - indexTip.x) * drawCanvas.width;
                const rawY = indexTip.y * drawCanvas.height;
                const smoothed = smoothPosition(rawX, rawY);
                const x = smoothed.x;
                const y = smoothed.y;
                
                const inGrid = x >= gridX && x <= gridX + gridSize &&
                               y >= gridY && y <= gridY + gridSize;
                
                // Check for ERASE gesture (open hand) - only when NOT drawing
                if (!drawingEnabled && isHandOpen(landmarks)) {
                    const palmCenter = landmarks[9];
                    const palmX = (1 - palmCenter.x) * drawCanvas.width;
                    const palmY = palmCenter.y * drawCanvas.height;
                    
                    // Draw erase indicator
                    drawCtx.beginPath();
                    drawCtx.arc(palmX, palmY, 50, 0, 2 * Math.PI);
                    drawCtx.strokeStyle = '#ef4444';
                    drawCtx.lineWidth = 3;
                    drawCtx.stroke();
                    drawCtx.fillStyle = 'rgba(239, 68, 68, 0.2)';
                    drawCtx.fill();
                    
                    // X icon
                    drawCtx.beginPath();
                    drawCtx.moveTo(palmX - 20, palmY - 20);
                    drawCtx.lineTo(palmX + 20, palmY + 20);
                    drawCtx.moveTo(palmX + 20, palmY - 20);
                    drawCtx.lineTo(palmX - 20, palmY + 20);
                    drawCtx.strokeStyle = '#ef4444';
                    drawCtx.lineWidth = 4;
                    drawCtx.stroke();
                    
                    document.getElementById('hand-status').textContent = 'üñêÔ∏è X√≤e tay = X√≥a h·∫øt';
                    document.getElementById('hand-status').className = 'perf-danger';
                    
                    // Clear all
                    clearCanvas();
                    return;
                }
                
                // DRAW MODE - when Space is held
                if (drawingEnabled && inGrid) {
                    if (!lastPoint) {
                        lastPoint = { x, y };
                        currentStroke = [{ x, y }];
                        strokeCount++;
                    }
                    
                    const dist = Math.sqrt(
                        Math.pow(x - lastPoint.x, 2) + 
                        Math.pow(y - lastPoint.y, 2)
                    );
                    
                    // V·∫Ω n·∫øu c√≥ di chuy·ªÉn v√† kh√¥ng nh·∫£y qu√° xa
                    if (dist >= MIN_MOVE_DISTANCE && dist < MAX_JUMP_DISTANCE) {
                        persistentCtx.beginPath();
                        persistentCtx.moveTo(lastPoint.x, lastPoint.y);
                        persistentCtx.lineTo(x, y);
                        persistentCtx.strokeStyle = '#3b82f6';
                        persistentCtx.lineWidth = 5;
                        persistentCtx.lineCap = 'round';
                        persistentCtx.lineJoin = 'round';
                        persistentCtx.stroke();
                        
                        currentStroke.push({ x, y });
                        lastPoint = { x, y };
                    } else if (dist >= MAX_JUMP_DISTANCE) {
                        // N·∫øu nh·∫£y qu√° xa, b·∫Øt ƒë·∫ßu ƒëi·ªÉm m·ªõi thay v√¨ b·ªè qua
                        lastPoint = { x, y };
                        currentStroke.push({ x, y });
                    }
                    
                    isDrawing = true;
                    
                    // Green indicator when drawing
                    drawCtx.beginPath();
                    drawCtx.arc(x, y, 10, 0, 2 * Math.PI);
                    drawCtx.fillStyle = '#22c55e';
                    drawCtx.fill();
                    
                    document.getElementById('hand-status').textContent = `‚úçÔ∏è ƒêang v·∫Ω | N√©t: ${strokeCount}`;
                    document.getElementById('hand-status').className = 'perf-value';
                    
                } else {
                    // Not drawing - save stroke if was drawing
                    if (isDrawing && currentStroke.length > 1) {
                        strokeHistory.push([...currentStroke]);
                    }
                    
                    lastPoint = null;
                    isDrawing = false;
                    currentStroke = [];
                    
                    // Yellow/red indicator
                    drawCtx.beginPath();
                    drawCtx.arc(x, y, 6, 0, 2 * Math.PI);
                    drawCtx.fillStyle = inGrid ? 'rgba(249, 158, 11, 0.8)' : 'rgba(255, 100, 100, 0.5)';
                    drawCtx.fill();
                    
                    const msg = inGrid ? 'üëÜ Gi·ªØ SPACE ƒë·ªÉ v·∫Ω' : '‚ö†Ô∏è ƒê∆∞a tay v√†o √¥';
                    document.getElementById('hand-status').textContent = msg;
                    document.getElementById('hand-status').className = 'perf-warning';
                }
                
            } else {
                document.getElementById('hand-status').textContent = 'üñêÔ∏è Kh√¥ng th·∫•y tay';
                document.getElementById('hand-status').className = 'perf-danger';
                
                if (isDrawing && currentStroke.length > 1) {
                    strokeHistory.push([...currentStroke]);
                }
                
                lastPoint = null;
                isDrawing = false;
                currentStroke = [];
                positionHistory = [];
            }
        }

        function clearCanvas() {
            strokeHistory = [];
            currentStroke = [];
            strokeCount = 0;
            
            if (persistentCtx) {
                persistentCtx.clearRect(0, 0, persistentCanvas.width, persistentCanvas.height);
            }
        }

        function redrawCanvas() {
            if (!persistentCtx) return;
            
            persistentCtx.clearRect(0, 0, persistentCanvas.width, persistentCanvas.height);
            
            strokeHistory.forEach(stroke => {
                if (stroke.length < 2) return;
                
                persistentCtx.beginPath();
                persistentCtx.moveTo(stroke[0].x, stroke[0].y);
                
                for (let i = 1; i < stroke.length; i++) {
                    persistentCtx.lineTo(stroke[i].x, stroke[i].y);
                }
                
                persistentCtx.strokeStyle = '#3b82f6';
                persistentCtx.lineWidth = 5;
                persistentCtx.lineCap = 'round';
                persistentCtx.lineJoin = 'round';
                persistentCtx.stroke();
            });
        }

        document.getElementById('btn-camera').addEventListener('click', initCamera);
        
        // SPACE KEY ƒë·ªÉ v·∫Ω
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && camera) {
                e.preventDefault();
                drawingEnabled = true;
                document.getElementById('btn-draw-toggle').classList.add('btn-active');
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                drawingEnabled = false;
                document.getElementById('btn-draw-toggle').classList.remove('btn-active');
                
                if (isDrawing && currentStroke.length > 1) {
                    strokeHistory.push([...currentStroke]);
                }
                lastPoint = null;
                isDrawing = false;
                currentStroke = [];
            }
        });
        
        // N√öT "Gi·ªØ ƒë·ªÉ v·∫Ω" - mouse events
        const btnDrawToggle = document.getElementById('btn-draw-toggle');
        btnDrawToggle.addEventListener('mousedown', () => {
            if (camera) {
                drawingEnabled = true;
                btnDrawToggle.classList.add('btn-active');
            }
        });
        btnDrawToggle.addEventListener('mouseup', () => {
            drawingEnabled = false;
            btnDrawToggle.classList.remove('btn-active');
            if (isDrawing && currentStroke.length > 1) {
                strokeHistory.push([...currentStroke]);
            }
            lastPoint = null;
            isDrawing = false;
            currentStroke = [];
        });
        btnDrawToggle.addEventListener('mouseleave', () => {
            drawingEnabled = false;
            btnDrawToggle.classList.remove('btn-active');
        });
        // Touch events cho mobile
        btnDrawToggle.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (camera) {
                drawingEnabled = true;
                btnDrawToggle.classList.add('btn-active');
            }
        });
        btnDrawToggle.addEventListener('touchend', (e) => {
            e.preventDefault();
            drawingEnabled = false;
            btnDrawToggle.classList.remove('btn-active');
            if (isDrawing && currentStroke.length > 1) {
                strokeHistory.push([...currentStroke]);
            }
            lastPoint = null;
            isDrawing = false;
            currentStroke = [];
        });
        
        document.getElementById('btn-undo').addEventListener('click', () => {
            if (strokeHistory.length > 0) {
                strokeHistory.pop();
                strokeCount = Math.max(0, strokeCount - 1);
                redrawCanvas();
                logResult(`‚Ü©Ô∏è Undo n√©t ${strokeCount + 1}`);
            }
        });
        
        document.getElementById('btn-clear').addEventListener('click', () => {
            clearCanvas();
            logResult('üóëÔ∏è ƒê√£ x√≥a canvas');
        });
    </script>

    <script>
        // ============ TEST & LOGGING ============
        function toggleResults() {
            const results = document.getElementById('test-results');
            const toggle = document.getElementById('results-toggle');
            if (results.style.display === 'none') {
                results.style.display = 'block';
                toggle.textContent = '‚ñ≤';
            } else {
                results.style.display = 'none';
                toggle.textContent = '‚ñº';
            }
        }
        
        function logResult(msg) {
            const results = document.getElementById('test-results');
            const time = new Date().toLocaleTimeString();
            results.innerHTML += `<div>[${time}] ${msg}</div>`;
            results.scrollTop = results.scrollHeight;
        }

        async function runFullTest() {
            const btn = document.getElementById('btn-full-test');
            btn.disabled = true;
            btn.textContent = 'üîÑ ƒêang test...';
            
            logResult('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            logResult('üß™ B·∫ÆT ƒê·∫¶U FULL TEST (30 gi√¢y)');
            logResult('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            
            // Device info
            logResult(`üì± Device: ${navigator.userAgent.substring(0, 50)}...`);
            logResult(`üñ•Ô∏è Screen: ${window.screen.width}x${window.screen.height}`);
            logResult(`üíæ Memory: ${navigator.deviceMemory || 'N/A'} GB`);
            logResult(`üîß Cores: ${navigator.hardwareConcurrency || 'N/A'}`);
            
            // Test 1: Hanzi Writer Animation
            logResult('');
            logResult('üìù Test 1: Hanzi Writer Animation...');
            const animStart = performance.now();
            for (let i = 0; i < 5; i++) {
                await new Promise(resolve => {
                    writer.animateCharacter({ onComplete: resolve });
                });
            }
            const animTime = performance.now() - animStart;
            logResult(`   ‚úÖ 5 animations: ${Math.round(animTime)}ms (${Math.round(animTime/5)}ms/each)`);
            
            // Test 2: Character switching
            logResult('');
            logResult('üìù Test 2: Character Switching...');
            const chars = ['Â•Ω', '‰Ω†', 'Êàë', '‰ªñ', 'ÊòØ'];
            const switchStart = performance.now();
            for (const char of chars) {
                initHanziWriter(char);
                await new Promise(r => setTimeout(r, 100));
            }
            const switchTime = performance.now() - switchStart;
            logResult(`   ‚úÖ 5 switches: ${Math.round(switchTime)}ms (${Math.round(switchTime/5)}ms/each)`);
            
            // Test 3: FPS stability
            logResult('');
            logResult('üìù Test 3: FPS Stability (10s)...');
            await new Promise(r => setTimeout(r, 10000));
            const avgFps = perfData.fps.length > 0 
                ? Math.round(perfData.fps.reduce((a,b) => a+b, 0) / perfData.fps.length) 
                : 0;
            const minFps = perfData.fps.length > 0 ? Math.min(...perfData.fps) : 0;
            logResult(`   ‚úÖ Avg FPS: ${avgFps}, Min FPS: ${minFps}`);
            
            // Test 4: Memory usage
            logResult('');
            logResult('üìù Test 4: Memory Usage...');
            if (perfData.memory.length > 0) {
                const avgMem = Math.round(perfData.memory.reduce((a,b) => a+b, 0) / perfData.memory.length);
                const maxMem = Math.max(...perfData.memory);
                logResult(`   ‚úÖ Avg Memory: ${avgMem}MB, Max: ${maxMem}MB`);
            } else {
                logResult('   ‚ö†Ô∏è Memory API kh√¥ng kh·∫£ d·ª•ng (ch·ªâ Chrome)');
            }
            
            // Summary
            logResult('');
            logResult('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            logResult('üìä K·∫æT QU·∫¢ T·ªîNG H·ª¢P');
            logResult('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            
            let grade = 'A';
            let recommendation = '';
            
            if (avgFps >= 30 && minFps >= 20) {
                grade = 'A';
                recommendation = '‚úÖ TUY·ªÜT V·ªúI! M√°y ch·∫°y m∆∞·ª£t m√†.';
            } else if (avgFps >= 20 && minFps >= 10) {
                grade = 'B';
                recommendation = 'üëç T·ªêT. C√≥ th·ªÉ d√πng ƒë∆∞·ª£c, ƒë√¥i khi h∆°i lag.';
            } else if (avgFps >= 15) {
                grade = 'C';
                recommendation = '‚ö†Ô∏è T·∫†M ƒê∆Ø·ª¢C. N√™n t·∫Øt Air Writing, ch·ªâ d√πng Quiz.';
            } else {
                grade = 'D';
                recommendation = '‚ùå Y·∫æU. Ch·ªâ n√™n d√πng Animation c∆° b·∫£n.';
            }
            
            logResult(`üèÜ Grade: ${grade}`);
            logResult(recommendation);
            logResult('');
            logResult('üí° Y√äU C·∫¶U T·ªêI THI·ªÇU ƒê·ªÄ XU·∫§T:');
            logResult('   - CPU: Intel i3 / AMD Ryzen 3 tr·ªü l√™n');
            logResult('   - RAM: 4GB (8GB recommended)');
            logResult('   - Browser: Chrome/Edge m·ªõi nh·∫•t');
            logResult('   - Webcam: 720p (cho Air Writing)');
            logResult('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            
            btn.disabled = false;
            btn.textContent = 'üß™ Ch·∫°y Full Test (30 gi√¢y)';
        }

        document.getElementById('btn-full-test').addEventListener('click', runFullTest);

        // ============ INIT ============
        window.onload = () => {
            getDeviceInfo();
            updatePerformance();
            initHanziWriter('Â•Ω');
            srsUpdateUI(); // Load SRS data
            logResult('ÔøΩ  PolyBiz AI MVP ƒë√£ s·∫µn s√†ng!');
            logResult('üí° Tip: Nh·∫•n "Full Test" ƒë·ªÉ ki·ªÉm tra hi·ªáu nƒÉng m√°y.');
            logResult('üîä B·∫≠t/t·∫Øt ph√°t √¢m ·ªü panel "Th·ªëng k√™"');
        };
    </script>
</body>
</html>